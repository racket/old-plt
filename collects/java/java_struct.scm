;; Mario Latendresse, 16 May 2000.
;;
;; Structure definitions for MzScheme. See java.lal for their use.

;; (include "gambitMacros.scm")

#| The following node structures are for the AST of the java
programs. They are directly used by the parser. See java.lal

|#

;; TypeName, (u [str] str sym)
;; PrimitiveType, (u 'byte 'char 'short 'int 'long 'float 'double)
;; Type, (u PrimitiveType 'undefined 'void (s type-class)
;;

;; package, (s n-qName)
(define-struct n-program       (package imports types fileName))

;;  Contract Java 
(define-struct n-prepost       (pre post src))

;; For operators old and result in post-condition contracts.
;; op: (u 'result 'old)
;; expr: 
(define-struct n-specCExpr     (op expr src))

;; modifiers, [sym]
;; type, typeSpecifier
;; id, str
;; parmList, [n-parm] 
;; throws,   [n-qName]
;; block,    (s n-block)
;; mt, (s mt). Inserted by semantic analysis.
;; prepost,  (s prepost)
(define-struct n-method  
  (modifiers type id parmList dim throws block src mt prepost)) 

;; final,    bool
;; typeName, (u TypeName PrimitiveType)
;; dim,      num. 
(define-struct n-typeSpecifier (final typeName dim src))

;; id, str; dim, num.
(define-struct n-declaratorName (id dim src))

;; name, [str]
;; src,  (s n-src)
;; access, [varAccess]
(define-struct n-qName (name src access))

;; i, (u #f int). It is an int only if it is a local access.
;; jvmType, For local access, as generated by T->jvmType
;;          For field access, as generated by T->jvmPool
;; className. qName. The full name of the class.
;; fieldName, str. The name of the field.
;; static?, #t if it is a static reference (getstatic instruction)
(define-struct varAccess (i jvmType className fieldName static?))

(define-struct n-specialName (name src))

;; op, sym; left, Expression; right, Expression
;; type, (u sym '("java" "lang" "String")). 
;;       Type of the resulting operation.
(define-struct n-op         (op left right src type))

;; typeSpecifier, (s n-typeSpecifier)
;; type-var, (s type-var)
(define-struct n-instanceof (expr typeSpecifier src typeVar))

;; type, (u 'char 'int 'long 'float 'double '("java" "lang" "String"))
;; value, (u int float str) For a char, it is translated to an integer.
(define-struct n-literal    (type value src))

;; value, (u "true" "false")
(define-struct n-boollit    (value src))

;; declaratorName, n-declaratorName; 
;; initializer, (u n-arrayInit Expression)
;; After semantic analysis:
;; access, (s varAccess)
;; initializer,(u #f (s e-r))
(define-struct n-varInit    (declaratorName initializer src access))

;; exprs, [expr]. These expressions comes from the {...} list
;; of an initializer.
;; After semantic analysis:
;; exprs, [(s e-r)]
;; type, the type of the arrayInit. (after semantic analysis)
(define-struct n-arrayInit  (exprs src type))

;; static, bool; 
;; block, n-block
(define-struct n-initz      (static block src))

;; declStmts, (u 'none [(u Statement n-localVarDecl)])
(define-struct n-block      (declStmts src))

;; final,          bool
;; typeSpecifier,  (s n-typeSpecifier)
;; declaratorName, (s n-declaratorName)
(define-struct n-parm  (typeSpecifier declaratorName src))

(define-struct n-emptyStatement (src))

;; expr: Expression  then : Statement  , else : Statement
(define-struct n-if          (expr Sthen Selse src))

;; expr, Expression
;; block, (s n-block)
;; pairs, #f
;; After semantic analysis:
;; casesStmts, [(c . stmts)]. For constant value c execute
;;             stmts. c can be 'default.
(define-struct n-switch      (expr block src casesStmts)) 

;; cond : Expression, statement : Statement
(define-struct n-while       (expr statement src))

(define-struct n-do          (statement expr src))

;; init, [Expression] or LocalVariableDeclarationStatement
;; cond, Expression
;; incr, [Expression]
;; statement, Statement
(define-struct n-for         (init expr incr statement src))

;; field, (u Primitive (s n-qName) Expression (s n-special))
;; id, str  (I have removed 'this and 'class)
;; access, (s varAccess)
(define-struct n-fieldAccess (field id src access))

;; modifiers, [sym]; 
;; type, n-typeSpecifier; 
;; vars, [(u n-varInit n-declaratorName)]
(define-struct n-fieldDecl (modifiers type vars src))

;; qName, a qName.
;; star, bool
(define-struct n-import       (qName star src))

;; header, n-header; 
;; members, [(u (s n-fieldDecl) (s n-method)
;;              (s n-methodInterface) ;; For contract Java
;;              (s n-initz) (s n-type)]
(define-struct n-type         (header members src))
(define-struct n-header       (modifiers classWord id extendings interfaces src))


;; id, str.
;; nodeLabel, str after semantic analysis it is (s n-label)
(define-struct n-break        (id src nodeLabel))
(define-struct n-continue     (id src nodeLabel))

;; expr, Expression
;; src, n-src
;; access, if a return has an expression and is in an try with a
;;         finally, it needs to temporarily store the 
;;         expression value before executing the finally.
(define-struct n-return       (expr src access))

(define-struct n-throw        (expr src))

;; iLocals, int. A local variable offset. Used for the synchronized
;; value and the return address of the ``finally'' subroutine (for the
;; break, continue and return statements)
(define-struct n-syn (expr statement iLocals src))

;; block, (s n-block)
;; catches, [(s n-catching)]
;; finally, (s n-block)
;; iRetAdr, int. The the local variable offset for the return address.
(define-struct n-try          (block catches finally src iRetAdr))

;; catchheader, (s n-catch)
;; block,       (s n-block)
(define-struct n-catching     (catchHeader block src))

;; type, (s n-typeSpecifier)
;; id, str
;; access, (s varAccess) For the local catch variable.
(define-struct n-catch       (type id src access))

;; array, (u (s n-qName) ComplexPrimary)
;; index, Expression
;; basicType, the basicType of the array. It is a symbol
;; for the generation of JVM code.
(define-struct n-arrayAccess  (array index src basicType))

;; expr, (u n-arrayAlloc n-classAlloc)
;; qualifiedName, 
(define-struct n-alloc        (qualifiedName expr src))

;; typeMethod, (s tyM) the type of the method called.
(define-struct n-classAlloc   (typeName argList fieldDeclarations 
					   src typeMethod))

;; typeName, (u PrimitiveType n-qName)
;; dimExprs, [Expression]
;; dims, int
;; 
(define-struct n-arrayAlloc   (typeName dimExprs dims initializers src))

;; lhs, generates by UnaryExpression
;; op, sym. = *= /= %= += -= <<= >>= >>>= &= ^= or=
;; rhs, generates by AssignmentExpression
(define-struct n-assignment   (lhs op rhs src))


(define-struct n-question     (expr Sthen Selse src)) 

;; cast
;; typeCast, the type of cast.
(define-struct n-cast         (cast expr src typeCast))

;; op, '++ and '--
(define-struct n-postExpr     (expr op src))

;; op, '++ '-- '+ '- '~ '!
(define-struct n-unary        (op expr src))

;; method, (u n-qName 'super 'this 'null n-literal 
;;                n-boollit n-specialName
;;                n-arrayAccess n-fieldAccess n-call)
;; argList, [Expression]
(define-struct n-call         (method argList src method-type))

(define-struct n-case         (constExpr src))
;; qName, (s n-qName)
;; stmt, a statement
;; jvmLabel, (s targetLabel)
(define-struct n-label        (qName stmt src jvmLabel))

;; vars, [(u (s n-declaratorName) (s n-varInit))]
;; type, (s n-typeSpecifier)
(define-struct n-localVarDecl (type vars src))

;; The following two nodes are used to have pointers towards the
;; source file.

;; line, int
;; col, int
(define-struct n-src  (line col))

;; s,    str (this is the lexeme)
;; line, int
;; col,  int
(define-struct lexeme    (s line col))

;; ------------------------------------------------------------------

;; The following are used by semantic analysis.

;; Type = (u sym n-qName type-class type-interface tyM 
;;               n-typeSpecifier)

;; id, (u str [str])  
;; type, Type
;; kind, sym 
;; value, (u #f int float bool str (s n-block) 
;;           [(s n-fieldDecl)])
;;         A structure n-block is for a method.
;;         
;; src, the position of definition of that id in the source.
;; mdfs, modifiers of id.
;; access, (u #f (s varAccess))
;;         #f means that it cannot be accessed. For example
;;         for a type.
(define-struct mt (id type kind value src mdfs access))

;; A global table.
;; names,    [(cons id (s mt))]
;; imports,  [qualifiedName]  (these are the lazy imports)
(define-struct Gtable  (names imports))

;; A class or interface (type) table.
;; names,    [(cons id (s mt))]
;; up-table, (s Gtable)
(define-struct Ttable  (names up-table))

;; Local table.
;; names,    [(cons id (s mt))]
;; up-table, (u #f (s Ltable))
;; nbWords, current number of words used by all locals on stack
;; typeTable, (s Ttable) the table of the enclosing type.
(define-struct Ltable  (names up-table nbWords typeTable))

(define (table-names table)
  (if (Ltable? table) 
      (Ltable-names table)
      (if (Ttable? table)
	  (Ttable-names table)
	  (if (Gtable? table)
	      (Gtable-names table)
	      (error "CE, table-names, unknown table: " table)))))

(define (table-up-table table)
  (if (Ltable? table) 
      (Ltable-up-table table)
      (if (Ttable? table)
	  (Ttable-up-table table)
	  #f)))

;; Given a table or type, returns its global table.
;; I: T, (u (s table) (s type))
;; O: (u #f (s table))
(define (get-GTable T)
  ;; TBF can this test on T be eliminated?
  (and T
       (cond ((type? T) (get-Gtable (type-table T)))
	     ((tyA? T)  (get-Gtable (type-table (tyA-type T))))
	     ((Gtable? T) T)
	     ((Ltable? T) (get-Gtable (Ltable-typeTable T)))
	     ((Ttable? T) (get-GTable (Ttable-up-table T)))
	     (else (error "CE, get-Gtable, unkown case " T)))))
      
;; The structure to represent a class or interface.
;;
;; cl?,        bool, #t iff the type is a class.
;; name,       (u str [str])
;; modifiers,  [sym]
;; extend,     (s n-qName)
;; implements, [(s n-qName)]
;; table,      (s Ttable) 
;; inside?     bool, #t iff this class comes from the compiled source.
(define-struct type (cl? name mdfs extend interfaces table inside?))

;; Type method.
;; mName,  str. The method name.
;; mdfs,   [sym]. The modifiers of the method.
;; rtype, Type
;; parm-types,  [Type]
;; throws,      [n-qName] 
;; table,       (s Ltable)
;; classType,   (u qName (s type))
;; nbWords,     int. Nb words taken by parameters and locals 
;;                   (including this)
;; contract,  (u #f 'contract 'wrapper 'blame). 
;;            To identify methods with a contract and
;;            new methods added to handle them.
;;            #f => method has nothing to do with contracts.
(define-struct tyM  (mName mdfs rType parm-types throws table
			   classType nbWords contract src))

;; Type array.
;; dim, int
;; type, (u Type TypeName)
(define-struct tyA    (dim type))

;; Expression result, used as result in ver-expr-sem.
;;
;; t, Type. If it is primitive it must not have any modifiers.
;; v, (u #f int float). The constant value of the expression.
;; variable?, bool  If #t, the expression can be assigned.
;; src,   (s n-src)
;; node, the expression node that resulted with this type.
(define-struct e-r   (t v variable? src node))

;; access-fleags, int
;; name-index, int
;; descriptor-index, int
;; attributes, [(s clAttribute)]
(define-struct clField (access-flags name-index descriptor-index 
				     attributes-length attributes))

;; info, (s clInfo)			 
(define-struct clAttribute (name-index attribute-length info))

;; type, 'unknown 'constantvalue 'code 'exception
;; infoinfo,(u [byte] 16bitword (s clCode) (s exception))
(define-struct clInfo (type infoinfo))

;; nb-exceptions, 16bitword
;; index-table, [16bitword]
(define-struct exception (nb-exceptions index-table))


(define-struct clCode (max-stack max-locals code-length code
				 exception-table-length
				 exception-table
				 attributes-count
				 attributes))

;; A label as an operand in an instruction of the bytecode.
;; label, sym.
;; nb-bytes, int. The number of bytes to use for the offset.
(define-struct label        (label nb-bytes))

;; A label as an instruction in the bytecode.
;; label, sym
(define-struct targetLabel  (label))

;; label, symbol, a label generated by Ijvm
;; kind, (u 'start 'end 'catch)
;;       'start means the beginning of a try block
;;       'end means the end of a try block
;;       'catch means the beginning of a catch block
;;       'finally means the beginning of a finally block
;; type, (u #f str)
;;       The typeName as it is inserted in the exception table
;;       of the class file. It is str only for 'catch. The #f
;;       signals that the block is for any exception. It is
;;       used to implement the short block to jump to the
;;       finally block in case of any exception.
(define-struct tryLabel (label kind type))
