;"Template.scm" configuration template of *features* for Scheme	-*-scheme-*-
; Copyright (C) 1991, 1992, 1993 Aubrey Jaffer.

; Compatibility file for MzScheme --
;   http://www.cs.rice.edu/CS/PLT/packages/mzscheme/
; -- and DrScheme --
;   http://www.cs.rice.edu/CS/PLT/packages/drscheme/
; -- produced by Shriram Krishnamurthi <shriram@cs.rice.edu>,
; Mon Feb 10 12:03:53 CST 1997
;
; To configure for DrScheme instead of MzScheme, delete the
;   (require-library "pretty.ss")
; below, then follow remaining instructions.

(require-library "pretty.ss")

; Set appropriate values for
; 1. default-software-type
; 2. implementation-vicinity
; 3. library-vicinity
; 
; There are two system dependencies:
; a. current-time is bound to a platform-dependent function, so it 
;    may not work on non-Unix (or even all Unix) systems.
; b. most-positive-fixnum is bound to a 32-bit-specific value.
;
; Nothing else should require changing.
;
; If you have problems or comments, please use the above email address.
; Do NOT contact Aubrey Jaffer with problems in this file!

; Now, for the rest of the spiel ...

;Permission to copy this software, to redistribute it, and to use it
;for any purpose is granted, subject to the following restrictions and
;understandings.
;
;1.  Any copy made of this software must include this copyright notice
;in full.
;
;2.  I have made no warrantee or representation that the operation of
;this software will be error-free, and I am under no obligation to
;provide any services, by way of maintenance, update, or otherwise.
;
;3.  In conjunction with products arising from the use of this
;material, there shall be no use of my name in any advertising,
;promotional, or sales literature without prior written consent in
;each case.

;;; (software-type) should be set to the generic operating system type.
;;; UNIX, VMS, MACOS, AMIGA and MS-DOS are supported.

(define (software-type)
  (case (system-type)
    [(unix beos) 'UNIX]
    [(windows) 'MS-DOS]
    [(macos) 'MACOS]))

;;; (scheme-implementation-type) should return the name of the scheme
;;; implementation loading this file.

(define (scheme-implementation-type) '|MzScheme|)

;;; (scheme-implementation-version) should return a string describing
;;; the version the scheme implementation loading this file.

(define scheme-implementation-version version)

;;; (implementation-vicinity) should be defined to be the pathname of
;;; the directory where any auxillary files to your Scheme
;;; implementation reside.

(define implementation-vicinity
  (let ([path
	 (or (getenv "PLTHOME")
	     (with-handlers ([void (lambda (x) #f)])
	       (let ([p (collection-path "mzlib")])
		 (let*-values ([(base name dir?) (split-path p)]
			       [(base name dir?) (split-path base)])
		   (and (string? base) base))))
	     (case (system-type)
	       ((unix) "/usr/local/lib/plt")
	       ((windows) "C:\\Program Files\\PLT")
	       ((macos) "My Disk:plt:")))])
    (lambda () path)))

;;; (library-vicinity) should be defined to be the pathname of the
;;; directory where files of Scheme library functions reside.

(define library-vicinity
  (let ((library-path
	 (or
	  ;; Use this getenv if your implementation supports it.
	  (getenv "SCHEME_LIBRARY_PATH")
	  ;; Use this path if your scheme does not support GETENV
	  ;; or if SCHEME_LIBRARY_PATH is not set.
	  (case (software-type)
	    ((UNIX) "/usr/local/lib/slib/")
	    ((VMS) "lib$scheme:")
	    ((MS-DOS) "C:\\SLIB\\")
	    (else "")))))
    (lambda () library-path)))

;;; *FEATURES* should be set to a list of symbols describing features
;;; of this implementation.  Suggestions for features are:

(define *features*
      '(
	source				;can load scheme source files
					;(slib:load-source "filename")
	compiled			;can load compiled files
					;(slib:load-compiled "filename")
	rev4-report			;conforms to
;	rev3-report			;conforms to
;	ieee-p1178			;conforms to
;	sicp				;runs code from Structure and
					;Interpretation of Computer
					;Programs by Abelson and Sussman.
	rev4-optional-procedures	;LIST-TAIL, STRING->LIST,
					;LIST->STRING, STRING-COPY,
					;STRING-FILL!, LIST->VECTOR,
					;VECTOR->LIST, and VECTOR-FILL!
;	rev2-procedures			;SUBSTRING-MOVE-LEFT!,
					;SUBSTRING-MOVE-RIGHT!,
					;SUBSTRING-FILL!,
					;STRING-NULL?, APPEND!, 1+,
					;-1+, <?, <=?, =?, >?, >=?
	multiarg/and-			;/ and - can take more than 2 args.
	multiarg-apply			;APPLY can take more than 2 args.
	rationalize
	delay				;has DELAY and FORCE
	with-file			;has WITH-INPUT-FROM-FILE and
					;WITH-OUTPUT-FROM-FILE
	string-port			;has CALL-WITH-INPUT-STRING and
					;CALL-WITH-OUTPUT-STRING
	transcript			;TRANSCRIPT-ON and TRANSCRIPT-OFF
	char-ready?
;	macro				;has R4RS high level macros
	defmacro			;has Common Lisp DEFMACRO
	eval				;SLIB:EVAL is single argument eval
;	record				;has user defined data structures
	values				;proposed multiple values
	dynamic-wind			;proposed dynamic-wind
	ieee-floating-point		;conforms to
	full-continuation		;can return multiple times
;	object-hash			;has OBJECT-HASH

;	sort
;	queue				;queues
	pretty-print
;	object->string
;	format
;	trace				;has macros: TRACE and UNTRACE
;	compiler			;has (COMPILER)
;	ed				;(ED) is editor
	system				;posix (system <string>)
	getenv				;posix (getenv <string>)
	program-arguments		;returns list of strings (argv)
;	Xwindows			;X support
;	curses				;screen management package
;	termcap				;terminal description package
;	terminfo			;sysV terminal description
;	current-time			;returns time in seconds since 1/1/1970
	))

;;; Compatibility code added by Shriram.

(define-macro defmacro
  (lambda (name params . body)
    `(define-macro ,name
       (lambda ,params
	 ,@body))))

(define program-arguments
  (lambda ()
    (vector->list argv)))

(define current-time current-seconds)

;;; Remainder is modifications of existing code in Template.scm.

;;; (OUTPUT-PORT-WIDTH <port>)
(define (output-port-width . arg) 79)

;;; (OUTPUT-PORT-HEIGHT <port>)
(define (output-port-height . arg) 24)

;;; (CURRENT-ERROR-PORT)

;;; (TMPNAM) makes a temporary file name.
(define tmpnam (let ((cntr 100))
		 (lambda () (set! cntr (+ 1 cntr))
			 (string-append "slib_" (number->string cntr)))))

;;; (FILE-EXISTS? <string>)

;;; (DELETE-FILE <string>)

;;; FORCE-OUTPUT flushes any pending output on optional arg output port
;;; use this definition if your system doesn't have such a procedure.
(define force-output flush-output)

;;; CALL-WITH-INPUT-STRING and CALL-WITH-OUTPUT-STRING are the string
;;; port versions of CALL-WITH-*PUT-FILE.

(define call-with-input-string
  (lambda (string thunk)
    (parameterize ((current-input-port (open-input-string string)))
      (thunk))))

(define call-with-output-string
  (lambda (receiver)
    (let ((sp (open-output-string)))
      (receiver sp))))

;;; CHAR-CODE-LIMIT is one greater than the largest integer which can
;;; be returned by CHAR->INTEGER.
(define char-code-limit 256)

;;; MOST-POSITIVE-FIXNUM is used in modular.scm
(define most-positive-fixnum #x3FFFFFFFF) ; 30 bits on 32-bit machines

;;; Return argument
(define (identity x) x)

;;; If your implementation provides eval SLIB:EVAL is single argument
;;; eval using the top-level (user) environment.
(define slib:eval eval)

;;; If your implementation provides R4RS macros:
;(define macro:eval slib:eval)
;(define macro:load load)

(define gentemp
  (let ((*gensym-counter* -1))
    (lambda ()
      (set! *gensym-counter* (+ *gensym-counter* 1))
      (string->symbol
       (string-append "slib:G" (number->string *gensym-counter*))))))

(define defmacro? macro?)

(define macroexpand-1 expand-defmacro-once)

(define macroexpand expand-defmacro)

(define base:eval slib:eval)
(define (defmacro:expand* x)
  (require 'defmacroexpand) (apply defmacro:expand* x '()))
(define (defmacro:eval x) (base:eval (defmacro:expand* x)))

(define (defmacro:load <pathname>)
  (slib:eval-load <pathname> defmacro:eval))

(define (slib:eval-load <pathname> evl)
  (if (not (file-exists? <pathname>))
      (set! <pathname> (string-append <pathname> (scheme-file-suffix))))
  (call-with-input-file <pathname>
    (lambda (port)
      (let ((old-load-pathname *load-pathname*))
	(set! *load-pathname* <pathname>)
	(do ((o (read port) (read port)))
	    ((eof-object? o))
	  (evl o))
	(set! *load-pathname* old-load-pathname)))))

;;; define an error procedure for the library
(define slib:error error)

;;; define these as appropriate for your system.
(define slib:tab (integer->char 9))
(define slib:form-feed (integer->char 12))

;;; Support for older versions of Scheme.  Not enough code for its own file.
(define (last-pair l) (if (pair? (cdr l)) (last-pair (cdr l)) l))
(define t #t)
(define nil #f)

;;; Define these if your implementation's syntax can support it and if
;;; they are not already defined.

(define (1+ n) (+ n 1))
(define (-1+ n) (+ n -1))
(define 1- -1+)

(define in-vicinity build-path)

;;; Define SLIB:EXIT to be the implementation procedure to exit or
;;; return if exitting not supported.
(define slib:exit exit)

;;; Here for backward compatability
(define scheme-file-suffix
  (let ((suffix (case (software-type)
		  ((NOSVE) "_scm")
		  (else ".scm"))))
    (lambda () suffix)))

;;; (SLIB:LOAD-SOURCE "foo") should load "foo.scm" or with whatever
;;; suffix all the module files in SLIB have.  See feature 'SOURCE.

(define (slib:load-source f) (load (string-append f ".scm")))

;;; (SLIB:LOAD-COMPILED "foo") should load the file that was produced
;;; by compiling "foo.scm" if this implementation can compile files.
;;; See feature 'COMPILED.

(define (slib:load-compiled f) (load (string-append f ".zo")))

;;; At this point SLIB:LOAD must be able to load SLIB files.

(define slib:load slib:load-source)

(slib:load (in-vicinity (library-vicinity) "require"))
