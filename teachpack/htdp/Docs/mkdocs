#!/bin/sh
string=? ; exec ${HOMESCHEME-/home/scheme}/Executables/mzscheme -r $0 "$@"

; This list determines the order of libraries in the index file:
(define libraries
  '("Mastermind"
    "Guess"
    "Hangman"
    "Arrows"
    "Simple Drawing Exercises"
    "Ping-Pong"
    "Protect-the-Wall"
    "Elevator"
    "Documents"
    "Directories"
    "Rectangles"
    "Graphing Functions"
    "GUI"
    "Lkup GUI"
    "Arrows GUI"
    "Guess GUI"))

; Defines go:
(load (format "~a/Packages/TrashyTeXTools/bin/thtml2html"
	      (or (getenv "HOMESCHEME")
		  "/home/scheme")))

(require-library "cmdline.ss")

(parse-command-line
 "mkdocs"
 argv
 `()
 (lambda (-) (void))
 null)

(require-library "function.ss")

(define dest-dir (build-path 'up ; plt/teachpack/htdp dir
			     'up ; plt/teachpack dir
			     'up ; plt dir
			     "collects"
			     "doc"
			     "teachpack"))

(unless (directory-exists? dest-dir)
  (make-directory dest-dir))

(define src-files
  (filter (lambda (x) (and (regexp-match "[.]thtml$" x)
			   (not (regexp-match "^index[.]thtml$" x))))
	  (directory-list)))

;; Get library names:

(define lib-names  
  ; Get list of (cons name file)
 (map (lambda (s)
	(with-input-from-file s
	  (lambda ()
	    (let loop ()
	      (let ([l (read-line)])
		(cond
		 [(eof-object? l)
		  (error 'mkdocs "EOF before library name found in ~s" s)]
		 [(regexp-match "#define LIBNAME (.*)" l)
		  => (lambda (m)
		       (cons (cadr m) s))]
		 [else (loop)]))))))
      src-files))

;; Check library list:

(for-each (lambda (s) (unless (member (car s) libraries)
			(error 'mkdocs "library not listed in mkdocs: ~a = ~a" 
			       (cdr s) (car s))))
	  lib-names)
(let ([found-libraries (map car lib-names)])
  (for-each (lambda (s) (unless (member s found-libraries)
			  (error 'mkdocs "non-existent library listed in mkdocs: ~a" 
				 s)))
	    libraries))
(let loop ([libs lib-names][saw null])
  (cond
   [(null? libs) (void)]
   [(assoc (caar libs) saw)
    => (lambda (m)
	 (error 'mkdocs "library ~a has two .thtml files: ~a and ~a" 
		(caar libs) (cdar libs) (cdr m)))]
   [else (loop (cdr libs) (cons (car libs) saw))]))

;; Make index.thtml:

(define (thtml-name->html s)
  (regexp-replace "thtml$" s "html"))

(with-output-to-file "index.thtml"
  (lambda ()
    (printf "#define LIBNAME Teachpacks for How to Design Programs~n")
    (printf "#include head.tinc~n")
    (printf "<UL>~n")
    (for-each
     (lambda (libname)
       (let ([file (thtml-name->html (cdr (assoc libname lib-names)))])
	 (printf "<LI> <A HREF=~s>~a</A>~n" file libname)))
     libraries)
    (printf "</UL>~n")
    (printf "#include foot.tinc~n"))
  'replace)

(set! src-files (cons "index.thtml" src-files))

;; Make .html files:

(define dest-files
  (map (lambda (s)
	 (let ([html (thtml-name->html s)])
	   (build-path dest-dir html)))
       src-files))
		       
(for-each
 (lambda (src dest)
   (go (vector "html"
	       "-o"
	       dest
	       "-f"
	       src)))
 src-files dest-files)

;; Make hdindex file:

(let ([ifile (build-path dest-dir "hdindex")])
  (with-output-to-file ifile
    (lambda ()
      (printf "(~n")
      (printf "~s~n"
	'("Teachpacks for \"How to Design Programs\""
	   "index.html"
	   "HtDP"
	   "Arrows GUI teachpack"))
      (for-each
       (lambda (lib-name)
	 (let ([src (cdr lib-name)]
	       [title (car lib-name)])
	   (with-input-from-file src
	     (lambda ()
	       (let loop ()
		 (let ([l (read-line)])
		   (unless (eof-object? l)
		     (let ([m (regexp-match "<<LIBDESC>>{([^}]*)}" l)])
		       (when m
			 (printf "(~s ~s ~s ~s)~n" 
				 (cadr m) 
				 (thtml-name->html src) 
				 (cadr m)
				 (format "~a teachpack" title))))
		     (loop))))))))
       lib-names)
      (printf ")~n"))
    'truncate))
