;; Reconstruct types from flow information
;; see TR 00-359 for a description of a similar algorithm
;; some details differ here 

;; The following code shoes that there's a bug somewhere in this type reconstruction algorithm.
;; e should have an infinite type (e is aplied to the first Id to which e is then applied), but
;; the algorithm computes a finite type with setvars in it. Most of the time, when given a program
;; with an infinite type, the algo produces void. So the bug doesn't always show up...
;;((lambda (e)
;;   (((e (lambda (x) x)) ((lambda (x) x) e)) 1))
;; (lambda (x) x))

(unit/sig newspidey:type-reconstruction^
  (import [mzlib : mzlib:core-flat^]
          [setexp : newspidey:datadef-setexp^]
          [type : newspidey:datadef-types^]
          [cgp : newspidey:constraints-gen-and-prop^])

; (listof binding)
; invariant: list is partitioned so that the bindings where the 
;   binder occurs in the type are at the beginning of the list
(define rec-bindings 'not-initialized)

; (hash-table-of sym -> (union #f (listof sym)))
; returns #f iff the sym is the name of a type variable that
;  does not occur in its binding
(define *rec-bindings-rec-table* (make-hash-table))

; (hash-table-of sym -> type)
; these are the alpha's and omega's that are needed by 
;  mk-type-aux; they only need to be computed once 
;  so we memoize them here
(define *set-var-to-type-table* (make-hash-table))

; sym type -> void
(define (associate-set-var-and-type set-var type)
  (hash-table-put! *set-var-to-type-table* (setexp:Set-var-name set-var) type))

; sym -> (union #f type)
(define (lookup-type-from-set-var set-var)
  (hash-table-get *set-var-to-type-table* (setexp:Set-var-name set-var) 
		  (lambda () #f)))

; -> void
; populates *set-var-to-type-table*
(define (init-set-var-to-type)
  (for-each
   (lambda (set-var)
     (associate-set-var-and-type set-var (make-type-aux set-var)))
   (cgp:get-all-set-vars)))

; sym -> type
; this is mk-type from the TR
; one small optimization: we substitute set-var's type for 
;  set-var in the body of the recursive type, so we 
;  don't have to do it during type reduction
(define (mk-type set-var)
  (let ([omega-set-var (lookup-type-from-set-var set-var)]
        [all-set-vars (cgp:get-all-set-vars)])
    (type:make-Type-Rec
     ;;(map list all-set-vars (map lookup-type-from-set-var all-set-vars))
     rec-bindings ;; already reduced
     omega-set-var)))

; sym (listof sym) -> (listof sym)
; used when computing omega_dom's
(define (set-var-upper-bounds set-var accum)
  (let* ([ubs (cgp:lookup-lo-and-filter setexp:Set-var? set-var)]
         [new-ubs (mzlib:filter (lambda (ub)
                                  (not (memq ub accum)))
                                ubs)]
         [new-accum (cons set-var (append new-ubs accum))])
    (remove-duplicates-eq
     (cons
      set-var
      (apply append
             (map (lambda (ub)
                    (set-var-upper-bounds ub new-accum))
                  new-ubs))))))

; (listof eq-ables) -> (listof eq-ables)
(define (remove-duplicates-eq l)
  ;;(printf "list: ~a~n" l)
  (if (null? l)
      '()
      (let ([l-car (car l)]
            [l-cdr (cdr l)])
        (if (memq l-car l-cdr)
            (remove-duplicates-eq l-cdr)
            (cons l-car (remove-duplicates-eq l-cdr))))))

; sym -> type
; changes from TR: omega-arrow is a *union* type, where each element
;  is generated by a case-lambda clause
(define (make-type-aux alpha)
  (let* ([lookup-filtered-set-exp
          (lambda (pred alpha)
            (types->type
             (cgp:lookup-hi-and-filter pred alpha)))]
         [omega-c
          (lookup-filtered-set-exp setexp:Const? alpha)]
         [omega-cons
          (if (null? (cgp:lookup-hi-and-filter setexp:Token? alpha))
              type:*empty-type*
              (let ([omega-car (lookup-filtered-set-exp setexp:Set-var? (setexp:make-Car alpha))]
                    [omega-cdr (lookup-filtered-set-exp setexp:Set-var? (setexp:make-Cdr alpha))])
                (type:make-Type-Cons omega-car omega-cdr)))]
         [omega-arrow
          (let* ([labels (cgp:lookup-hi-and-filter setexp:Label? alpha)])
            ;;(printf "labels: ~a~n" labels)
            (types->type
             (apply append
                    (map
                         (lambda (label)
                           (let* ([arities (cgp:lookup-ars-from-label (setexp:Label-name label))]
                                  [label-alpha (setexp:make-Set-var
                                                ;; structures are not associated with a lambda, but structure
                                                ;; related functions have labels
                                                ;;(cgp:lookup-set-var-from-term (cgp:lookup-lambda-from-label label))
                                                ;; we don't compute the "right" type here for primitives, because
                                                ;; all primitive applications are independant. XXX
                                                (cgp:lookup-set-var-from-label label)
                                                )]
                                  ;;[foo (printf "label: ~a~narities: ~a~nlabel-alpha: ~a~n" label arities label-alpha)]
                                  ;;[goo (cgp:pp-constraints cgp:*the-constraints*)]
                                  [deltas (set-var-upper-bounds label-alpha '())]
;                                  [doms-omega (apply APPLY
;                                                     append
;                                                     (map
;                                                      (lambda (delta)
;                                                        (cgp:lookup-hi-and-filter
;                                                         setexp:Set-var?
;                                                         (setexp:make-Dom-interval (setexp:make-Interval 'star 'star)
;                                                                                   0 delta)))
;                                                      deltas))]
                                  )
                             ;;(printf "deltas: ~a~n" deltas)
                             (map
                              (lambda (arity)
                                (let* ([int (setexp:Arity-req arity)]
                                       [n (setexp:Interval-lo int)]
                                       [m (setexp:Interval-hi int)]
                                       [max-j (if (eq? m 'omega) (add1 n) n)]
                                       [sat (cgp:satisfies int max-j arity)]
                                       ;;[foo (printf "int: ~a~nn: ~a~narity: ~a~nsat: ~a~n~n" int n arity sat)]
                                       [omega-doms
                                        (let loop ([j 1])
                                          (if (> j max-j)
                                              '()
                                              (cons
                                               (if sat
                                                   (types->type
                                                    (remove-duplicates-eq
                                                     (apply
                                                      append
                                                      ;; doms-omega APPLY
                                                      (map
                                                       (lambda (delta)
;                                                         (cgp:lookup-hi-and-filter
;                                                          setexp:Set-var?
;                                                          (setexp:make-Dom-interval int j delta))
                                                         ;; no need to filter, we filter before calling
                                                         ;; relate-set-var-to-dom in add-contraint-and-update-tables
                                                         (cgp:lookup-set-vars-from-dom-int int delta j)
                                                         )
                                                       deltas))))
                                                   type:*empty-type*)
                                               (loop (add1 j)))))]
;                                       [omega-doms
;                                        (let loop ([j 1])
;                                          (if (> j max-j)
;                                              '()
;                                              (cons
;                                               (types->type
;                                                (cgp:lookup-lo-and-filter
;                                                 setexp:Set-var?
;                                                 (setexp:make-Dom-arity arity j alpha)))
;                                               (loop (add1 j)))))]
                                       [omega-rng (lookup-filtered-set-exp setexp:Set-var?
                                                                           (setexp:make-Rng-arity arity label-alpha))]
;                                       [omega-rng (types->type (remove-duplicates-eq
;                                                                (apply
;                                                                 append
;                                                                 (map
;                                                                  (lambda (delta)
;                                                                    (cgp:lookup-lo-and-filter
;                                                                     setexp:Set-var?
;                                                                     (setexp:make-Rng-interval int n delta)))
;                                                                  deltas))))]
                                       )
                                  ;;(printf "max-j: ~a~nomega-doms: ~a~n" max-j omega-doms)
                                  ;;(printf "TYPE: ~a -> ~a~n" omega-doms omega-rng)
                                  (type:make-Type-Arrow omega-doms omega-rng)))
                              arities)))
                         labels))))]
         [omega-struct (let ([structs (cgp:lookup-hi-and-filter setexp:Struct? alpha)])
                         (types->type
                          (map (lambda (struct)
                                 (type:make-Type-Struct (setexp:Struct-name struct)
                                                        (setexp:Struct-fields struct)))
                               structs)))])
    ;;(printf "omega-c: ~a~nomega-cons: ~a~nomega-arrow: ~a~nomega-struct: ~a~n~n" omega-c omega-cons omega-arrow omega-struct)
    (type:make-Type-Union (list omega-c omega-cons omega-arrow omega-struct))))
  
; (listof type) -> type
; implements Set2Type from TR
(define (types->type set-vars)
  (let ([len (length set-vars)])
    (cond
      [(= len 0) type:*empty-type*]
      [(= len 1) (car set-vars)]
      [else (type:make-Type-Union set-vars)])))


; -> void
; reduce types in *set-var-to-type-table*
; only needs to be done once
(define (type-reduce-rec-bindings)
  (let* ([bindings (hash-table-map *set-var-to-type-table*
                                   (lambda (name type)
                                     (type:make-Type-Binding
                                      (setexp:make-Set-var name)
                                      type)))])
    (set! rec-bindings (let loop ([cur-bindings bindings]
                                  [accum '()])
                         (if (null? cur-bindings)
                             accum
                             (let* ([binding_i (car cur-bindings)]
                                    [set-var_i (type:Type-Binding-set-var binding_i)]
                                    [type_i (type:Type-Binding-type binding_i)])
                               (if (is-recursive-rec-binding? binding_i)
                                   (loop (cdr cur-bindings)
                                         (cons (type:make-Type-Binding
                                                set-var_i
                                                (type-reduce type_i))
                                               accum))
                                   (cons (type:make-Type-Binding
                                          set-var_i
                                          (type-reduce type_i))
                                         (loop (cdr cur-bindings)
                                               accum)))))))))

; binding -> (union #f (listof sym))
; interface to *rec-bindings-rec-table*
(define (is-recursive-rec-binding? binding)
  (let ([name (setexp:Set-var-name (type:Type-Binding-set-var binding))]
        [type (type:Type-Binding-type binding)])
    (hash-table-get *rec-bindings-rec-table* name
                    (lambda ()
                      (let ([answer (memq name (extract-set-vars type))])
                        (hash-table-put! *rec-bindings-rec-table* name answer)
                        answer)))))

; type -> (listof sym) 
; all set vars that occur in a type
(define (extract-set-vars type)
  ;;(printf "type: ~a~n" type)
  (let ([map-and-flatten (lambda (lst)
                           (apply append
                                  (map extract-set-vars lst)))])
    (cond
      [(setexp:Const? type) '()]
      [(setexp:Set-var? type) (list (setexp:Set-var-name type))]
      [(type:Type-Rec? type)
       (remove-duplicates-eq
        (apply append
               (map-and-flatten (map type:Type-Binding-type (type:Type-Rec-bindings type)))
               (extract-set-vars (type:Type-Rec-type type))))]
      [(type:Type-Arrow? type)
       (remove-duplicates-eq
        (append
         (map-and-flatten (type:Type-Arrow-doms type))
         (extract-set-vars (type:Type-Arrow-rng type))))]
      [(type:Type-Cons? type)
       (remove-duplicates-eq
        (append (extract-set-vars (type:Type-Cons-car type))
                (extract-set-vars (type:Type-Cons-cdr type))))]
      [(type:Type-Union? type)
       (remove-duplicates-eq
        (map-and-flatten (type:Type-Union-types type)))]
      [(type:Type-Struct? type)
       (remove-duplicates-eq
        (map-and-flatten (type:Type-Struct-fields type)))]
      [(type:Type-Empty? type) '()]
      [else (error 'extract-set-vars "unknown type: ~a~n" type)])))


; implements type reduction rules
; type -> type
(define (type-reduce type)
  ;;(printf "type-reduce: ~a~n" type)
  (cond
    [(setexp:Set-var? type) type]
    [(type:Type-Rec? type)
     (cond
       ;; rec already done when creating the rec-type in mk-type
       ;; rec-elim
       [(null? (type:Type-Rec-bindings type))
        (type-reduce (type:Type-Rec-type type))]
       ;; unfold
       [else (let* ([first-rec-binding (car (type:Type-Rec-bindings type))]
                    [rest-rec-bindings (cdr (type:Type-Rec-bindings type))]
                    [alpha (setexp:Set-var-name (type:Type-Binding-set-var first-rec-binding))]
                    [omega (type:Type-Binding-type first-rec-binding)]
                    [body-type (type:Type-Rec-type type)])
               (when (not (is-recursive-rec-binding? first-rec-binding))
                 (if (extract-set-vars body-type) ;; optimisation
                     (type-reduce (type:make-Type-Rec
                                   (map (lambda (binding)
                                          (type:make-Type-Binding
                                           (type:Type-Binding-set-var binding)
                                           (type-subst (type:Type-Binding-type binding) alpha omega)))
                                        rest-rec-bindings)
                                   (type-subst body-type alpha omega)))
                     (type-reduce body-type))))])]
    [(type:Type-Union? type)
     (let* ([types (type:Type-Union-types type)]
            ;; union
            [types-reduced (map type-reduce types)]
            ;; empty-filter
            [types-filtered (mzlib:filter (lambda (type) (not (eq? type type:*empty-type*))) types-reduced)]
            ;; union-merger
            [types-flattened (let loop ([cur-types types-filtered])
                               (if (null? cur-types)
                                   '()
                                   (let ([cur-type (car cur-types)])
                                     (if (type:Type-Union? cur-type)
                                         (append (type:Type-Union-types cur-type)
                                                 (loop (cdr cur-types)))
                                         (cons cur-type
                                               (loop (cdr cur-types)))))))]
            [types-length (length types-flattened)])
       (cond
         [(= types-length 0) type:*empty-type*]
         [(= types-length 1) (car types-flattened)]
         [else (type:make-Type-Union types-flattened)]))]
    [(type:Type-Cons? type)
     (type:make-Type-Cons (type-reduce (type:Type-Cons-car type))
                          (type-reduce (type:Type-Cons-cdr type)))]
    [(type:Type-Arrow? type)
     (type:make-Type-Arrow (map type-reduce (type:Type-Arrow-doms type))
                           (type-reduce (type:Type-Arrow-rng type)))]
    [(setexp:Const? type) type]
    [(type:Type-Struct? type)
     (type:make-Type-Struct (type:Type-Struct-name type)
                            (map type-reduce (type:Type-Struct-fields type)))]
    [(type:Type-Empty? type) type]
    [else (error 'type-reduce "unknown type: ~a~n" type)]))

; type sym type -> type
(define (type-subst type alpha omega)
  (cond
    [(type:Type-Union? type)
     (type:make-Type-Union 
      (map (lambda (type) 
	     (type-subst type alpha omega)) 
	   (type:Type-Union-types type)))]
    [(type:Type-Cons? type)
     (type:make-Type-Cons (type-subst (type:Type-Cons-car type) alpha omega)
                          (type-subst (type:Type-Cons-cdr type) alpha omega))]
    [(type:Type-Arrow? type)
     (type:make-Type-Arrow 
      (map (lambda (type) 
	     (type-subst type alpha omega)) 
	   (type:Type-Arrow-doms type))
      (type-subst (type:Type-Arrow-rng type) alpha omega))]
    [(type:Type-Rec? type)
     (type:make-Type-Rec 
      (map (lambda (binding)
	     (let ([set-var (type:Type-Binding-set-var binding)]
		   [type (type:Type-Binding-type binding)])
	       (type:make-Type-Binding set-var (type-subst type alpha omega))))
	   (type:Type-Rec-bindings type))
      (type-subst (type:Type-Rec-type type) alpha omega))]
    [(setexp:Set-var? type)
     (if (mzlib:symbol=? (setexp:Set-var-name type) alpha)
         omega
         type)]
    [(type:Type-Struct? type)
     (type:make-Type-Struct (type:Type-Struct-name type)
                            (map (lambda (type) 
                                   (type-subst type alpha omega))
                                 (type:Type-Struct-fields type)))]
    [(setexp:Const? type) type]
    [(type:Type-Empty? type) type]
    [else (error 'type-subst "unknown type: ~a~n" type)]))

  ) ;; unit/sig