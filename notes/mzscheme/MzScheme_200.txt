
MzScheme version 200 is different from previous versions of MzScheme
in several important ways:

 * There is a new module system that supports only top-level,
   first-order modules. The library-collection system now works with
   the module system. In particular, `require-library' has been
   replaced by a `require' form.

 * There is no built-in object or unit system. These have been moved
   to MzLib-defined syntax modules: "class.ss" (or "class-old.ss"),
   "unit.ss", and "unitsig.ss" in the "mzlib" collection. For example,
   to get the old class system, use
    
       (require (lib "class-old.ss"))

 * The core syntax system is hygienic; `define-macro' has been
   replaced by `define-syntax'.

   In general, there is no easy way to convert a `define-macro' macro
   to `define-syntax'; re-writing an old-style macro with
   `define-syntax' and `syntax-case' is usually quite easy. The
   following works sometimes, though:

      (define-syntax define-macro
        (lambda (stx)
	  (syntax-case stx ()
	    [(_ name proc)
	     (syntax
	      (define-syntax name
	        (lambda (stx)
		  (datum->syntax-object 
                   (quote-syntax here)
                   (apply proc 
		          (cdr (syntax-object->datum stx)))))))])))

 * Although MzScheme has no class system, there is still a "standard"
   one (i.e., the one that works with MrEd), and it is different from
   the previous built-in class system. The principal difference is
   that classes have fields and methods, and the form of a method
   definition is syntactically restricted (so that it can be
   implemented with a per-class procedure instead of a per-object
   procedure).

   Syntactically, the new `class' form is substantially different from
   the old `class' form. The new form is more consistent with the
   `unit' and `module' syntax, using `define' for method and private
   field declarations.

   The "class100.ss" library in MzLib supplies a `class100' form with a
   syntax similar to the old `class' form, but with a semantics that
   matches the new `class' form.

   To make old code work with the new class system:

      0. Require the "class.ss" and "class100.ss" libraries.

      1. Replace "class" with "class100" (and "class*" with
         "class100*", etc.).

      2. Replace "private" with "private-field".

      3. Loop until there are no more syntax errors:
         - Try to load the code
         - Read the error message (which provides a source location)
         - Fix the problem
   
   The `send' form works as before, but there is no `ivar' form.
   Field values are accessed through procedures constructed with
   `make-class-field-accessor'. Instances are contructed with either
   `make-object' or the new `instantiate' form; the latter supports
   by-name initialization arguments. See the MzLib documentation for
   details.

   The "class-old.ss" library in MzLib implements precisely the old
   MzScheme class syntax, but it cannot be used with MrEd classes.

 * The `struct' form is gone, replaced by a more flexible
   `make-struct-type' form. 

   The `define-struct' form works as before, but also supports an
   optional inspector expression after the field list.

   Inspectors provide debugging access, with a custodian-like
   hierarchy for opacity. The form

    (define-struct s (f ...))

   now creates a type for structs that are effectively opaque. Use

    (define-struct s (f ...) (make-inspector))

   for transparent structs.

   Struct type properties let a programmer attach static information
   to a structure type. (For example, using properties,
   structure-based classes can be implemented more efficiently.)

 * The `process', `process*', `process/ports', `process*/ports',
   `system', and `system*' procedures have been moved to a new MzLib
   library, "process.ss".

   MzScheme's new built-in form is `subprocess', which takes the same
   arguments as `process*/ports'. It returns four values: a subprocess
   value, an input port or false (the subprocess's stdout, if one was
   created), an output port or false (the subprocess's stdin), and an
   input port or false (the subprocess's stderr). The new
   `subprocess-status' procedure gets the status or return code of the
   subprocess, and `subprocess-pid' gets its process id.
   
   The `process', etc. procedures are implemented in terms of
   `subprocess'. Consequently, old bugs and gaps in support
   (especially for Windows) have been eliminated.

   The `execute' and `execute*' procedures were eliminated entirely.

 * Nearly all #% names are gone, since they are unnecessary with the
   new syntax system. However, a few new syntactic forms, which are
   usually implicit, use #%: `#%app', `#%datum', `#%top', etc.

 * `global-defined-value' has been renamed `namespace-variable-binding'
   (for consistency with other names). `defined?' is gone, but it can
   be implemented with `namespace-variable-binding'.

 * In the "unitsig.ss" library, all `unit-with-signature' names were
   either replaced by `unit/sig' names or eliminated in favor of
   existing `unit/sig' names.

MzLib changes:

 * "functio.ss" was split into "list.ss" and "etc.ss"

 * "macro.ss" was merged into "etc.ss", mostly

 * "invoke.ss" was merged into "unit.ss" and "unitsig.ss"

 * "include.ss" is new; it implements the `include' form that used to
    be restricted to `unit/sig' bodies

 * "defstru.ss" was roughly re-implemented in "compat.ss" (and the
    re-implementation matches the Chez form)

 * "process.ss" is new
