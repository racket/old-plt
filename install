#!/bin/sh
#|
# PLT software installer
#
# Configures PLTHOME path within scripts
#
# Can create .zo files or re-use existing ones (modifying .dep files)
#
# Normally it'll use MzScheme (will search for it at the same place this script
# is), but it can also be used with mred for graphic installations.

# Try to find where mzscheme is, usually where this script is being run from
if [ -x install -a -d collects ]; then
  pltdir="."
else
  # Try finding the installation directory...
  if [ -x "/bin/dirname" ]; then
    pltdir="`/bin/dirname \"$0\"`"
  elif [ -x "/usr/bin/dirname" ]; then
    pltdir="`/usr/bin/dirname \"$0\"`"
  else
    dirname="`which dirname`"
    if [ ! -z "$dirname" ]; then
      pltdir="$dirname"
    fi
  fi
fi

if [ -x "$pltdir/bin/mzscheme" ]; then
  mz="$pltdir/bin/mzscheme"
elif [ -x "$pltdir/MzScheme.exe" ]; then
  mz="$pltdir/MzScheme.exe"
else
  echo "install: cannot find the mzscheme executable"
  echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  echo "!!               Install incomplete!               !!"
  echo "!!                                                 !!"
  echo "!! If you downloaded the source distribution, see  !!"
  echo "!!        src/README for build instructions.       !!"
  echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  exit 1
fi

exec "$mz" -qC "$0" "$@"
exit 1
|#

(use-compiled-file-kinds 'none)

(define plthome #f)
(define this-script #f)
(define didnothing? #t)

;; this will be the same as plthome, except when a `-p' argument is used.
;; `plthome' always points at the current plthome, the one we use to load
;; stuff.
(define fake-plthome #f)

(define zos?          #t)
(define scripts?      #t)
(define updates?      #f)
(define install-mode? #f)

(define (set-install-mode!)
  (set! install-mode? #t)
  (set! zos? #t)
  (set! scripts? #f)
  (set! updates? #f))

(when (or (getenv "OSX_PLT_INSTALL") (getenv "RPM_INSTALL_PREFIX"))
  (set-install-mode!))

(define (set-plthome this)
  (let-values ([(dir name dir?)
                (split-path
                 (resolve-path
                  (path->complete-path (simplify-path (resolve-path this)))))])
    (unless (string? dir) (error 'install "Bad pathname for install: ~s" this))
    (current-directory dir)
    (current-directory ".") ; avoid a "/" suffix
    (set! plthome (current-directory))
    (unless fake-plthome (set! fake-plthome plthome))
    (unless (and (directory-exists? "collects/mzlib") (file-exists? name))
      (error 'install
             "Can't find the PLT installation this script (~a) is part of"
             this))
    (set! this-script name)))

(define (setup-environment)
  (putenv "PLTHOME" plthome)
  (putenv "PLTCOLLECTS" "")
  (current-library-collection-paths (list (build-path plthome "collects"))))

(require (lib "cmdline.ss"))
(define (process-command-line)
  (define no-install-flag #f)
  (define (install-flag-error)
    (error 'install "Cannot use -i with other flags"))
  (define-syntax set!!
    (syntax-rules ()
      [(set!! var val) (begin (when install-mode? (install-flag-error))
                              (set! no-install-flag #t)
                              (set! var val))]))
  (define more-help
    (lambda (help)
      (for-each display
                '("This is the PLT installer.\n"
                  "  When it is used with the \"-i\" flag, it will run in\n"
                  "  `install-mode' -- updating launchers, and preparing an\n"
                  "  existing tree for operation.  This is intended as a\n"
                  "  one-time operation so it will remove itself when it is\n"
                  "  done.\n"
                  "Usage: "))
      (display help)
      (exit 0)))
  (command-line "install" (current-command-line-arguments)
    (once-each
     (("-i")
      "Install mode.\n\
       This is a `one-time option' that is intended to be used with\n\
       installers or after retrieving a fresh plt tree; this script will be\n\
       deleted afterwars.  It cannot be used with any of the other flags."
      (when no-install-flag (install-flag-error))
      (set-install-mode!))
     (("-z") "skip .zo file compilation"                   (set!! zos? #f))
     (("+z") "compile .zo files (default)"                 (set!! zos? #t))
     (("-s") "skip modifying PLTHOME in scripts"           (set!! scripts? #f))
     (("+s") "modify PLTHOME setting in scripts (default)" (set!! scripts? #t))
     (("-u") "skip on-line updates checking (default)"     (set!! updates? #f))
     (("+u") "check for on-line updates (temporarily disabled)"
                                                           (set!! updates? #t))
     (("-p") explicit-home
      "use explicit PLTHOME value instead of the current directory."
      (set!! fake-plthome explicit-home)
      (unless (absolute-path? explicit-home)
        (error './install
               "bad value for PLTHOME, expected an absolute path, got ~s"
               explicit-home))))
    (=> (lambda (_) _) '() more-help)))

;; Set up GUI if we're using MrEd
(when (namespace-variable-value 'make-eventspace #t (lambda () #f))
  (let ([evt (make-eventspace)] [orig-exit (exit-handler)])
    (parameterize ([current-eventspace evt])
      (define (do-callback thunk)
        (parameterize ([current-eventspace evt]) (queue-callback thunk #f)))
      (define (quit)
        (when (eq? 'ok (message-box "Stop Installation"
                                    "Ok to stop the installation?"
                                    f '(ok-cancel)))
          (exit 1)))
      (define (fail msg exit-code)
        (do-callback
         (lambda ()
           (send e lock #f)
           (let* ([p1 (send e last-position)]
                  [_  (send e insert msg p1)]
                  [p2 (send e last-position)])
             (send e insert "\n(click button below to continue)" p2)
             (send e change-style 
                   (let ([d (make-object style-delta% 'change-bold)])
                     (send d set-delta-foreground "red")
                     d)
                   p1 p2))
           (send e lock #t)
           (send b set-label "Quit Installation")
           (set! quit (lambda () (orig-exit exit-code)))))
        (semaphore-wait (make-semaphore)))
      (define f (make-object
                 (class frame% ()
                   (define/override (can-close?) (quit) #f)
                   (super-instantiate ("PLT Installer" #f600 480)))))
      (define e (make-object text%))
      (define c (make-object editor-canvas% f e '(no-hscroll)))
      (define b (make-object button% "Stop Installation" f (lambda _ (quit))))
      (send c allow-tab-exit #t)
      (send e lock #t)
      (send e auto-wrap #t)
      (let ([out (make-custom-output-port #f
                   (lambda (string start end flush?)
                     (do-callback
                      (lambda ()
                        (send e lock #f)
                        (send e insert (substring string start end)
                              (send e last-position))
                        (send e lock #t)))
                     (- end start))
                   void void)])
        (current-output-port out)
        (current-error-port out))
      (send f center 'both)
      (send f show #t)
      (exit-handler
       (lambda (v)
         ;; can use an explicit (exit 0) to show the output
         (fail (if (zero? v) "Done" "INSTALLATION FAILED") v)))
      (current-exception-handler
       (lambda (e)
         (if (exn:break? e)
           (orig-exit 1) ; don't lock up if the process is killed
           (fail (format "INSTALLATION FAILED: ~a"
                         (if (exn? e) (exn-message e) e))
                 1))))
      (initial-exception-handler (current-exception-handler)))))

(define (update-scripts)
  (when scripts?
    (printf "setting PLTHOME to ~s in scripts:\n" fake-plthome)
    (parameterize ([current-directory "bin"])
      (define (scan-file)
        (let loop ([ls null] [changed? #f])
          (let ([l (read-line)])
            (cond
             ((eof-object? l) (values (reverse ls) changed?))
             ((regexp-match #rx"^( *)PLTHOME=(.*)$" l) =>
              (lambda (m)
                (loop (cons (format "~aPLTHOME=~s" (cadr m) fake-plthome) ls)
                      #t)))
             (else (loop (cons l ls) changed?))))))
      (for-each
       (lambda (f)
         (cond
          [(not (file-exists? f)) '-]
          [(and (file-exists? f) (> (file-size f) 4096))
           (printf " skipping ~a\n" f)]
          [else
           (set! didnothing? #f)
           (printf " checking ~a..." f)
           (let-values ([(lines changed?) (with-input-from-file f scan-file)])
             (if changed?
               (begin (printf " updating\n")
                      (with-output-to-file f
                        (lambda ()
                          (for-each (lambda (l) (display l) (newline)) lines))
                        'truncate))
               (printf " nothing to do\n")))]))
       (directory-list)))))

(define (check-updates)
  (when updates?
    ((dynamic-require '(lib "check-text.ss" "version") 'check-version))))

(define (create-zos)
  (if zos?
    (parameterize
        (;; Need a new namespace to ensure that all modules are compiled,
	 ;; including ones we've already loaded.  We also need to re-enable
	 ;; compiled files, since cm.ss checks on that flag.
         [current-namespace (make-namespace)]
         [use-compiled-file-kinds 'all]
         [current-command-line-arguments
          (if install-mode? #("--trust-zos" "--no-install") #())]
         ;; setup will use `exit' when done, so catch these, and stop if
         ;; non-zero
         [exit-handler
          (lambda (n)
            (unless (zero? n)
              (error 'install "Errors in compilation process! (~a)" n)))]
         ;; also, protect `current-directory' since it will change
         [current-directory (current-directory)])
      (set! didnothing? #f)
      (dynamic-require '(lib "setup.ss" "setup") #f))
    (for-each display
              (list "Skipping .zo-file creation; create .zo files later by "
                    "running\n  " plthome "/bin/setup-plt\n"))))

(define (main args)
  (set-plthome (car args))
  (setup-environment)
  (process-command-line)
  (update-scripts)
  (check-updates)
  (create-zos)
  (cond [(not install-mode?)
         (printf "PLT installation done~a.\n"
                 (if didnothing? " (nothing to do)" ""))
         (when (file-exists? "bin/drscheme")
           (for-each display '("\nRun DrScheme as bin/drscheme.\nFor Help, "
                               "select `Help Desk' from DrScheme's `Help' "
                               "menu,\nor run bin/help-desk.\n")))
         ;; if we're using GUI, and not in install mode, don't close the window
         (exit 0)]
        [this-script
         (display "Installation complete.\n")
         (delete-file this-script)]))
