(module qqstx mzscheme
  (provide quasiquote-syntax
           unquote-syntax
           unquote-splicing-syntax)
  (require-for-syntax "stx.ss")
  
  (define-syntax (unquote-syntax stx)
    (raise-syntax-error
     #f
     "illegal outside of quasiquote-syntax"
     stx
     #f))
  (define-syntax (unquote-splicing-syntax stx)
    (raise-syntax-error
     #f
     "illegal outside of quasiquote-syntax"
     stx
     #f))
  
  (define-syntax (quasiquote-syntax orig-stx)
    (define (wrap x src-stx)
      (with-syntax ([x x]
                    [ctx (datum->syntax-object src-stx '! src-stx)])
        (syntax/loc src-stx (datum->syntax-object
                             (quote-syntax ctx)
                             x
                             (quote-syntax ctx)))))
    (let ([body (syntax-case orig-stx ()
                  [(_ stx) (syntax stx)])])
      (let loop ([stx body]
                 [depth 0]
                 [same-k (lambda () ;; an optimization of done-k
                           (with-syntax ([body body])
                             (syntax/loc orig-stx (syntax body))))]  
                 [convert-k (lambda (x) (wrap x body))]
                 [done-k (lambda (x) x)])
        (syntax-case stx (unquote-syntax unquote-splicing-syntax quasiquote-syntax)
          [(unquote-syntax x)
           (if (zero? depth)
               (done-k (syntax x))
               (let ([x-done-k
                      (lambda (v)
                        (with-syntax ([x v]
                                      [uq (stx-car stx)])
                          (convert-k (syntax/loc stx (list (quote-syntax uq) x)))))])
                 (loop (syntax x) (sub1 depth)
                       same-k
                       (lambda (v)
                         (x-done-k (wrap v (syntax x))))
                       x-done-k)))]
          [unquote-syntax
           (raise-syntax-error
            #f
            "misuse within quasiquote-syntax"
            orig-stx
            stx)]
          [((unquote-splicing-syntax x) . rest)
           (if (zero? depth)
               (let ([rest-done-k
                      (lambda (rest-v)
                        (with-syntax ([rest-v rest-v])
                          (convert-k (syntax/loc stx (append x rest-v)))))])
                 (loop (syntax rest) depth
                       (lambda ()
                         (convert-k (syntax/loc stx (append x (syntax rest)))))
                       (lambda (v)
                         (rest-done-k (wrap v (syntax rest))))
                       rest-done-k))
               (let ([x-done-k
                      (lambda (x-v)
                        ;; x is generated by x-v
                        (let ([rest-done-k
                               (lambda (rest-v)
                                 (with-syntax ([x-v x-v]
                                               [rest-v rest-v])
                                   (convert-k (syntax/loc stx (cons x-v rest-v)))))])
                          (loop (syntax rest) depth
                                (lambda ()
                                  ;; rest is unchanged
                                  (rest-done-k (syntax (syntax rest))))                                 
                                (lambda (rest-v)
                                  (rest-done-k (wrap rest-v (syntax rest))))
                                rest-done-k)))])
                 (loop (syntax x) (sub1 depth)
                       (lambda ()
                         ;; x is unchanged.
                         (with-syntax ([(old . _) stx])
                           (let ([rest-done-k
                                  (lambda (rest-v)
                                    (with-syntax ([rest-v rest-v])
                                      (convert-k (syntax/loc stx (cons old rest-v)))))])
                             (loop (syntax rest) depth
                                   same-k
                                   (lambda (rest-v)
                                     (rest-done-k (wrap rest-v (syntax rest))))
                                   rest-done-k))))
                       (lambda (x-v)
                         ;; x is generated by x-v
                         (x-done-k (wrap x-v (syntax x))))
                       x-done-k)))]
          [unquote-splicing-syntax
           (raise-syntax-error
            #f
            "misuse within quasiquote-syntax"
            orig-stx
            stx)]
          [(quasiquote-syntax x)
           (let ([x-done-k
                  (lambda (v)
                    (with-syntax ([x v]
                                  [qq (stx-car stx)])
                      (convert-k (syntax/loc stx (list (quote-syntax qq) x)))))])
             (loop (syntax x) (add1 depth)
                   same-k
                   (lambda (v)
                     (x-done-k (wrap v (syntax x))))
                   x-done-k))]
	  [(a . b)
           (let ([a-done-k
                  (lambda (a-v)
                    (let ([b-done-k
                           (lambda (b-v)
                             (with-syntax ([b-v b-v]
                                           [a-v a-v])
                               (convert-k (syntax/loc stx (cons a-v b-v)))))])                     
                      (loop (syntax b) depth
                            (lambda ()
                              (b-done-k (syntax (syntax b))))
                            (lambda (b-v)
                              (b-done-k (wrap b-v (syntax b))))
                            b-done-k)))])
             (loop (syntax a) depth
                   (lambda ()
                     ;; a is unchanged:
                     (let ([b-done-k
                            (lambda (b-v)
                              (with-syntax ([b-v b-v])
                                (convert-k (syntax/loc stx (cons a b-v)))))])                     
                       (loop (syntax b) depth
                             ;; b is unchanged
                             same-k
                             (lambda (b-v)
                               (b-done-k (wrap b-v (syntax b))))
                             b-done-k)))
                   (lambda (a-v)
                     (a-done-k (wrap a-v (syntax a))))
                   a-done-k))]
          [_else
           (cond
             [(vector? (syntax-e stx))
              (let ([v-done-k
                     (lambda (v)
                       (with-syntax ([v v])
                         (convert-k (syntax/loc stx (list->vector (syntax->list v))))))])
                (loop (datum->syntax-object
                       stx
                       (vector->list (syntax-e stx))
                       stx)
                      depth
                      same-k
                      (lambda (v) (v-done-k (wrap v stx)))
                      v-done-k))]
             [(box? (syntax-e stx))
              (let ([v-done-k
                     (lambda (v)
                       (with-syntax ([v v])
                         (convert-k (syntax/loc stx (box v)))))])
                (loop (unbox (syntax-e stx))
                      depth
                      same-k
                      (lambda (v)
                        (v-done-k (wrap v (unbox (syntax-e stx)))))
                      v-done-k))]
             [else
              (same-k)])])))))
