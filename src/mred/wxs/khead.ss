
;; kernel.ss is generated by xctocc

(module kernel mzscheme
  (require (all-except (lib "class.ss") object%))

  ;; Pull pieces out of #%mred-kernel dynamically, so that
  ;;  the library compiles with setup-plt in mzscheme.
  
  (define kernel:initialize-primitive-object
    (dynamic-require '#%mred-kernel 'initialize-primitive-object))
  (define kernel:primitive-object->class
    (dynamic-require '#%mred-kernel 'primitive-object->class))
  (define kernel:find-in-primitive-class
    (dynamic-require '#%mred-kernel 'find-in-primitive-class))
  (define kernel:primitive-class->method-name-list
    (dynamic-require '#%mred-kernel 'primitive-class->method-name-list))
  (define kernel:primitive-class->method-vector
    (dynamic-require '#%mred-kernel 'primitive-class->method-vector))

  (define kernel:make-primitive-object
    (dynamic-require '#%mred-kernel 'make-primitive-object))
  (define kernel:primitive-object?
    (dynamic-require '#%mred-kernel 'primitive-object?))
  (define kernel:primitive-object-size
    (dynamic-require '#%mred-kernel 'primitive-object-size))
  (define kernel:primitive-object-ref
    (dynamic-require '#%mred-kernel 'primitive-object-ref))
  (define kernel:primitive-object-set!
    (dynamic-require '#%mred-kernel 'primitive-object-set!))
  
  ;; (require (prefix kernel: #%mred-kernel))

  (install-prim-functions kernel:primitive-object? 
			  (lambda (o)
			    (= 2 (kernel:primitive-object-size o)))
			  (lambda (o)
			    (kernel:primitive-object-ref o 0))
			  (lambda (o)
			    (kernel:primitive-object-ref o 1))
			  (lambda (prim-class c s lkup)
			    (let ([o (kernel:make-primitive-object 
				      prim-class
				      2
				      lkup)])
			      (kernel:primitive-object-set! o 0 c)
			      (kernel:primitive-object-set! o 1 s)
			      o))
			  kernel:initialize-primitive-object
			  kernel:primitive-object->class
			  kernel:find-in-primitive-class)

  (define (find-method class name)
    (let loop ([l (kernel:primitive-class->method-name-list class)][p 0])
      (if (eq? name (car l))
	  (vector-ref (kernel:primitive-class->method-vector class) p)
	  (loop (cdr l) (add1 p)))))

  (define-syntax define-constant
    (lambda (stx)
      (syntax-case stx ()
	[(_ name)
	 (with-syntax ([kernel:name (datum->syntax (string->symbol
						    (format 
						     "kernel:~a"
						     (syntax-e (syntax name))))
						   #f (syntax name))])
	   (syntax
	    (begin
	      (define kernel:name (dynamic-require '#%mred-kernel 'name))
	      (provide (rename kernel:name name)))))])))

  (define-syntax define-function
    (lambda (stx)
      (syntax-case stx ()
	[(_ name)
	 (syntax (define-constant name))])))

  (define-syntax define-functions
    (lambda (stx)
      (syntax-case stx ()
	[(_ name ...)
	 (syntax (begin (define-function name) ...))])))

  (define-syntax define-a-class
    (let ([defined null])
      (lambda (stx)
	(syntax-case stx ()
	  [(_ name super id ...)
	   (let ([nm (syntax-e (syntax name))]
		 [sn (syntax-e (syntax super))]
		 [ids (map syntax-e (syntax->list (syntax (id ...))))])
	     ;; find superclass
	     (let ([sup (assoc sn defined)])
	       (unless (or sup (not sn))
		 (raise-syntax-error
		  'class
		  "class not yet defined"
		  stx
		  (syntax super)))
	       ;; add this class to the list:
	       (set! defined (cons (cons nm (append (if sup
							(cdr sup)
							null)
						    ids))
				   defined))
	       (let-values ([(old new)
			     (let loop ([l ids][o null][n null])
			       (cond
				[(null? l) (values o n)]
				[(memq (car l) (cdr sup))
				 (loop (cdr l) (cons (car l) o) n)]
				[else
				 (loop (cdr l) o (cons (car l) n))]))])
		 (with-syntax ([(old ...) (datum->syntax old #f #f)]
			       [(new ...) (datum->syntax new #f #f)])
		   (syntax
		    (define name (let ([c (dynamic-require '#%mred-kernel 'name)])
				   (make-prim-class
				    c
				    'name super
				    '(old ...)
				    '(new ...)
				    (list
				     (find-method c 'old)
				     ...
				     (find-method c 'new)
				     ...)))))))))]))))

  (define-syntax define-class
    (lambda (stx)
      (syntax-case stx ()
	[(_ name super id ...)
	 (syntax
	  (begin 
	    (define-a-class name super id ...)
	    (provide name)))])))

  (define-syntax define-private-class
    (lambda (stx)
      (syntax-case stx ()
	[(_ name intf super id ...)
	 (syntax
	  (begin 
	    (define-a-class name super id ...)
	    (define intf (class->interface name))
	    (provide intf)))])))
