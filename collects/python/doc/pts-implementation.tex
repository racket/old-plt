% Implementation issues

\section{Implementation}
\label{implementation}

This section describes the current implementation of the Python-to-Scheme compiler.  The compiler is composed of three major components: the front-end, which uses a lexical analyzer (scanner) to read program text and a parser to check the syntax of the tokens produced by the scanner; the back-end, which is a code generator using the parser's output to create MzScheme code; and the runtime system, which provides a library that the generated code makes use of (Figure~\ref{compilerfig}).  This section delineates these three components.  Section~\ref{parsing} describes the scanner and parser; section~\ref{codegeneration}, the code generator; and section~\ref{runtimesystem}, the runtime system.

\begin{figure}
	\caption{Compiler overview}
	\label{compilerfig}
	\begin{center}
		\includegraphics{images/compiler-overview}
	\end{center}
\end{figure}

\subsection{Lexical and Syntax Analysis}
\label{parsing}

Python program text is read by the lexical analyzer -- created by Scott Owens of Utah University -- and transformed into tokens.  Tokens are either reserved keywords, represented as symbols, or input items, such as literal values, identifiers, and indentation directives.  The lexical analyzer outputs tokens, which are consumed by the parser.

The parser -- also provided by Scott Owens, along with the grammar it uses -- accepts a stream of tokens from the lexical analyzer and generates abstract syntax trees (ASTs) according to the grammar described in section~\ref{grammar}.

Abstract syntax trees are data structures representing the syntax elements present in a program.  For example, the Python expression \verb{x + 3} is a binary expression (section~\ref{arithzzzexprb}).  This binary expression is made up of the identifier \verb{x}, the number \verb{3}, and the addition operation operation symbol (\verb{+}).  See figure~\ref{simpleastfig} for a UML~\cite{silva00umli} representation of the statement's syntax tree.

\begin{figure}
	\caption{AST for x + 3}
	\label{simpleastfig}
	\begin{center}
		\includegraphics{images/uml/simple-ast}
	\end{center}
\end{figure}

%Python abstract syntax trees are represented by subclasses of \mbox{ast-node\%}, a base class containing source location and methods to emit MzScheme syntax-objects, which are s-expressions with additional properties, including lexical context and source location.  The \verb{->orig-so} method creates a syntax object with the compiler's context from an s-expression, and the \verb{->lex-so} method creates a syntax object from the given s-expression and context arguments:

%Given an s-expression, the function \verb{->py-so} creates a syntax object within the runtime system's context.

The parser produces a list of abstract syntax trees (one for each top-level statement in the original program).  They are accepted by the code generator as input.

\subsection{Code Generation}
\label{codegeneration}

The code generator must produce Scheme code from a list of ASTs.  It does so by converting the meaning of the supplied ASTs (by the parser described in section~\ref{parsing}) into the equivalent Scheme representation.  The following subsections display and explain the Scheme code generated for the most important parts of the Python language.

\subsubsection{Function Definitions}
\label{functions}

A python function has a few features not present in the syntax for Scheme functions.  Tuple variables are automatically unpacked, arguments may be specified by keyword instead of position, and those arguments left over (for which no key matches) are placed in a special dictionary argument.  To illustrate this, let us define the following Python function, which will consume three required arguments, a rest argument (for spilled-over positional arguments), and a dictionary argument:

\begin{verbatim}
def f(x, y, z, *rest, **dict):
    print x, y, z
    print rest
    print dict
\end{verbatim}

Keeping this function in mind, consider these two calls to \verb|f|:

\begin{verbatim}
Welcome to DrScheme, version 203.10-cvs27apr2003.
Language: Python.
> f(1, 2, 3, 4, 5, 6, test = 8)
1 2 3 
(4, 5, 6) 
{'test': 8} 
> f(1, z = 2, y = 3, test = 4)
1 3 2
() 
{'test': 4} 
\end{verbatim}

The right behavior is emulated by converting the function definition into the following Scheme code, where \verb{procedure->py-function%} takes a procedure, its name, and its argument names to produce an object representing the Python function:

\scm{
(define f
  (procedure->py-function%
   (opt-lambda (dict x y z . rest)
     (let ([rest (list->py-tuple% rest)])
       (call-with-escape-continuation
        (lambda (return10846)
          (py-print #f (list x y z))
          (py-print #f (list rest))
          (py-print #f (list dict))
          py-none))))
   'f (list 'x 'y 'z) null 'rest 'dict))
}

In this translation, \verb{procedure->py-function%}, \verb{list->py-tuple%}, and \verb{py-print} are runtime system functions, and \verb{py-none} is a runtime system constant representing the Python \verb{None}.  We will delay further discussion of the runtime system until section~\ref{runtimesystem}.  The more interesting part of the example is the generated lambda.

In the function described by the \verb{opt-lambda} expression, the compiler shifts the dictionary argument, \verb{dict}, into the first position among the function's parameters (where the function call mechanism knows to put keyword arguments), and places a \verb{let} binding to convert the Scheme list of leftover arguments -- the \verb{rest} in the \verb{opt-lambda} parameter list -- into the Python tuple of leftover arguments.  After handling parameters, the compiler generates the function's \verb{return} handler, followed by the function body itself.

The meaning of a Python \verb{return} statement can be emulated with a Scheme escape continuation, which represents the rest of the program.  A label is generated for the ``return'' continuation; any \verb{return} \emph{value} statement would be translated into \scm{(return10846} \emph{value}\scm{)}.  With the returning mechanism established, the function body can now be generated.

The body of a Python function being a sequence of statements, the code generator translates that into a sequence of Scheme commands (expressions evaluated for side-effect) plus the default return value, \verb{None}.

While it is fairly simple to convert a Python function into Scheme text that looks like a typical function definition, functions tend to look more like \verb{let} bindings when defined as class methods, as the next section displays.

\subsubsection{Class Definitions}

The Python built-in \verb{type} function returns a new type (synonymous and used interchangeably with class) when given a name, tuple of parents, and dictionary of member fields and methods.  The compiler generates a Python class object as the result of a call to \verb{type}.

Consider this small Python class:

\begin{verbatim}
class C(A, B):
    some_static_field = 7
    another_static_field = 3

    def m(this, x):
        return C.some_static_field + x
\end{verbatim}

In this class \verb|C|, three members are defined, the two static fields, and the method \verb|m|, which adds the value of the first static field to its argument.  This short example compiles into thirty-nine lines of Scheme code, which we now dissect:

\scm{
01(define C
02  (python-method-call type '__call__
03   (list
04    (symbol->py-string% 'C) (list->py-tuple% (list A B))
}

Since \verb|type| is both a class and a callable object, what looks like the function call \verb|type(...)| is in reality the \emph{static method} call \verb{type.__call__(...)}, which is what line 2 starts to invoke.  The \verb{__call__} method yields a new class object when given three arguments: a name, a tuple of parents, and a dictionary of fields and methods (or list of thunks ready to be converted into such a dictionary).  Line 4 hands off the class name, C, and a tuple of base classes, A and B, as the first two parameters of the call.  The third argument is a list of functions, each of which accept one argument, the created class, and returns a pair where the first item is the name of a class field or method and the second, its value.  The entire rest of the program listing makes up this third argument.

\scm{
05    (list
06     (lambda (this-class)
07       (list
08        'some_static_field
09        (number->py-number% 7)))
}

The need for wrapping each key-value pair around a function is shown in the result of compiling the next member field:

\scm{
10     (lambda (this-class)
11       (list
12        'another_static_field
13        (let-values ([(some_static_field)
14                      (values (python-get-member this-class
15                                                 'some_static_field
16                                                 #f))])
17          (number->py-number% 3))))
}

Notice the \scm{let-values} form wrapping the member field value.  In Python, at class creation time, member variables have access to the previously created ones.  To emulate this, the Scheme code must contain the right bindings when creating the member variable value, hence the need to always pass the class object to allow the extraction of currently bound values.  The number of bound member variables grows as more definitions are encountered by the class initializer, and so does the \scm{let-values}, as in the final part of the third \verb{type} argument.

\scm{
18     (lambda (this-class)
19       (list
20        'm
21        (let-values ([(another_static_field some_static_field)
22                      (values
23                       (python-get-member this-class
24                                          'another_static_field
25                                          #f)
26                       (python-get-member this-class
27                                          'some_static_field
28                                          #f))])
29          (procedure->py-function%
30           (opt-lambda (this x)
31             (call/ec (lambda (return1732)
32                        (return1732
33                          (python-method-call
34                          (python-get-attribute C
35                                                'some_static_field)
36                          '__add__
37                          (list x)))
38                        py-none)))
39           'm (list 'this 'x) (list) #f #f))))))))
}

This locally creates the proper bindings and adds the right python function to the class as a member method.  To bind top level variables, though, the compiler must create the appropriate \scm{define}s or \scm{let}s.

\subsubsection{Variable Assignments}

Identifiers are bound either at the top or function level.  Imported modules' identifiers are bound at a different top level (see section~\ref{import}).

Assignments at the top level are translated into \scm{define}s for first assignments or \scm{set!}s for mutative assignments.  In the following Python listing, the first line defines x, while the second line mutates x and defines y as the same value.

\begin{verbatim}
x = 1
x = y = 2
\end{verbatim}

The first line becomes the following two Scheme lines:

\scm{
(define rhs2320 (number->py-number% 1))
(define x rhs2320)
}

While it seems redundant to use an auxiliary variable (\verb{rhs2320}), its need is obviated in the translation of the second statement:

\scm{
(define rhs2321 (number->py-number% 2))
(set! x rhs2321)
(define y rhs2321)
}

As \verb{x} and \verb{y} share the same value, the right-hand side must only be evaluated once.  A similar strategy is followed for function variables, though as a current shortcoming of the compiler, they are all defined as \scm{void} at the start of a function.  For example, the following function uses a single variable, \verb{x}.

\begin{verbatim}
def f():
    print "fn start"
    x = 1
\end{verbatim}

Its body is translated into this Scheme equivalent (omitting the \scm{call/ec} scaffolding):

\scm{
(opt-lambda ()
  (let ([x (void)])
    (py-print #f
              (list (string->py-string% "fn start")))
    (let ([rhs1718 (number->py-number% 1)])
      (set! x rhs1718))
    py-none))
}

This does ensure that a runtime error is the result of using \verb{x} before its definition, but it does not provide a good error message.  This will be fixed in the future (see section~\ref{futurework}).

When a \verb{global} statement names any variable, the named variable is simply omitted from the Scheme function's initial \scm{let} bindings, thereby allowing assignments to said variable to mutate an identifier existing at the outer scope instead of defining a new one.

\subsubsection{Importing Modules}
\label{import}

In order to import a Python module at runtime -- and, in fact, to initialize the environment at startup -- the runtime system creates a new MzScheme namespace and populates it with the built-in library.  The runtime system then compiles the requested file and evaluates it in this new namespace.  Finally, new bindings are introduced in the original namespace for the necessary values.  For example, when evaluating the statement \verb{import popen from os}, only the binding for \verb{popen} is copied into the original namespace from the new one.

\subsection{The Runtime System}
\label{runtimesystem}

The examples in the previous section have all made references to \scm{py-print}, \scm{procedure->py-function%}, \scm{py-none}, and other runtime system library exports.  This section explains the runtime system and the runtime libraries used throughout the generated Scheme program text.

The Python runtime system models the mechanics of the Python language.  Python objects -- called \emph{python-nodes} in the runtime system for readability so as to not confuse them with the \verb{object} class that is also seen at many places in the source code -- have a type, a mutability specifier (so that you cannot, for example, change the contents of an immutable string), and a hash table (dictionary) of dynamic fields.  The syntactic form \emph{obj.attrib} refers, save a couple of exceptions, to the value associated with \emph{attrib} in \emph{obj}'s (or \emph{obj}'s parent's) dictionary.

For efficiency reasons, there are two special attributes not stored in the object dictionary:

\begin{enumerate}
\item \verb{__dict__} points to the object's dictionary; and
\item \verb{__class__} refers to the object's type.
\end{enumerate} 

Though an object's type is its \verb{__class__} attribute, a type's type is always the built-in \verb{type} object, and its parent classes are found in its \verb{__bases__} attribute.  Base types inherit from the built-in type \verb{object} (Figure~\ref{simpleclassfig}).

\begin{figure}
	\caption{A simple Python class}
	\label{simpleclassfig}
	\begin{center}
		\includegraphics{images/uml/simple-class}
	\end{center}
\end{figure}

With these concepts in mind, let us now explore a set of important functions from the runtime system.

\subsubsection{py-print}

\verb{py-print} accepts a list of objects to print, each one separated by a space character, and an output device object (one that has a \emph{write} method).  If the output object is false, the current output port is used.

\subsubsection{string-$>$py-string\%}

This function converts a Scheme string into a Python string.

\subsubsection{procedure-$>$py-function\%}

This function accepts a Scheme procedure, a function name symbol, a list of positional argument names, a list of optional argument names, a rest-argument name (or false), and a dictionary argument name (or false).  It returns a Python function object.
