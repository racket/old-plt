
;; texpict: MzScheme utils for creating LaTeX picture expressions

;;     >>>>>> THIS IS UNSUPPORTED SOFTWARE <<<<<<<

;; The utilities in this library are used to construct `pict'
;; structures. Functions are provided to create new simple picts
;; (e.g., `tex') or create new picts that include other picts (e.g.,
;; `ht-append'). In the latter case, the embedded picts retain their
;; identity, so that offset-finding functions (e.g., `find-lt') can
;; find the offset of the embedded pict in the larger pict.

;; Form of a pict:
;;                 w
;;         ------------------
;;        |                  | a  \
;;        |------------------|    |
;;        |                  |    | h
;;        |------------------|    |
;;        |                  | d  /
;;         ------------------     
;; For a single `tex' line, d is descent below the baseline and
;; a + d = h. For multiple tex lines (created with vX-append), a is 
;; ascent of top line above baseline and d is descent of bottom line,
;; so a + d < h. Other boxes have d = 0 and a = h.

;; To create a LaTeX picture, assemble a `pict' and then call
;; `pict->string'. This string can be `display'ed to obtain the LaTeX
;; code, which is of the form:
;;    \begin{picture} ... \end{picture}

;; The `tex' function creates a pict given an arbitrary LaTeX
;; expression as a string. Initially, `tex' guess at the size of the
;; resulting pict. (It always guesses 10 x 10.) The LaTeX expression
;; generated for a `tex' pict causes information to be written to an
;; auxilliary file when LaTeX evaluates the expression. If you use
;; `tex' boxes, then:

;;    * Use the package "mztp.sty" at the start of your LaTeX
;;      document "X.tex".
;;    * In the MzScheme code creating `tex' picts, call
;;      (read-in-sizes "X.mztp") before calling `tex'.
;;    * Run the texpict-LaTeX cycle twice to get properly
;;      draw pictures.

;; texpict keys `tex' size information on the exact LaTeX expression
;; provided to `tex'. If you use a single `tex' pict in two different
;; contexts where the provided expression produces differently sized
;; output, texpict cannot distinguish the uses (and the size of the
;; first instance of the pict will be used).

(define-signature texpict^
  ((struct pict (draw width height ascent descent children))
   (struct child (pict dx dy))

   ;; Load `tex' pict size information generated by a LaTeX run
   read-in-sizes  ; string -> void

   ;; Parameter specifying whether the `pict2e' package is active
   using-pict2e-package

   ;; Parameter specifying whether to draw precise lines for `connect'
   ;; with bezier curves. It be a boolean or a procedure that takes
   ;; a lenght and returns the number of points to use
   draw-bezier-lines
   
   ;; Boolean parameter: #t => resort to Bezier lines when an appropriate
   ;; slope is really hard to find.
   draw-bezier-hard-lines
   
   ;; Parameter specifying whether to draw in B&W or color (when
   ;; `colorize' is used)
   black-and-white

   ;; Find an embedded picture; see bottom for the definition of pict-path
   find-lt  ; (left & top)  ; pict pict-path -> dx dy
   find-lc  ; (left & vertical center)
   find-lb  ; (left & bottom)
   find-ltl ; (left and top baseline)
   find-lbl ; (left and bottom baseline)
   find-ct  ; (horizontal center & top)
   find-cc
   find-cb
   find-ctl
   find-cbl
   find-rt
   find-rc
   find-rb
   find-rtl
   find-rbl

   ;; Create a new pict that hides the given pict from find-XX
   launder  ; pict -> pict

   ;; Create an empty pict
   blank        ; w h -> pict

   ;; Create picts
   tex               ; string -> pict
   text-line         ; string -> pict
   text-line/phantom ; string string -> pict
   tex-paragraph     ; w string ['top|'bottom] -> pict

   ;; Delimitters to go around height h (result is taller than h)
   left-brace     ; h -> pict
   right-brace    ; h -> pict
   top-brace      ; h -> pict
   bottom-brace   ; h -> pict
   left-delimit   ; str h -> pict
   right-delimit  ; str h -> pict
   middle-delimit ; str h -> pict

   clip-descent   ; pict -> pict
   inset          ; pict i -> pict
                  ; pict hi vi -> pict
                  ; pict l t r b -> pict

   hline        ; w h -> pict
   dash-hline   ; w h seg -> pict
   vline        ; w h -> pict
   dash-vline   ; w h seg -> pict

   frame        ; pict -> pict
   dash-frame   ; pict seg-length -> pict ; dfeault seg-length is 5
   oval         ; pict -> pict
   oval/radius  ; pict r -> pict

   big-circle   ; diameter -> pict

   ; Make a container picture that doesn't draw the child picture,
   ; but uses the child's size
   ghost        ; pict -> pict

   record       ; pict pict ... -> pict

   vl-append    ; d pict ... -> pict
   vc-append
   vr-append
   ht-append
   hc-append
   hb-append
   htl-append
   hbl-append

   lt-superimpose ; pict ... -> pict
   lb-superimpose
   lc-superimpose
   ltl-superimpose
   lbl-superimpose
   rt-superimpose
   rb-superimpose
   rc-superimpose
   rtl-superimpose
   rbl-superimpose
   ct-superimpose
   cb-superimpose
   cc-superimpose
   ctl-superimpose
   cbl-superimpose

   ;; Make a table give a list of picts. The list should be a
   ;; concatentation of rows (so it formats correctly in Scheme code).
   ;;
   ;; The col-aligns, row-aligns, col-seps, and row-seps arguments are
   ;; `lists' specifying the row and columns alignments separation
   ;; between rows and columns.  For C columns and R rows, the first
   ;; two should have C and R superimpose procedures, and the last two
   ;; should have C - 1 and R - 1 numbers, respectively. The lists can
   ;; be improper (e.g. just a number), in which case the non-pair cdr
   ;; is used as the value for all remaining list items that were
   ;; expected. The alignment procedures are used to superimpose all
   ;; of the cells in a column or row; this superimposition determines
   ;; the total width oir height of the column or row, and also
   ;; determines the horizontal or vertical placement of each cell in
   ;; the column or row.
   ;;
   table ; ncols pict-list col-aligns row-aligns col-seps row-seps -> pict

   colorize ; pict color-string -> pict

   ;; Desribe a picture with low-level commands; see below
   picture      ; w h command-list -> pict

   ;; Create a new picture by `cons'ing drawing commands onto
   ;; and existing picture
   cons-picture ; pict command-list -> pict

   ;; Generate the LaTeX code for a pict
   pict->string))

#|

pict-path:

   pict
   non-empty-pict-path-list

commands:

   `(place ,x ,y ,pict)
   `(put ,x ,y ,putable)
   `(connect ,x1 ,y1 ,x2 ,y2 ,bool)    ; line or vector; bool => vector
   `(dconnect ,x ,y ,dx ,dy ,bool)     ; line or vector; bool => vector
   `(curve ,x1 ,y1 ,x2 ,y2 ,xc ,yc ,d) ; bezier curve; d is optional density

putables:

   draw
   `(line ,dh ,dv ,hlen)
   `(vector ,dh ,dv ,hlen)
   `(circle ,d)
   `(circle* ,d)
   `(frame ,draw)
   `(colorbox ,color-str ,draw)
   `(oval ,w ,h ,str) ; str is portion: e.g., "" or "[bl]"
   ; plus some more

draws:

   string ; latex string
   `(picture ,w ,h ,@command-list)

|#
