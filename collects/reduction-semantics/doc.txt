_Reduction Semantics_
_reduction-semantics_

This collection provides three files:

  _reduction-semantics.ss_: the core reduction semantics
  library

  _gui.ss_: a _visualization tool for reduction sequences_.

  _subst.ss_: a library for _capture avoiding substitution_.

In addition, the examples subcollection contains several
small languages to demonstrate various different uses of
this tool:

  _arithmetic.ss_: an arithmetic language with every
  possible order of evaluation

  _church.ss_: church numerals with call by name
  normal order evaluation

  _combinators.ss_: fills in the gaps in a proof in
  Berendrecht that i and j (defined in the file) are
  a combinator basis

  _future.ss_: an adaptation of Cormac Flanagan's future
  semantics.

  _ho-contracts.ss_: computes the mechanical portions of a
  proof in the Contracts for Higher Order Functions paper
  (ICFP 2002).

  _ho-contracts-pp.scm_: the pretty printer for
  ho-contracts.ss. 

  _macro.ss_: models macro expansion as a reduction semantics.

  _omega.ss_: the call by value lambda calculus and omega.

  _threads.ss_: shows how non-deterministic choice can be
  modelled in a reduction semantics.

  iswim.ss : see further below.

======================================================================

The _reduction-semantics.ss_ library defines a pattern
language, used in various ways:

  pattern = any
          | number
          | string
          | variable
          | hole
          | <symbol>
          | (name <symbol> <pattern>)
          | (in-hole <pattern> <pattern>)
          | (in-hole* <symbol> <pattern> <pattern>)
          | (side-condition <pattern> <guard>)
          | (cross <symbol>>)
          | (pattern ...)
          | <scheme-constant>

The patterns match sexpressions. The first pattern matches
any sepxression. The second pattern matches any number. The
third pattern matches any string. The `variable' pattern
matches any symbol. The <symbol> pattern stands for a
literal symbol that must match exactly (except, of course,
for any, number, string, hole, or variable which are
reserved). The pattern:

  (name <symbol> <pattern>)

matches <pattern> and binds it to the name <symbol>. 

The (in-hole <pattern> <pattern>) matches the first
pattern. This match must include exactly one match against
the `hole' pattern. The `hole' pattern matches any
sexpression. Then, the sexpression that matched the hole
pattern is used to match against the second pattern. The
in-hole pattern also binds `hole' in the right-hand side of
a reduction.

The (in-hole* <symbol> <pattern> <pattern>) is just like the
in-hole pattern, except that you can specify the name to be
implicitly bound. This is important to write reductions with
nested contexts; if you were to use in-hole twice, you would
get two bindings of `hole' and the pattern matcher would
require them to be equal, according to the semantics of
repeated variables.

The (side-condition pattern guard) pattern matches what the
embedded pattern matches, and then the guard expression is
evaluated. If it returns #f, the pattern fails to match,
and if it returns anything else, the pattern matches. In
addition, any occurrences of `name' in the pattern will be
bound in the guard.

The (cross <symbol>) pattern is used for the compatible
closure functions. If the language contains a non-terminal
with the same name as <symbol>, the pattern (cross <symbol>)
matches the context that corresponds to the compatible
closure of that non-terminal.

The (pattern ...) pattern matches a sexpression list, where
each pattern matches an element of the list. In addition, if
a list pattern contains an ellipses that is not treated as a
literal, instead it matches any number of duplications of the
pattern that came before the ellipses (including 0). Furthemore,
each (name <symbol> <pattern>) in the duplicated pattern
binds a list of matches to <symbol>, instead of a single match.
(A nested duplicated pattern creates a list of list matches,
etc.) Ellipses may be placed anywhere inside the row of 
patterns,  except in the first position or immediately after
another ellipses.  Multiple ellispes are allowed.

> (language (non-terminal pattern ...) ...)     SYNTAX

This form defines a context-free language. As an example,
this is the lambda calculus:

  (define lc-lang
    (language (e (e e ...)
                 variable
                 v)
              (c (v ... c e ...)
                 hole)
              (v (lambda (variable ...) e))))

with non-terminals e for the expression language, c for the
evaluation contexts and v for values.

> compiled-lang? : (any? . -> . boolean?)

Returns #t if its argument was produced by `language', #f
otherwise.

> (reduction language pattern bodies ...)       SYNTAX

This form defines a reduction. The first position must
evaluate to a language defined by the `language' form. The
pattern determines which terms this reductions apply to and
the last bodies are expressions that must evaluate to a new
sexpression corresponding to the reduct for this term. The
bodies are implicitly wrapped in a begin.

As an example, the reduction for the lambda calculus above
would be written like this:

     (reduction lc-lang
                (in-hole (name c c)
                         ((lambda ((name xs variable) ...) (name body e))
                          (name args v) ...))
                (replace c hole 
                 (foldl lc-subst body args xs)))

The first name is the lang definition from above. The second
argument is a pattern for an evaluation context. Here's how
it looks without the `name' patterns:

                (in-hole c
                         ((lambda (variable ...) e)
                          v ...))

The in-hole pattern matches a term against `c', and binds
what matches the hole to `hole'. Then, it matches what
matched the hole against ((lambda (variable) e) v).

With the name patterns restored, c, hole, xs, body, and args
are bound in the right hand side of the reduction. Then,
when the reduction matches, the result is the result of
evaluating the last argument to reduction. See `replace'
below and lc-subst is defined by using the subst.ss library
below.

> (reduction/context language context pattern bodies ...)   SYNTAX

reduction/context is a short-hand form of reduction. It
automatically adds the `in-hole' pattern and the call to
`replace'. The equivalent reduction/context to the above
example is this:

     (reduction/context 
      lang
      c
      ((lambda ((name x variable)) (name body e)) (name arg v))
      (lc-subst x arg body))

> red? : (any? . -> . boolean?)

Returns #t if its argument is a reduction (produced by `reduction',
`reduction/context', etc.), #f otherwise.

> compatible-closure : (red?
                        compiled-lang?
                        symbol?
                        . -> .
                        red?)

This function accepts a reduction, a language, the name of a
non-terminal in the language and returns the compatible
closure of the reduction for the specified non-terminal.

> context-closure : (red?
                     compiled-lang?
                     any
                     . -> .
                     red?)

This function accepts a reduction, a language, a pattern
representing a context (ie, that can be used as the first
argument to `in-hole'; often just a non-terminal) in the
language and returns the closure of the reduction
in that context.

> replace : (any? hole-binding? any? . -> . any)

The first argument to this function is an sexpression to
replace into. The second argument is the binding in the hole
(it contains the information about where to replace) and the
last argument is the sexpression to replace in the first
argument. It returns the replaced term.

> reduce : ((listof red?) any? . -> . (listof any?))

Reduce accepts a list of reductions, a term, and returns a
list of terms that the term reduces to.

> language->predicate : (compiled-lang?
                         symbol?
                         . -> . 
                         (any? . -> . boolean?))

Takes a language and a non-terminal name and produces
a predicate that matches instances of the non-terminal.

> match-pattern : (compiled-pattern 
                   any?
                   . -> .
                   (union false? (listof bindings?)))

This is mostly used to explore a particular pattern to
determine what is going wrong. It accepts a compiled pattern
and a and returns #f if the pattern doesn't match the term,
and returns bindings (an association list) if the terms do
match. The association maps from the `name' variables in the
pattern to the subterms they match.

> compile-pattern : (compiled-lang? any? . -> . compiled-pattern)

This is mostly used in conjunction with match-pattern to
explore particular patterns and terms when debugging. It
compiles a sexpression pattern to a pattern.

> variable-not-in : (any? symbol? . -> . symbol?)

This helper function accepts an sexpression and a
variable. It returns a variable not in the sexpression with
a prefix the same as the second argument.

======================================================================

The _gui.ss_ library provides two functions:

> (gui language reductions expr [pp])

This function calls gui/multiple with language, reductions
and (list expr).

> (gui/multiple lang reductions exprs [pp])
  lang : language
  reductions : (listof reduction)
  exprs : (listof sexp)
  pp : (any port number (is-a?/c text%) -> void)

This function opens a new window and inserts each
expr. Then, reduces the terms until either
reduction-steps-cutoff (see below) different terms are
found, or no more reductions can occur. It inserts each new
term into the gui. Clicking the `reduce' button reduces
until reduction-steps-cutoff more terms are found.

The pp function renders its first argument into the port
(its second argument) with width at most given by the
number. The final argument is the text where the port is
connected -- characters written to the port go to the end of
the editor. The default pp uses mzlib's pretty-print
function. See the ho-contracts for an example use of this
argument.

You can save the contents of the window as a postscript file
from the menus.

> (reduction-steps-cutoff)
> (reduction-steps-cutoff number)

A parameter that controls how many steps the `gui' function
takes before stopping.

> (initial-font-size)
> (initial-font-size number)

A parameter that controls the initial font size for the terms shown
in the GUI window.

> (initial-char-width)
> (initial-char-width number)

A parameter that determines the initial width of the boxes
where terms are displayed (measured in characters)

======================================================================

The _subst.ss_ library provides these names:

> (subst (match-pattern subst-rhs ...) ...)      SYNTAX

The result of this form is a function that performs capture
avoiding substition for a particular (sexp-based)
language. The function accepts three arguments, a variable,
a term to substitue and a term to substitute into.

Each of the `match-pattern's specify the forms of
the language and the `subst-rhs's specify what kind of form
it is.  Each of the match-patterns are in (lib "match.ss"
"match)'s pattern language and any variable that they bind
are avaialbe in the <scheme-expression>'s described below.

The language of the subst-rhs follows.

> (variable)

  this means that the rhs for this form is a symbol that
  should be treated like a variable. Nothing may follow
  this.

> (constant)

  this means that the rhs for thsi form is a constant that
  cannot be renamed. Nothing may follow this.

> (all-vars <scheme-expression>)

This form indicates that this pattern in the language binds
the variables produced by the
<scheme-expression>. 

Immediately following this in a subst-rhs must be a (build
...) form and some number of (subterm ...) or (subterms ...)
forms.

> (build <scheme-expression>)

This form must come right after an (all-vars ...) form and
before any (subterm ...) or (subterms ...) forms.

This form tells subst how to reconstruct this term. The
<scheme-expression> must evaluate to a procedure that
accepts the (possibly renamed) variables from the all-vars
clause, and one argument for each of the subterms that
follow this declaration (with subterms flattened into the
argument list) in the same order that the subterm or
subterms declarations are listed.

> (subterm <scheme-expression> <scheme-expression>)

The first <scheme-expression> must be a list of variables
that is a sub-list of the variables in the all-vars
expression. The second expression must be an sexp
corresponding to one of the subexpressions of this
expression (matched by the match-patten for this clause of
subst).

> (subterms <scheme-expression> <scheme-expression>)

The first <scheme-expression> must be a list of variables
that is a sub-list of the variables in the all-vars
expression. The second expression must be an sexp
corresponding to one of the subexpressions of this
expression (matched by the match-patten for this clause of
subst).

Consider this example of a substition procedure for the
lambda calculus:

  (define lc-subst
    (subst
     [`(lambda ,vars ,body)
      (all-vars vars)
      (build (lambda (vars body) `(lambda ,vars ,body)))
      (subterm vars body)]
     [(? symbol?) (variable)]
     [(? number?) (constant)]
     [`(,fun ,@args)
      (all-vars '())
      (build (lambda (vars fun . args) `(,fun ,@args)))
      (subterm '() fun)
      (subterms '() args)]))

The first clause matches lambda expressions with any number
of arguments and says that there is one subterm, the body of
the lambda, and that all of the variables are bound in it.

The second clause matches symbols and indicates that they
are variables.

The third clause matches numbers and indicates that they are
constants.

The final clause matches function applications. The
`all-vars' shows that applications introduce no new
names. The build procedure reconstructs a new application
form. The subterm declaration says that the function
position is a subterm with no variables bound in it. The
subterms declaration says that all of the arguments are
subterms and that they do not introduce any new terms.

In this program, lc-subst is bound to a function that does
the substition. The first argument is the variable to
substitute for, the second is the term to substitute and the
final argument is the term to substitute into. For example,
this call:

  (lc-subst 'q 
            '(lambda (x) y) 
            '((lambda (y) (y q)) (lambda (y) y)))

produces this output:

  '((lambda (y@) (y@ (lambda (x) y))) (lambda (y) y))

This library also provides:

> subst/proc
> alpha-rename 
> free-vars/memoize

Theses functions are the procedure-based interface to
substitution that subst expands to and uses.

======================================================================

The _iswim.ss_ module in the "examples" sub-collection defines a
grammar and reductions from "Programming Languages and Lambda Calculi"
by Felleisen and Flatt.

       Example S-expression forms of ISWIM expressions:
         Book                     S-expr
         ----                     ------
         (lambda x . x)           ("lam" x x)
         (+ '1` '2`)              ("+" 1 2)
         ((lambda y y) '7`)       (("lam" y y) 7)

       See "iswim.ss" for the reduction-semantics grammar.

       The following are provided by "iswim.ss" (case-insensitively):
               Grammar and substitution:
>                 iswim-grammar : compiled-lang?
>                 M? : (any? . -> . boolean?)
>                 V? : (M? . -> . boolean?)
>                 o1? : (M? . -> . boolean?)
>                 o2? : (M? . -> . boolean?)
>                 on? : (M? . -> . boolean?)
>                 iswim-subst : (M? symbol? M? . -> . M?)
               Reductions:
>                 beta_v : red?
>                 delta : (listof red?)
>                 ->v : (listof red?)
>                 :->v : (listof red?)
               Abbreviations:
>                 if0 : (M? M? M? . -> . M?)
>                 true : M?
>                 false : M?
>                 mkpair : M?
>                 fst : M?
>                 snd : M?
>                 Y_v : M?
>                 sum : M?
               Helpers:
>                 delta*1 : (o1? V? . -> . (union false? V?))
                     delta as a function for unary operations.
>                 delta*2 : (o2? V? V? . -> . (union false? V?))
                     delta as a function for binary operations.
>                 delta*n : (on? (listof V?) . -> . (union false? V?))
                     delta as a function for any operation.
>                 function-reduce* : ((listof red?)
                                      any?
                                      (any? . -> . boolean?)
                                      . -> . (listof any?))
                     A poor-man's `gui' for test interaction. The
                     first argument represents a set of reductions
                     that define a function; the second argument is
                     the starting expression; the last argument is
                     a predicate to recognize ending expressions.
                     The function applies the reductions repeatedly
                     until an ending expression os found, or the
                     reduction gets stuck. The result is the list of
                     expressions leading to the ending expression.
