;; Reconstruct types from flow information
;; see TR 00-359 for a description of a similar algorithm
;; some details differ here 

(unit/sig newspidey:type-reconstruction^
  (import [mzlib : mzlib:core-flat^]
          [setexp : newspidey:datadef-setexp^]
          [type : newspidey:datadef-types^]
          [cgp : newspidey:constraints-gen-and-prop^])

; (listof binding)
; invariant: list is partitioned so that the bindings where the 
;   binder occurs in the type are at the beginning of the list
(define rec-bindings 'not-initialized)

; (hash-table-of sym -> (union #f (listof sym)))
; returns #f iff the sym is the name of a type variable that
;  does not occur in its binding
(define *rec-bindings-rec-table* (make-hash-table))

; (hash-table-of sym -> type)
; these are the alpha's and omega's that are needed by 
;  mk-type-aux; they only need to be computed once 
;  so we memoize them here
(define *set-var-to-type-table* (make-hash-table))

; sym type -> void
(define (associate-set-var-and-type set-var type)
  (hash-table-put! *set-var-to-type-table* (setexp:Set-var-name set-var) type))

; sym -> (union #f type)
(define (lookup-type-from-set-var set-var)
  (hash-table-get *set-var-to-type-table* (setexp:Set-var-name set-var) 
		  (lambda () #f)))

; -> void
; populates *set-var-to-type-table*
(define (init-set-var-to-type)
  (for-each
   (lambda (set-var)
     (associate-set-var-and-type set-var (make-type-aux set-var)))
   (cgp:get-all-set-vars)))

; sym -> type
; this is mk-type from the TR
; one small optimization: we substitute set-var's type for 
;  set-var in the body of the recursive type, so we 
;  don't have to do it during type reduction
(define (mk-type set-var)
  (let ([omega-set-var (lookup-type-from-set-var set-var)]
        [all-set-vars (cgp:get-all-set-vars)])
    (type:make-Type-Rec
     ;;(map list all-set-vars (map lookup-type-from-set-var all-set-vars))
     rec-bindings ;; already reduced
     omega-set-var)))

; sym (listof sym) -> (listof sym)
; used when computing omega_dom's
(define (set-var-upper-bounds set-var accum)
  (let* ([ubs (cgp:lookup-lo-and-filter setexp:Set-var? set-var)]
         [new-ubs (mzlib:filter (lambda (ub)
                                  (not (memq ub accum)))
                                ubs)]
         [new-accum (cons set-var (append new-ubs accum))])
    (remove-duplicates-eq
     (cons
      set-var
      (apply append
             (map (lambda (ub)
                    (set-var-upper-bounds ub new-accum))
                  new-ubs))))))

; (listof eq-ables) -> (listof eq-ables)
(define (remove-duplicates-eq l)
  ;;(printf "list: ~a~n" l)
  (if (null? l)
      '()
      (let ([l-car (car l)]
            [l-cdr (cdr l)])
        (if (memq l-car l-cdr)
            (remove-duplicates-eq l-cdr)
            (cons l-car (remove-duplicates-eq l-cdr))))))

; sym -> type
; changes from TR: omega-arrow is a *union* type, where each element
;  is generated by a case-lambda clause
(define (make-type-aux alpha)
  (let* ([lookup-filtered-set-exp
          (lambda (pred alpha)
            (types->type
             (cgp:lookup-hi-and-filter pred alpha)))]
         [omega-c
          (lookup-filtered-set-exp setexp:Const? alpha)]
         [omega-cons
          (if (null? (cgp:lookup-hi-and-filter setexp:Token? alpha))
              type:*empty-type*
              (let ([omega-car (lookup-filtered-set-exp setexp:Set-var? (setexp:make-Car alpha))]
                    [omega-cdr (lookup-filtered-set-exp setexp:Set-var? (setexp:make-Cdr alpha))])
                (type:make-Type-Cons omega-car omega-cdr)))]
         [omega-arrow
          (let* ([labels (cgp:lookup-hi-and-filter setexp:Label? alpha)])
            (if (null? labels)
                type:*empty-type*
                (type:make-Type-Union
                 (let* ([arities (apply append (map (lambda (label)
                                                       (cgp:lookup-ars-from-label (setexp:Label-name label)))
                                                     labels))]
                        ;;[foo (printf "arities: ~a~n" arities)]
                        [deltas (set-var-upper-bounds alpha '())]
;                        [doms-omega (apply APPLY
;                                     append
;                                     (map
;                                      (lambda (delta)
;                                        (cgp:lookup-hi-and-filter
;                                         setexp:Set-var?
;                                         (setexp:make-Dom-interval (setexp:make-Interval 'star 'star) 0 delta)))
;                                      deltas))]
			)
                   ;;(printf "alpha: ~a~nlabels: ~a~ndeltas: ~a~n" alpha labels deltas)
                   (map
                    (lambda (arity)
                      (let* ([int (setexp:Arity-req arity)]
                             [n (setexp:Interval-lo int)]
                             [m (setexp:Interval-hi int)]
                             [max-j (if (eq? m 'omega) (add1 n) n)]
                             [omega-doms (let loop ([j 1])
                                           (if (> j max-j)
                                               '()
                                               (cons
                                                (types->type (remove-duplicates-eq
                                                 (apply
                                                  append
                                                  ;; doms-omega APPLY
                                                  (map
                                                   (lambda (delta)
;                                                     (cgp:lookup-hi-and-filter
;                                                      setexp:Set-var?
;                                                      (setexp:make-Dom-interval int j delta))
                                                     ;; no need to filter, we filter before calling
                                                     ;; relate-set-var-to-dom in add-contraint-and-update-tables
                                                     (cgp:lookup-set-vars-from-dom-int int delta j)
                                                     )
                                                   deltas))))
                                                (loop (add1 j)))))]
                             [omega-rng (lookup-filtered-set-exp setexp:Set-var? (setexp:make-Rng-arity arity alpha))])
                        ;;(printf "max-j: ~a~nomega-doms: ~a~n" max-j omega-doms)
                        ;;(printf "TYPE: ~a -> ~a~n" omega-doms omega-rng)
                        (type:make-Type-Arrow omega-doms omega-rng)))
                    arities)))))])
    (type:make-Type-Union (list omega-c omega-cons omega-arrow))))
  
; (listof type) -> type
; implements Set2Type from TR
(define (types->type set-vars)
  (let ([len (length set-vars)])
    (cond
      [(= len 0) type:*empty-type*]
      [(= len 1) (car set-vars)]
      [else (type:make-Type-Union set-vars)])))


; -> void
; reduce types in *set-var-to-type-table*
; only needs to be done once
(define (type-reduce-rec-bindings)
  (let* ([bindings (hash-table-map *set-var-to-type-table*
                                   (lambda (name type)
                                     (type:make-Type-Binding
                                      (setexp:make-Set-var name)
                                      type)))])
(set! rec-bindings (let loop ([cur-bindings bindings]
                                  [accum '()])
                         (if (null? cur-bindings)
                             accum
                             (let* ([binding_i (car cur-bindings)]
                                    [set-var_i (type:Type-Binding-set-var binding_i)]
                                    [type_i (type:Type-Binding-type binding_i)])
                               (if (is-recursive-rec-binding? binding_i)
                                   (loop (cdr cur-bindings)
                                         (cons (type:make-Type-Binding
                                                set-var_i
                                                (type-reduce type_i))
                                               accum))
                                   (cons (type:make-Type-Binding
                                          set-var_i
                                          (type-reduce type_i))
                                         (loop (cdr cur-bindings)
                                               accum)))))))))

; binding -> (union #f (listof sym))
; interface to *rec-bindings-rec-table*
(define (is-recursive-rec-binding? binding)
  (let ([name (setexp:Set-var-name (type:Type-Binding-set-var binding))]
        [type (type:Type-Binding-type binding)])
    (hash-table-get *rec-bindings-rec-table* name
                    (lambda ()
                      (let ([answer (memq name (extract-set-vars type))])
                        (hash-table-put! *rec-bindings-rec-table* name answer)
                        answer)))))

; type -> (listof sym) 
; all set vars that occur in a type
(define (extract-set-vars type)
  ;;(printf "type: ~a~n" type)
  (let ([map-and-flatten (lambda (lst)
                           (apply append
                                  (map extract-set-vars lst)))])
    (cond
      [(setexp:Const? type) '()]
      [(setexp:Set-var? type) (list (setexp:Set-var-name type))]
      [(type:Type-Rec? type)
       (remove-duplicates-eq
        (apply append
               (map-and-flatten (map type:Type-Binding-type (type:Type-Rec-bindings type)))
               (extract-set-vars (type:Type-Rec-type type))))]
      [(type:Type-Arrow? type)
       (remove-duplicates-eq
        (append
         (map-and-flatten (type:Type-Arrow-doms type))
         (extract-set-vars (type:Type-Arrow-rng type))))]
      [(type:Type-Cons? type)
       (remove-duplicates-eq
        (append (extract-set-vars (type:Type-Cons-car type))
                (extract-set-vars (type:Type-Cons-cdr type))))]
      [(type:Type-Union? type)
       (remove-duplicates-eq
        (map-and-flatten (type:Type-Union-types type)))]
      [(type:Type-Empty? type) '()])))


; implements type reduction rules
; type -> type
(define (type-reduce type)
  ;;(printf "type-reduce: ~a~n" type)
  (cond
    [(setexp:Set-var? type) type]
    [(type:Type-Rec? type)
     (cond
       ;; rec already done when creating the rec-type in mk-type
       ;; rec-elim
       [(null? (type:Type-Rec-bindings type))
        (type-reduce (type:Type-Rec-type type))]
       ;; unfold
       [else (let* ([first-rec-binding (car (type:Type-Rec-bindings type))]
                    [rest-rec-bindings (cdr (type:Type-Rec-bindings type))]
                    [alpha (setexp:Set-var-name (type:Type-Binding-set-var first-rec-binding))]
                    [omega (type:Type-Binding-type first-rec-binding)]
                    [body-type (type:Type-Rec-type type)])
               (when (not (is-recursive-rec-binding? first-rec-binding))
                 (if (extract-set-vars body-type) ;; optimisation
                     (type-reduce (type:make-Type-Rec
                                   (map (lambda (binding)
                                          (type:make-Type-Binding
                                           (type:Type-Binding-set-var binding)
                                           (type-subst (type:Type-Binding-type binding) alpha omega)))
                                        rest-rec-bindings)
                                   (type-subst body-type alpha omega)))
                     (type-reduce body-type))))])]
    [(type:Type-Union? type)
     (let* ([types (type:Type-Union-types type)]
            ;; union
            [types-reduced (map type-reduce types)]
            ;; empty-filter
            [types-filtered (mzlib:filter (lambda (type) (not (eq? type type:*empty-type*))) types-reduced)]
            ;; union-merger
            [types-flattened (let loop ([cur-types types-filtered])
                               (if (null? cur-types)
                                   '()
                                   (let ([cur-type (car cur-types)])
                                     (if (type:Type-Union? cur-type)
                                         (append (type:Type-Union-types cur-type)
                                                 (loop (cdr cur-types)))
                                         (cons cur-type
                                               (loop (cdr cur-types)))))))]
            [types-length (length types-flattened)])
       (cond
         [(= types-length 0) type:*empty-type*]
         [(= types-length 1) (car types-flattened)]
         [else (type:make-Type-Union types-flattened)]))]
    [(type:Type-Cons? type)
     (type:make-Type-Cons (type-reduce (type:Type-Cons-car type))
                          (type-reduce (type:Type-Cons-cdr type)))]
    [(type:Type-Arrow? type)
     (type:make-Type-Arrow (map type-reduce (type:Type-Arrow-doms type))
                           (type-reduce (type:Type-Arrow-rng type)))]
    [(setexp:Const? type) type]
    [(type:Type-Empty? type) type]))

; type sym type -> type
(define (type-subst type alpha omega)
  (cond
    [(type:Type-Union? type)
     (type:make-Type-Union 
      (map (lambda (type) 
	     (type-subst type alpha omega)) 
	   (type:Type-Union-types type)))]
    [(type:Type-Cons? type)
     (type:make-Type-Cons (type-subst (type:Type-Cons-car type) alpha omega)
                          (type-subst (type:Type-Cons-cdr type) alpha omega))]
    [(type:Type-Arrow? type)
     (type:make-Type-Arrow 
      (map (lambda (type) 
	     (type-subst type alpha omega)) 
	   (type:Type-Arrow-doms type))
      (type-subst (type:Type-Arrow-rng type) alpha omega))]
    [(type:Type-Rec? type)
     (type:make-Type-Rec 
      (map (lambda (binding)
	     (let ([set-var (type:Type-Binding-set-var binding)]
		   [type (type:Type-Binding-type binding)])
	       (type:make-Type-Binding set-var (type-subst type alpha omega))))
	   (type:Type-Rec-bindings type))
      (type-subst (type:Type-Rec-type type) alpha omega))]
    [(setexp:Set-var? type)
     (if (mzlib:symbol=? (setexp:Set-var-name type) alpha)
         omega
         type)]
    [(setexp:Const? type) type]
    [(type:Type-Empty? type) type]
    [else (error "type-subst: unknown type: ~a~n" type)]))

  ) ;; unit/sig