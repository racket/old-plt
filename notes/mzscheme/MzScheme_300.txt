
MzScheme version 300 is different from previous versions of MzScheme
in several significant ways:

 * MzScheme's reader is case-sensitive for symbols/identifier by
   default. Prefix an S-expression with #ci to make it
   case-insensitive.

 * MzScheme now directly supports Unicode. The "char" datatype
   corresponds to a Unicode code point, and strings correspond to a
   sequence of code points. Meanwhile, a new "byte string" datatype
   implements a sequence of bytes (exact integers between 0 and 255),
   and byte strings take over the old role of strings with respect to
   low-level port operations.

   Regexp matching works on both char strings and byte strings, and
   MzScheme provides various operations for encoding chars as byte
   strings. See the "Unicode" section below for more information.

 * Related to the Unicode change, MzScheme now uses a distinct "path"
   datatype for file and directory names, instead of using
   strings. Built-in procedures that accept a path also accept a
   string (and implicitly convert it); procedures that produce a path
   never produce a string. See the "Paths" section below for more
   details.

 * The built-in exception hierarchy has been revised and streamlined
   (again). See the "Exceptions" section below for more details.

 * A continuation is no longer tied to its creating thread.

   Various continuation barriers remain in place, such as around the
   call to an exception handler or syntax expander, and also around
   the start of MzScheme's main thread. The main thread's barrier
   prevents continuations captured in the main thread from being used
   in other threads (which should make sense, intuitively, because
   then other threads could become "main"). A newly created thread,
   however, has no such barrier, so that created threads can trade
   continuations.

 * The "parameter" construct has been redefined. The new definition is
   indistinguishable from the old one, except that (1) the body of a
   `parameterize' is in tail position with respect to the entire
   `parameterize' expression, (2) a `parameterize' expression tends to
   execute much more quickly, while parameter lookup tends to be
   slightly slower, (3) a `parameterize' has the expected effect if a
   continuation is captured during the `parameterize' body and invoked
   in a different thread.

   Preserved thread cells now provide precisely the senatics of old
   "parameters". A new "parameter" maps a continuation to a preserved
   thread cell, which in turn provides a thread-specific value.

 * The `break-enabled' procedure no longer corresponds to a parameter,
   because changing the break-enable state implies a check for a
   suspended break, and this check is incompatible with tail
   evaluation of `parameterize' forms.

   Related to this change, if a `with-handlers' handler is called to
   handle an exception, breaks are initially disabled for the handler,
   but the handler is not called in tail position with respect to the
   `with-handlers' form. (The body is in tail position, though.) Use
   `with-handlers*' to make a handler called in tail position, but
   without breaks disabled.

 * The `object-wait-multiple' function has been renamed to
   `sync/timeout', and `sync' is the same procedure without a timeout
   argument. The `object-wait-multiple/enable-break' procedure has
   been renamed to `sync/timeout/enable-break', and
   `sync/enable-break' enables breaks without a timeout.

   The "waitable" procedures have been renamed to "evt" procedures in
   general, often dropping "make-". "Evt" stands for "synchronizable
   event". Several new event-generating procedures have been added.

            Old                        New
            ---                        ---
            object-waitable?           evt?
            waitables->waitable-set    choice-evt
            make-channel-put-waitable  channel-put-evt
            make-semaphore-peek        semaphore-peek-evt
            make-wrapped-waitable      convert-evt or finish-evt
            make-guard-waitable        guard-evt
            make-nack-guard-waitable   nack-guard-evt
            make-poll-guard-waitable   poll-guard-evt
            thread-dead-waitable       thread-dead-evt
            thread-suspend-waitable    thread-suspend-evt
            thread-resume-waitable     thread-resume-evt

                                       alarm-evt
                                       read-bytes-avail!-evt
                                       write-bytes-avail-evt

======================================================================
 Unicode
======================================================================

The "char" datatype means "Unicode code point", which technically
should not be confused with "Unicode character". But most things that
a literate human would call a "character" can be represented by a
single code point in Unicode, so the "code point" approximation of
"character" works well for many purposes. See section 1.2 in the
MzScheme manual for an overview of MzScheme's approach to Unicode and
locales.

Actually, "char" corresponds to Unicode extended to include code
points up to (sub1 (expt 2 31)). In particular, `integer->char'
produces a character for every exact integer from 0 to #x7FFFFFFF,
except #xFFFF, #xFFFE, and #xD800 to #xDFFF (which are not code points
and never will be).

The `bytes->string/utf-8' and `string->bytes/utf-8' functions convert
between the two kinds of strings via UTF-8.  The `bytes->string/utf-8'
accepts an optional character to use in place of bad encoding
sequences (otherwise an exception is raised).

A general `bytes-convert' interface lets you convert among different
encodings in a bytes, including UTF-8 and the current locale's
encoding. The conversion interface can deal with input that ends
mid-encoding, so it can be used for conversion on streams, too. (The
converter uses iconv() where available.)

Internally, strings are encoded as UCS-4, but symbols are encoded in
UTF-8.

Other details:

 * The `char->latin-1-integer' and `latin-1-integer->char' procedures
   have been removed.

 * Added a `bytes-...' operation for most every `string-...' operation.
   The `byte?' predicate returns true for exact integers in [0,255].

 * `regexp' produces a char regexp, and `byte-regexp' produces a byte
   regexp. A regexp can be matched against a byte string (or port), in
   which case the byte string (or port) is interpreted as a UTF-8
   encoding. Similarly, a regexp can be matched against a string, in
   which case the string is encoded via UTF-8 before matching.

 * A hash before a string makes it a byte-string literal:

      (string->list "hi") = '(#\h #\i)
      (bytes->list #"hi") = '(104 105)

   Similarly, #rx"...." is a regexp, while #rx#"...." is a byte
   regexp.

 * Use #\uXXXX or #\UXXXXXXXX for arbitrary character constants, where
   each X is a hexadecimal digit and the resulting number identifies a
   code point. In a string (but not a byte string), use "\uXXXX" or
   "\UXXXXXXXX".

 * All of the `char-whitespace?', `char-alphabetic?', etc. functions
   are defined in accordance with SRFI-14. New functions include
   `char-title-case?', `char-blank?', `char-graphic?' `char-symbolic?',
   and `char-titlecase'.

 * The built-in string functions remain locale-independent (as in
   SRFI-13), and `string-locale=?', etc. provide locale-sensitive
   comparisons. The `string-locale-upcase' and
   `string-locale-downcase' functions provide locale-sensitive case
   conversion. No locale-sensitive character operations are provided
   (the old ones have been removed).

 * Case-insensitivity for symbols is consistent with SRFI-13, which
   means using the 1-1 character mapping defined by the Unicode
   consortium.

   Number parsing recognizes only ASCII digits (and A-F/a-f) for
   numbers, but all `char-whitespace?' characters are treated as
   whitespace by `read'.

 * MzScheme effectively assumes UTF-8 stdin and stdout. DrScheme reads
   and writes text files using UTF-8.

Ports
-----

"port" still means "byte port" in MzScheme. Various port operations,
like `read-string-avail!', have been renamed to to `read-bytes-avail!'.

Character operations on a port, such as `read-char' and `read-string',
are defined in terms of a UTF-8 parsing/writing of the port's byte
stream. (With a custom-port wrapper and the byte-string conversion
functions, other decodings can be implemented.)

Position and column counting for a port is sensitive to UTF-8.  For
example, reading #o302 followed by #o251 increments the position and
column by 1, instead of 2.

======================================================================
 Paths
======================================================================

Under Unix, paths fundamentally byte strings, not strings. Typically,
the correct printing of a path use the current locale's encoding, but
there's no guarantee that the path is well-formed using the current
locale's encoding.

To mediate these view of paths, MzScheme now supplies a "path"
datatype, with operations `path->string', `string->path',
`bytes->string', and `bytes->path'. Use `path->string' to print a path
to the user, but use `path->bytes' to marshal a path (e.g., for saving
a pathname in a file).

All functions that consume a pathname accept a string and implicitly
convert it (via the user's locale's default encoding) to a byte-string
pathname.

Under Windows, where a pathname is a UTF-16 string, MzScheme
internally converts to and from byte strings via UTF-8<->UTF-16. A
byte string that is not a UTF-8 encoding will never correspond to a
pathname under Windows.

======================================================================
 Exceptions
======================================================================

The new exception hierarchy distinguishes between breaks and failures
at nearly the top level of the hierarchy. In particular, most
`with-handlers' expressions should use the `exn:fail?' predicate,
insteda of the old (and now removed) `not-exn-break?' predicate.

The "type" and "mismatch" exceptions have been merged into
`exn:fail:contract'. Similarly, `exn:i/o:tcp' and `exn:i/o:udp'
have been merged into `exn:fail:network'.

Many exception fields have been eliminated, but certain exceptions
contain multiple source loations instead of just one. Instead of a
single type for all exceptions with source locations, the
`exn:srclocs' property identifies exceptions with source-location
information.

Structs:

  exn  - message continuation-marks
    exn:fail
      exn:fail:contract
        exn:fail:contract:arity
        exn:fail:contract:divide-by-zero
        exn:fail:contract:continuation
        exn:fail:contract:variable  - id
      exn:fail:syntax  - exprs
      exn:fail:read  - sources
        exn:fail:read:eof
        exn:fail:read:non-char
      exn:fail:filesystem
        exn:fail:filesystem:exists
        exn:fail:filesystem:version
      exn:fail:network
      exn:fail:out-of-memory
      exn:fail:unsupported
    exn:break  - continuation

  special-comment  - width
  ; Note: not exn:special-comment, because it doesn't need
  ;  a message or marks

Properties:

 exn:srclocs  - accessor

======================================================================
 Inside MzScheme (extend MzScheme via C)
======================================================================

A structure that represents a Scheme type should now start with a
Scheme_Object, instead of Scheme_Type. A Scheme_Object contains only a
Scheme_Type (except in 3m mode), so it takes the same amount of space
as before. But using Scheme_Object instead of Scheme_Type ensures that
casts to and from Scheme_Object* do not run afoul of C99's aliasing
assumptions.

SCHEME_STRINGP(), etc. have been replaced by SCHEME_CHAR_STRINGP(),
etc. and SCHEME_BYTE_STRINGP(), etc.  A character is reprsented by the
`mzchar' type, which corresponds to an unsigned integer (4 bytes).

In addition to functions scheme_char_string...() which operate on
`mzchar' arrays, some functions scheme_utf8_string...() are provided,
which accept a `char' array and interpret it as a UTF-8 encoding.
Several UTF-8 <-> mzchar conversion functions are also provided.

SCHEME_PATHP() recognizes the new path type. Use SCHEME_STRING_PATHP()
to recognize either a string or path, and use scheme_string_to_path()
to convert a string to a path.

The error_buf field of Scheme_Thread is now a pointer to a mz_jmp_buf,
instead of an inlined mz_jmp_buf. The protocol for temporarily
catching an exception is now as follows:

  mz_jmp_buf *save, fresh;
  save = scheme_current_thread->error_buf;
  scheme_current_thread->error_buf = &fresh;
  if (scheme_setjmp(scheme_error_buf)) {
    /* There was an error or continuation invocation */
    if (scheme_jumping_to_continuation) {
      /* It was a continuation jump */
      scheme_longjmp(*save, 1);
      /* To block the jump, instead: scheme_clear_escape(); */
    } else {
      /* It was a primitive error escape */
    }
  } else {
    /* Whatever might escape. */
    ....
  }
  scheme_current_thread->error_buf = save;

The input and output port driver interfaces have changed to accomodate
progress events and commits (for input ports) and write events (for
output ports). For most port types, the new features can be
implemented automatically by MzScheme with a small amount of extra
work in the driver.
