First, note that you don't need to compile MzScheme unless you wantto modify it. The standard PLT distribution provides an executableMzScheme application:  http://www.cs.rice.edu/CS/PLT/packages/mzscheme/=====================================================================This folder contains most of the Mac-specific files for compilingMzScheme and/or MrEd with CodeWarrior Pro 5. The folder must be named "cw" and placed in "plt:src".=====================================================================There are three possible forms for the MzScheme application:  1) as a plain Mac application (the usual form);  2) as an application that uses MzScheme as a shared library      but the same dynamic extension convention as the plain      application form; or  3) as an application that uses MzScheme as a shared library     and exploits CFM-linking for dynamic extension linking     (instead of a custom jump table defined by MzScheme).[Ed. Note --- forms 2 and 3 are not currently supported. (2001-05)]Instructions for each form are below.Dynamic extensions are supported via CFM in all cases (thanksto William Ng).The last step of each build puts the final application directly in the "plt" folder (i.e., two levels up from the CW projects).Shared libraries also go to the "plt" folder, but staticintermediate libraries are built here in the "cw" folder.---------------------------Form #1: Plain application---------------------------To build a standalone MzScheme, build the "MzScheme(app).mcp" project.  It has two targets, one for PPC and one for 68K.This is the form of MzScheme as distributed by the PLT at Rice.Although "mzc" is the preferred way to compile extension, weprovide two example projects showing how to compile extensionsdirectly in Metrowerks:   dynext( stdext) - creates dynexample.so   oe( stdext) - creates oe.soTo load the resulting extensions, first make an alias to theMetrowerks "MSL RuntimePPC.DLL" shared library and put it in the samelocation as the extension. (The dynext extension is statically linkedwith the ANSI C library; you could use "MSL C.PPC.DLL", instead.)-------------------------------------------------------Form #2: Application using MzScheme as a shared library-------------------------------------------------------To build MzScheme as a sharded library with the wrapper application,compile (only PPC projects are provided):   the gc   MzScheme(lib)   MzScheme(cfm)  --- generates MzScheme.PPC.cfm shared library   MzScheme(appl via cfm)The MzScheme application and MzScheme.PPC.cfm are put three foldersup, right in the "plt" folder.To run this MzScheme, you must first copy two libraries fromMetrowerks into the same folder as MzScheme:	 MSL RuntimePPC.DLL	 MSL C.PPC.DLL	 Aliases to the libraries can be used instead of compyig the libraries.Also, the libraries or aliases can be put in the System folder insteadof with MzScheme.MzScheme.PPC.cfm can be loaded anto any other application supportingcode fragments. The two Metrowerks libraries are also needed in thatcase.Dynamic extensions for this form of mzScheme are compiled the sameas for the plain MzScheme application.-----------------------------------------------------------------Form #3: Application that uses CFM-based linking for extensions-----------------------------------------------------------------To build MzScheme as a shared library that exploits CFM-linkingfor dynamic extensions, compile:   the gc   MzScheme(lib)   MzScheme(cfm+)  --- generates MzScheme.PPC.cfm shared library   MzScheme(appl via cfm)   The MzScheme application and MzScheme.PPC.cfm are put two foldersup, right in the "plt" folder.Just as in form #2 above, the two Metrowerks libraries are neededto run MzScheme this way.Example dynamic extensions using CFM-linking are built with:   dynext(cfm+ext)   oe(cfm+ext)NOTE: The CFM-based extension linking is not compatible withprecompiled applications distributed by the PLT at Rice, orwith mzc.=====================================================================If you are compiling from scratch, and you want the launcherapplications (such as mzc), also compile the  MzStarter  project. This project creates the GoMz application that is usedas a template by the "launcher" collection. We provide only".68k" projects, which work for both 68k and PPC platforms; alauncher performs little work, so there's no need to make thesystem more complex by having both 68k and PPC launchers. Theproject writes the GoMz application to the launcher collectionfolder: "plt:collects:launcher".After creating GoMz, hold down the Command key, double-click onMzScheme, and provide the  following command line in the dialog:  -mvqL- setup.ss compiler  This step creates all of the other applications in "plt" (besidesMrEd and MzScheme). It also makes .zo files; to skip compiling .zos,add -n to the end of the command line.=====================================================================See the GC notes for information about setting up a project from scratch.Note that MzScheme depends on 4-byte 'int's. The file macconf.h must beused as the prefix file for compiling MzScheme, or maccfm.h if MzSchemeis to be compiled with CFM-based dynamic extensions. When compiling with CodeWarrior on the PowerPC, *do not* put static variables in TOC; this will break the garbage collector. Far globals are fine for 68K.=====================================================================-Matthew mflatt@rice.edu