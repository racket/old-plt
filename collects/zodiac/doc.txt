
Using _Zodiac_
--------------

The top-level way:

   (require-library "invoke.ss" "zodiac")
   ; binds global names prefixed with `zodiac:';
   ; zodiac:internal-error and zodiac:static-error
   ;  can be redefined afterwards.

The unit/sig way:

  Elaboration time:
   (require-library "zsigs.ss" "zodiac")
   (require-library "sigs.ss" "zodiac")

  Link time:
   (require-library-unit/sig "link.ss" "zodiac")
   Imports:
      zodiac:interface^ ; see "Error Handlers" below
      mzlib:pretty-print^
      mzlib:file^
   Exports:
      zodiac:system^ ; no `zodiac:' prefix

Reader Procedures
-----------------

> (zodiac:read p (zodiac:make-location 1 1 0 filename)) - reads from
  the port `p', which represents the file indicated by the `filename'
  string.  Returns a PROCEDURE that gets each expression as a zodiac
  AST. When the reader encounters an eof-of-file, it returns an
  instance of zodiac:eof.

Expander Procedures
-------------------

> (zodiac:scheme-expand expr [attr 'previous] [vocab #f]) - expands
  one expression, reprsented as a zodiac AST, returning a zodiac AST.

> (zodiac:scheme-expand-program exprs [attr 'previous] [vocab #f]) -
  expands several expressions, reprsented as a list of zodiac ASTs,
  returning a list of zodiac ASTs.

Zodiac AST -> S-Expression
--------------------------

> (zodiac:parsed->raw expr) - converts a zodiac AST to an S-expression
   (losing location information, obviously).

Vocabularies
------------

> beginner-vocabulary
> intermediate-vocabulary
> advanced-vocabulary
> full-vocabulary - advanced + units and objects
> scheme-vocabulary - MzScheme (unlike full-vocabulary, local, send*,
                     etc. are not present until the correcponding
                     `define-macro' expression in MzLib is evaluated
                     at elaboration time)

Handler Parameters
------------------

> (elaboration-evaluator [proc]) - parameter for the evaluatotr used
  to evaluate begin-elaboration-time bodies and the RHS of a macro
  definition.

 default: (lambda (expr parsed->raw phase)
            (eval (parsed->raw expr)))

> (user-macro-body-evaluator [proc]) - parameter for the evaluator
  used to evaluate macro applications.

 default: (lambda (x . args)
            (eval `(,x ,@(map (lambda (x) `(#%quote ,x)) args))))

Error Handlers
--------------

Zodiac relies on two error handlers that are provided by its
>     zodiac:interface^
import: 
>   internal-error - for when things go wrong in zodiac that should
                     never go wrong
>   static-error - for input errors during read or expand.

A zodiac error handler takes a zodiac AST followed by format-style
 arguments. For example:

 (define (static-error where fmt-spec . args)
    (printf "Error at: ~s~n" where) ; or, pull location out of `where'
    (apply error 'syntax-error fmt-spec args))

Example
-------

  (require-library "invoke.ss" "zodiac")
  (let ([r ((zodiac:read (open-input-string "(cons 1 null)")
                         (zodiac:make-location 1 1 0 "string")))])
    (eval (zodiac:parsed->raw (zodiac:scheme-expand r))))
  = (list 1)


Correlating Source
------------------

Quickref:

    who           how     source expression?
    ---           ---     ------------------
    'source       ...     yes
    'reader       ...     yes
    'duplicate    ...     no
    'micro        expr    iff expr is src
    'macro        expr    iff expr is src
    'non-source   ...     no

Details:

Although there is not a unique mapping from elaborated expressions to
source expressions, Zodiac gurantess that the mapping is unique when
restricted to elaborated expressions that have a source-who field of
'source or 'reader. When a source expression is duplicated by
elaboration (e.g., the `loop' in `(let loop () (loop))' => `(letrec
([loop (lambda () (loop))]) (loop))'), all but the first instance get
a 'duplcate source-who annotation. (The source-how field contains the
original source record.)

When an expression is dervied from a macro or micro expansion, the
source-who field contains 'micro or 'macro. The source-how field
contains the expression that was macro- or micro-expanded to produce
the expression. Thus, the result of a macro or micro-expansion
corresponds to a particular source expression iff the source-how field
contains an expression that corresponds to a particular source
expression.

The 'non-source value for the who field indicates that there is no
source expression that is equivalent to the expanded expression.  In
this case, a macro or micro must have manufactured the syntax; for
example, the `this' binding intoroduced by class* -> class*/names has
source-who value 'non-source. Of course, the location field of
"non-source" syntax still matches the syntax to a particular source
expression.
