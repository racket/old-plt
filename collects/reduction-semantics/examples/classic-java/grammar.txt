This implementation of ClassicJava *is* case-sensitive.

terminals: class null true false this new ref set send cast let if
           + - * == and or zero? null? not int bool
           
Symbols and integer literals are also terminal symbols in this language.

program     ::= defn* e

defn        ::= (class cname1 cname2 (field*) method*)
                    ;; class cname1 extends cname2 { field* method* }

field       ::= (type fname)

method      ::= (type mdname (arg*) expr)

arg         ::= (type argname)

expr        ::= null
              | integer literal
              | true
              | false
              | argname                       ;; local binding reference
              | this
              | (new cname)                   ;; new cname()
              | (ref expr fname)              ;; expr.fname
              | (set expr1 fname expr2)       ;; expr1.fname = expr2
              | (send expr1 mdname expr*)     ;; expr1.mdname(expr*)
              | (cast cname expr)             ;; (cname) expr
              | (let argname expr expr)       ;; local variable declaration
              | (bprim expr expr)             ;; binary primitive operators
              | (uprim expr)                  ;; unary primitive operators
              | (if expr1 expr2 expr3)        ;; conditional operator:
                                              ;;    expr1 ? expr2 : expr3

bprim       ::= + | - | * | == | and | or
uprim       ::= zero? | null? | not

type        ::= int | bool | cname
cname       ::= id                            ;; class name
fname       ::= id                            ;; field name
mdname      ::= id                            ;; method name
argname     ::= id                            ;; method arg/local var name

id          ::= any symbol except reserved words (those which appear in
                capitals above)


Equivalence of ClassicJava and real Java forms:
===============================================

  class Foo extends Bar {
      int x;
      bool y;
      int method(bool arg) { ... }
  }
    is equivalent to
  (class Foo Bar 
    ((int x) 
     (bool y))
    (int method ((bool arg)) ...))

Expressions
----------------------------------------------------------------------
  -  new Foo()                          (new Foo)
  -  obj.field                          (ref obj field)
  -  obj.field = rhs                    (set obj field rhs)
  -  obj.method(arg1, arg2)             (send obj method arg1 arg2)
  -  (Foo) obj                          (cast Foo obj)
  -  { int local_var = 3; body; }       (let local_var 3 body)
  -  text_exp ? then_exp : else_exp     (if test_exp then_exp else_exp)

And built-in binary and unary operators as listed above are expressed in
prefix notation: (+ 3 (* 4 5)) .
