
____Plot quick-start guide

1) Making basic Plots

After loading the correct module '(require (lib "plot.ss" "plot"))' type in the following command

(plot (line (lambda (x) x)) 

Any other function with the contract number -> number can be plotted in a similar fashion.
To plot multiple items, use mix or mix* :
(plot (mix (line (lambda (x) (sin x))) (line (lambda (x) (cos x)))))

The appearance of the plot can be changed by adding parenthesized argument/value pairs after the first argument
(plot (line (lambda (x) (sin x))) (x-min -1) (x-max 1) (title "Sin(x)"))

For a full list of arguments see below.

The appearance of each individual plot item can be altered by passing an associative list 
of parameters to the plot item.
(plot 
      (line 
      (lambda (x) x) 
      '((color green) (width 3))))

Besides plotting lines from functions in 2d, the plotter can also render a variety of other datums
in several ways:

To plot a 3d function z = f(x,y) on a 2 dimensional surface:

(define 3dfun (lambda (x y) (* (sin x) (sin y))))

; By Contours:
(plot (contour 3dfun))

; By color shading
(plot (shade 3dfun))

; gradient field
(plot (field (gradient 3dfun)))

; all together
(plot (mix*   
            (shade 3dfun)
	    (contour 3dfun)
	    (field (gradient 3dfun) '((samples 25))))

      (x-min -1.5) (x-max 1.5) (y-min -1.5) (y-max 1.5) (title "gradient field +shade + contours of F(x,y) = sin(x) * sin(y)"))

; To plot discreet data points

(plot (points (list (vector 1 1) (vector 2 2))))

; To plot a 3d surface

(plot3d (surface 3dfun '((color green))))

2) Curve Fitting

To fit up a particular function to a curve:

; set up the independent variable data
(define x-data '(0 1 2 3 4))

; set up the dependent variable data
(define results '(3 5 7 9 11))

; set up the function to be fitted using fit-lambda
; our function looks like f(x) = m*x + b
(define fit-fun (fit-lambda (x) (m b) (+ b (* m x))))

; make a guess (optional) about the results
(define guess '((b 2))

; now do the fit
(define fit-result (fit fit-fun guess x-data results 1))

; to see the resulting function with the original data points
(plot (mix* (points (map vector x-data results))
	    (line (fit-result-function fit-result)))
      (y-max 15))

; to see the paramaters
(fit-result-final-params fit-result)

3) Making custom plots.

Defining custom plots is simple : a renderer (that is passed to plot or mix) is just a function
that acts on a view-snip. both the 2d and 3d view snip have several drawing functions defined that
the renderer can call in any order. The full details of the view interface can be found in the
view-interface.txt file. Also, there are several predefined macros and functions defined 
in syntax.ss and renderer-helpers.ss that can be usefull in creating your own renderers.

For eaxmple, if we wanted to create a renderer that draws dashed-lines instead of lines given a
number-number function we could:

(require (lib "syntax.ss" "plot")
         (lib "class.ss")
         (lib "renderer-helpers.ss" "plot"))

(define dashed-line
  (r-lambda fun 2dview (x-min x-max) ((samples 100) (segments 20) (color 'red) (width 1))    
    (let* ((dash-size (/ (- x-max x-min) segments))
           (x-lists (build-list (/ segments 2) 
                                (lambda (index)                                    
                                  (x-values 
                                   (/ samples segments) 
                                   (+ x-min (* 2 index dash-size))
                                   (+ x-min (* (add1 ( * 2 index)) dash-size)))))))
      (send* 2dview 
        (set-line-color color)
        (set-line-width width))
      (for-each (lambda (dash)
                  (send 2dview plot-line 
                        (map (lambda (x) (vector x (fun x))) dash))) 
                x-lists))))
    
(plot (dashed-line (lambda (x) x) '((color red))))
