#!/bin/sh
#|
# PLT software installer
# Configures PLTHOME path within scripts
# For certain platforms and installations, adds extra directory links (to reach
# non-standard binaries through the platform's standard path)
# Can create .zo files or re-use existing ones (modifying .dep files)

if [ ! \( -x "install" -a -d "collects" \) ]; then
  echo "(Trying to get to the installation directory...)"
  if [ -x "/bin/dirname" ]; then
    cd "`/bin/dirname \"$0\"`"
  elif [ -x "/usr/bin/dirname" ]; then
    cd "`/usr/bin/dirname \"$0\"`"
  else
    dirname="`which dirname`"
    if [ ! -z "$dirname" ]; then
      cd "$dirname"
    fi
  fi
fi

if [ ! \( -x install -a -d collects \) ]; then
  echo "install: must be run from its own directory"
  exit 1
fi

if [ -x ./bin/mzscheme ]; then
  exec ./bin/mzscheme -qr "$0" ${1+"$@"}
elif [ -x ./MzScheme.exe ]; then
  exec ./MzScheme.exe -qr "$0" ${1+"$@"}
else
  echo "install: cannot execute mzscheme"
  echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  echo "!!               Install incomplete!               !!"
  echo "!!                                                 !!"
  echo "!! If you downloaded the source distribution, see  !!"
  echo "!!        src/README for build instructions.       !!"
  echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
fi

exit 1
|#

(use-compiled-file-kinds 'none)

(define plthome (current-directory))
(putenv "PLTHOME" plthome)
(putenv "PLTCOLLECTS" "")
(current-library-collection-paths (list (build-path plthome "collects")))

;; this will be the same as plthome, except when a `-p' argument is used.
;; `plthome' always points at the current plthome, the one we use to load
;; stuff.
(define fake-plthome plthome)

(define zos?         'ask)
(define scripts?     #t)
(define deps?        #f)
(define updates?     'ask)
(define interactive? #t)

(define in-osx-install? (getenv "OSX_PLT_INSTALL"))
(define in-rpm-install? (getenv "RPM_INSTALL_PREFIX"))
(define in-rpm-build? (and (getenv "RPM_OPT_FLAGS") (not in-rpm-install?)))

(when (or in-osx-install? in-rpm-install? in-rpm-build?) (set! updates? #f))
(when (or in-osx-install? in-rpm-install?)               (set! zos? #t))
(when in-rpm-build?                                      (set! zos? #f))

(require (lib "cmdline.ss"))
(command-line "install" argv
  (multi
   (("-z")
    "skip .zo file compilation."
    (set! zos? #f))
   (("+z")
    "compile .zo files (default: ask)."
    (set! zos? #t))
   (("-s")
    "skip modifying PLTHOME in scripts."
    (set! scripts? #f))
   (("+s")
    "modify PLTHOME setting in scripts (default)."
    (set! scripts? #t))
   (("-d")
    "skip modifying .dep files (default)."
    (set! deps? #f))
   (("+d")
    "modify .dep files paths and compiled timestamps (ignore unless `+s' and `-z')."
    (set! deps? #t))
   (("-u")
    "skip on-line updates checking."
    (set! updates? #f))
   (("+u")
    "check for on-line updates (default: ask)."
    (set! updates? #t))
   (("-i")
    "non-interactive mode."
    (set! interactive? #f))
   (("+i")
    "interactive mode (default)."
    (set! interactive? #t))
   (("-p") explicit-home
    "use explicit PLTHOME value instead of the current directory."
    (if (absolute-path? explicit-home)
      (set! fake-plthome explicit-home)
      (error './install
             "bad value for PLTHOME, expected an absolute path, got ~s"
             explicit-home)))))

(when (and deps? (or (not scripts?) zos?))
  (printf "Warning: can't modify .dep files due to command-line flags.\n")
  (set! deps? #f))

(define didnothing? #t)
(define old-plthome #f)

(when in-osx-install?
  (namespace-require '(lib "mred.ss" "mred"))
  (namespace-require '(lib "class.ss")))
;; Set up GUI
(when in-osx-install?
  (let ([evt (make-eventspace)]
	[there-was-an-error? #f])
    (parameterize ([current-eventspace evt])
      (define f (make-object frame% "PLT Installer" #f 600 480))
      (define e (make-object text%))
      (define c (make-object editor-canvas% f e))
      (define b (make-object button% "Stop Installation" f
			     (lambda (b e)
			       (when (or there-was-an-error?
					 (eq? 'ok (message-box
						   "Stop Installation"
						   "Ok to stop the installation?"
						   f
						   '(ok-cancel))))
				 (exit 1)))))
      (send e lock #t)
      (send e auto-wrap #t)
      (let ([out (make-custom-output-port
		  #f
		  (lambda (string start end flush?)
		    (parameterize ([current-eventspace evt])
		      (queue-callback
		       (lambda ()
			 (send e lock #f)
			 (send e insert (substring string start end)
			       (send e last-position))
			 (send e lock #t))
		       #f))
		    (- end start))
		  void
		  void)])
	(current-output-port out)
	(current-error-port out))
      (send f show #t)
      (let ([old-exit (exit-handler)])
	(exit-handler (lambda (v)
			(unless (zero? v)
			  (parameterize ([current-eventspace evt])
			    (queue-callback
			     (lambda ()
			       (send e lock #f)
			       (let ([s (send e last-position)])
				 (send e insert "INSTALLATION FAILED" s)
				 (let ([ss (send e last-position)])
				   (send e insert "\n(click button below to continue)" ss)
				   (send e change-style 
					 (let ([d (make-object style-delta% 'change-bold)])
					   (send d set-delta-foreground "red")
					   d)
					 s ss))
				 (send e lock #t))
			       (send b set-label "Quit Installation")
			       (set! there-was-an-error? #t))
			     #f))
			  (semaphore-wait (make-semaphore)))
			(old-exit v)))))))

(define (get-y-n lines)
  (or (not interactive?)
      (begin (for-each display lines)
             (display " [y] ")
             (flush-output)
             (let ([r (read-line)])
               (not (regexp-match "^ *[nN]" r))))))

(define (update-scripts)
  (printf "setting PLTHOME to ~s in scripts:\n" fake-plthome)
  (parameterize ([current-directory "bin"])
    (for-each
     (lambda (f)
       (cond
        [(not (file-exists? f)) '-]
        [(and (file-exists? f) (> (file-size f) 4096))
         (printf " skipping ~a\n" f)]
        [else
         (set! didnothing? #f)
         (printf " checking ~a..." f)
         (let-values
             ([(lines changed?)
               (with-input-from-file f
                 (lambda ()
                   (let loop ([ls null] [changed? #f])
                     (let ([l (read-line)])
                       (cond
                        ((eof-object? l) (values (reverse ls) changed?))
                        ((regexp-match #rx"^( *)PLTHOME=(.*)$" l) =>
                         (lambda (m)
                           (let ((m (regexp-match #rx"\"(.+)\"" (caddr m))))
                             (when (and deps? m)
                               (let ((old (regexp-replace
                                           #rx"\\\\(.)" (cadr m) "\\1")))
                                 (when (and old-plthome deps?
                                            (not (equal? old old-plthome)))
                                   (printf "Warning: can't modify .dep files, ~a.\n"
                                           "got inconsistent PLTHOMEs in scripts")
                                   (set! deps? #f))
                                 (set! old-plthome old))))
                           (loop (cons (format "~aPLTHOME=~s"
                                               (cadr m) fake-plthome)
                                       ls)
                                 #t)))
                        (else (loop (cons l ls) changed?)))))))])
           (if changed?
             (begin (printf " updating\n")
                    (with-output-to-file f
                      (lambda ()
                        (for-each (lambda (l) (display l) (newline)) lines))
                      'truncate))
             (printf " nothing to do\n")))]))
     (directory-list))))

(define (update-deps)
  (printf "Touching compiled files, ~a...\n"
          (if (and old-plthome (not (equal? fake-plthome old-plthome)))
            (format "and updating dependencies: ~s -> ~s"
                    old-plthome fake-plthome)
            (begin (set! old-plthome #f)
                   "no need to change dependencies")))
  (parameterize ([current-directory (build-path plthome "collects")])
    (define (recurse op)
      (define (do-files path)
        (lambda (x)
          (if (directory-exists? x)
            (parameterize ([current-directory x])
              (let ([do-dir (do-files (cons (string->symbol x) path))])
                (map do-dir (directory-list))))
            (op x path))))
      (map (do-files null) (directory-list)))
    (define current-time (current-seconds))
    (define (touch f delta)
      (file-or-directory-modify-seconds f (+ delta current-time)))
    (define old-plthome-len
      (and (string? old-plthome) (string-length old-plthome)))
    (define (plthome:old->new path)
      (cond [(and (string? path)
                  old-plthome-len
                  (<= old-plthome-len (string-length path))
                  (string=? old-plthome (substring path 0 old-plthome-len)))
             (string-append
              fake-plthome
              (substring path old-plthome-len (string-length path)))]
            [(pair? path)
             (cons (plthome:old->new (car path)) (plthome:old->new (cdr path)))]
            [else path]))
    (recurse (lambda (f path)
               (when (memq 'compiled path)
                 (cond [(regexp-match #rx"\\.dep$" f)
                        (when old-plthome
                          (let ((dep (with-input-from-file f read)))
                            (with-output-to-file f
                              (lambda () (write (plthome:old->new dep)))
                              'truncate)))]
                       [(regexp-match #rx"\\.zo$" f)
                        (touch f 0)]
                       [(and (memq 'native path)
                             (regexp-match #rx"\\.(dll|so)$" f))
                        (touch f 5)]))))))

;; ============================================================================
;; Start working here

;; ---------- update scripts ----------

(when scripts? (update-scripts))

;; ---------- on-line updates ----------

(when (eq? 'ask updates?)
  (set! updates?
        (get-y-n
         (list "Check for updates of PLT software over the Internet (y/n)?"))))

(require (lib "check-text.ss" "version"))
(when updates? (check-version))

;; ---------- update .deps and compiled timestamps ----------

(when deps? (update-deps))

;; ---------- make .zo files ----------

(when (eq? 'ask zos?)
  (set! zos?
        (get-y-n
         '("PLT software starts up much faster with .zo files, but\n"
           "creating .zo files now takes a few minutes and requires\n"
           "several MB of additional disk space.\n"
           "(If your distribution contains .zo files, this process\n"
           "will be very fast.)\n"
           "  Create .zo files now (y/n)?")))
  (unless zos?
    (printf "Skipping .zo-file creation; create .zo files later by running\n")
    (printf "  ~a/bin/setup-plt\n" plthome)))

(when zos?
  ;; Need a new namespace to ensure that all modules are compiled, including
  ;; ones we've already loaded.  We also need to re-enable compiled files,
  ;; since cm.ss checks on that flag.
  (parameterize ([current-namespace (make-namespace)]
		 [use-compiled-file-kinds 'all]
                 [current-command-line-arguments #("--trust-zos")])
    (dynamic-require '(lib "setup.ss" "setup") #f)))

;; ---------- done ----------

(when interactive?
  (printf "PLT installation done~a.\n" (if didnothing? " (nothing to do)" ""))
  (when (file-exists? "bin/drscheme")
    (for-each display
              '("Run DrScheme as bin/drscheme.\n"
                "For Help, select `Help Desk' from DrScheme's `Help' menu,\n"
                "or run bin/help-desk.\n"))))
