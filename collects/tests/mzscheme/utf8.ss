
(load-relative "loadtest.ss")

(SECTION 'utf8)

(define basic-utf8-tests
  '((#(#x3ba #x1f79 #x3c3 #x3bc #x3b5)
     (#\316 #\272 #\341 #\275 #\271 #\317 #\203 #\316 #\274 #\316 #\265))
    (#(0)
     (#\nul))
    (#(#x00000080)
     (#\302 #\200))
    (#(#x00000800)
     (#\340 #\240 #\200))
    (#(#x00010000)
     (#\360 #\220 #\200 #\200))
    (#(#x00200000)
     (#\370 #\210 #\200 #\200 #\200))
    (#(#x04000000)
     (#\374 #\204 #\200 #\200 #\200 #\200))
    (#(#x0000007F)
     (#\rubout))
    (#(#x000007FF)
     (#\337 #\277))
    ;; Should this one be allowed? We check below that it's
    ;;  disallowed!
    ;; (#(#x0000FFFF)
    ;;  (#\357 #\277 #\277))
    (#(#x001FFFFF)
     (#\367 #\277 #\277 #\277))
    (#(#x03FFFFFF)
     (#\373 #\277 #\277 #\277 #\277))
    (#(#x7FFFFFFF)
     (#\375 #\277 #\277 #\277 #\277 #\277))
    (#(#x0000D7FF)
     (#\355 #\237 #\277))
    (#(#x0000E000)
     (#\356 #\200 #\200))
    (#(#x0000FFFD)
     (#\357 #\277 #\275))
    (#(#x0010FFFF)
     (#\364 #\217 #\277 #\277))
    (#(#x00110000)
     (#\364 #\220 #\200 #\200))
    (#()
     (#\200))
    (#()
     (#\277))
    (#()
     (#\200 #\277))
    (#()
     (#\200 #\277 #\200))
    (#()
     (#\200 #\277 #\200 #\277))
    (#()
     (#\200 #\277 #\200 #\277 #\200))
    (#()
     (#\200 #\277 #\200 #\277 #\200 #\277))
    (#()
     (#\200 #\277 #\200 #\277 #\200 #\277 #\200))
    (#()
     (#\200))
    (#()
     (#\201))
    (#()
     (#\202))
    (#()
     (#\203))
    (#()
     (#\204))
    (#()
     (#\205))
    (#()
     (#\206))
    (#()
     (#\207))
    (#()
     (#\210))
    (#()
     (#\211))
    (#()
     (#\212))
    (#()
     (#\213))
    (#()
     (#\214))
    (#()
     (#\215))
    (#()
     (#\216))
    (#()
     (#\217))
    (#()
     (#\220))
    (#()
     (#\221))
    (#()
     (#\222))
    (#()
     (#\223))
    (#()
     (#\224))
    (#()
     (#\225))
    (#()
     (#\226))
    (#()
     (#\227))
    (#()
     (#\230))
    (#()
     (#\231))
    (#()
     (#\232))
    (#()
     (#\233))
    (#()
     (#\234))
    (#()
     (#\235))
    (#()
     (#\236))
    (#()
     (#\237))
    (#()
     (#\240))
    (#()
     (#\241))
    (#()
     (#\242))
    (#()
     (#\243))
    (#()
     (#\244))
    (#()
     (#\245))
    (#()
     (#\246))
    (#()
     (#\247))
    (#()
     (#\250))
    (#()
     (#\251))
    (#()
     (#\252))
    (#()
     (#\253))
    (#()
     (#\254))
    (#()
     (#\255))
    (#()
     (#\256))
    (#()
     (#\257))
    (#()
     (#\260))
    (#()
     (#\261))
    (#()
     (#\262))
    (#()
     (#\263))
    (#()
     (#\264))
    (#()
     (#\265))
    (#()
     (#\266))
    (#()
     (#\267))
    (#()
     (#\270))
    (#()
     (#\271))
    (#()
     (#\272))
    (#()
     (#\273))
    (#()
     (#\274))
    (#()
     (#\275))
    (#()
     (#\276))
    (#()
     (#\277))
    ;; 2-byte seqs with no continuation
    (#(#f 32)
     (#\300 #\space))
    (#(#f 32)
     (#\301 #\space))
    (#(#f 32)
     (#\302 #\space))
    (#(#f 32)
     (#\303 #\space))
    (#(#f 32)
     (#\304 #\space))
    (#(#f 32)
     (#\305 #\space))
    (#(#f 32)
     (#\306 #\space))
    (#(#f 32)
     (#\307 #\space))
    (#(#f 32)
     (#\310 #\space))
    (#(#f 32)
     (#\311 #\space))
    (#(#f 32)
     (#\312 #\space))
    (#(#f 32)
     (#\313 #\space))
    (#(#f 32)
     (#\314 #\space))
    (#(#f 32)
     (#\315 #\space))
    (#(#f 32)
     (#\316 #\space))
    (#(#f 32)
     (#\317 #\space))
    (#(#f 32)
     (#\320 #\space))
    (#(#f 32)
     (#\321 #\space))
    (#(#f 32)
     (#\322 #\space))
    (#(#f 32)
     (#\323 #\space))
    (#(#f 32)
     (#\324 #\space))
    (#(#f 32)
     (#\325 #\space))
    (#(#f 32)
     (#\326 #\space))
    (#(#f 32)
     (#\327 #\space))
    (#(#f 32)
     (#\330 #\space))
    (#(#f 32)
     (#\331 #\space))
    (#(#f 32)
     (#\332 #\space))
    (#(#f 32)
     (#\333 #\space))
    (#(#f 32)
     (#\334 #\space))
    (#(#f 32)
     (#\335 #\space))
    (#(#f 32)
     (#\336 #\space))
    (#(#f 32)
     (#\337 #\space))
    ;; 3-byte seqs with no continuation
    (#(#f 32)
     (#\340 #\space))
    (#(#f 32)
     (#\341 #\space))
    (#(#f 32)
     (#\342 #\space))
    (#(#f 32)
     (#\343 #\space))
    (#(#f 32)
     (#\344 #\space))
    (#(#f 32)
     (#\345 #\space))
    (#(#f 32)
     (#\346 #\space))
    (#(#f 32)
     (#\347 #\space))
    (#(#f 32)
     (#\350 #\space))
    (#(#f 32)
     (#\351 #\space))
    (#(#f 32)
     (#\352 #\space))
    (#(#f 32)
     (#\353 #\space))
    (#(#f 32)
     (#\354 #\space))
    (#(#f 32)
     (#\355 #\space))
    (#(#f 32)
     (#\356 #\space))
    (#(#f 32)
     (#\357 #\space))
    ;; 3-byte seqs with partial continuation
    (#(#f 32)
     (#\340 #\203 #\space))
    (#(#f 32)
     (#\341 #\203 #\space))
    (#(#f 32)
     (#\342 #\203 #\space))
    (#(#f 32)
     (#\343 #\203 #\space))
    (#(#f 32)
     (#\344 #\203 #\space))
    (#(#f 32)
     (#\345 #\203 #\space))
    (#(#f 32)
     (#\346 #\203 #\space))
    (#(#f 32)
     (#\347 #\203 #\space))
    (#(#f 32)
     (#\350 #\203 #\space))
    (#(#f 32)
     (#\351 #\203 #\space))
    (#(#f 32)
     (#\352 #\203 #\space))
    (#(#f 32)
     (#\353 #\203 #\space))
    (#(#f 32)
     (#\354 #\203 #\space))
    (#(#f 32)
     (#\355 #\203 #\space))
    (#(#f 32)
     (#\356 #\203 #\space))
    (#(#f 32)
     (#\357 #\203 #\space))
    ;; 4-byte seq with no continuations
    (#(#f 32)
     (#\360 #\space))
    (#(#f 32)
     (#\361 #\space))
    (#(#f 32)
     (#\362 #\space))
    (#(#f 32)
     (#\363 #\space))
    (#(#f 32)
     (#\364 #\space))
    (#(#f 32)
     (#\365 #\space))
    (#(#f 32)
     (#\366 #\space))
    (#(#f 32)
     (#\367 #\space))
    ;; 4-byte seq with only 1 continuation
    (#(#f 32)
     (#\360 #\203 #\space))
    (#(#f 32)
     (#\361 #\203 #\space))
    (#(#f 32)
     (#\362 #\203 #\space))
    (#(#f 32)
     (#\363 #\203 #\space))
    (#(#f 32)
     (#\364 #\203 #\space))
    (#(#f 32)
     (#\365 #\203 #\space))
    (#(#f 32)
     (#\366 #\203 #\space))
    (#(#f 32)
     (#\367 #\203 #\space))
    ;; 4-byte seq with only 2 continuation
    (#(#f 32)
     (#\360 #\203 #\203 #\space))
    (#(#f 32)
     (#\361 #\203 #\203 #\space))
    (#(#f 32)
     (#\362 #\203 #\203 #\space))
    (#(#f 32)
     (#\363 #\203 #\203 #\space))
    (#(#f 32)
     (#\364 #\203 #\203 #\space))
    (#(#f 32)
     (#\365 #\203 #\203 #\space))
    (#(#f 32)
     (#\366 #\203 #\203 #\space))
    (#(#f 32)
     (#\367 #\203 #\203 #\space))
    ;; 5-byte seqs with no continuation
    (#(#f 32)
     (#\370 #\space))
    (#(#f 32)
     (#\371 #\space))
    (#(#f 32)
     (#\372 #\space))
    (#(#f 32)
     (#\373 #\space))
    ;; 5-byte seqs with only 1 continuation
    (#(#f 32)
     (#\370 #\203 #\space))
    (#(#f 32)
     (#\371 #\203 #\space))
    (#(#f 32)
     (#\372 #\203 #\space))
    (#(#f 32)
     (#\373 #\203 #\space))
    ;; 5-byte seqs with only 2 continuations
    (#(#f 32)
     (#\370 #\203 #\203 #\space))
    (#(#f 32)
     (#\371 #\203 #\203 #\space))
    (#(#f 32)
     (#\372 #\203 #\203 #\space))
    (#(#f 32)
     (#\373 #\203 #\203 #\space))
    ;; 5-byte seqs with only 3 continuations
    (#(#f 32)
     (#\370 #\203 #\203 #\203 #\space))
    (#(#f 32)
     (#\371 #\203 #\203 #\203 #\space))
    (#(#f 32)
     (#\372 #\203 #\203 #\203 #\space))
    (#(#f 32)
     (#\373 #\203 #\203 #\203 #\space))
    ;; 6-byte seqs with no continuation
    (#(#f 32)
     (#\374 #\space))
    (#(#f 32)
     (#\375 #\space))
    ;; 6-byte seqs with only 1 continuation
    (#(#f 32)
     (#\374 #\203 #\space))
    (#(#f 32)
     (#\375 #\203 #\space))
    ;; 6-byte seqs with only 2 continuation
    (#(#f 32)
     (#\374 #\203 #\203 #\space))
    (#(#f 32)
     (#\375 #\203 #\203 #\space))
    ;; 6-byte seqs with only 3 continuation
    (#(#f 32)
     (#\374 #\203 #\203 #\203 #\space))
    (#(#f 32)
     (#\375 #\203 #\203 #\203 #\space))
    ;; 6-byte seqs with only 4 continuation
    (#(#f 32)
     (#\374 #\203 #\203 #\203 #\203 #\space))
    (#(#f 32)
     (#\375 #\203 #\203 #\203 #\203 #\space))
    ;; Sequences with last continuation byte missing, eol instead of space
    (#(#f)
     (#\300))
    (#(#f)
     (#\340 #\200))
    (#(#f)
     (#\340))
    (#(#f)
     (#\360 #\200 #\200))
    (#(#f)
     (#\360 #\200))
    (#(#f)
     (#\360 #\200))
    (#(#f)
     (#\370 #\200 #\200 #\200))
    (#(#f)
     (#\370))
    (#(#f)
     (#\370 #\200))
    (#(#f)
     (#\370 #\200 #\200))
    (#(#f)
     (#\374 #\200 #\200 #\200 #\200))
    (#(#f)
     (#\374))
    (#(#f)
     (#\374 #\200))
    (#(#f)
     (#\374 #\200 #\200))
    (#(#f)
     (#\374 #\200 #\200 #\200))
    (#(#f)
     (#\337))
    (#(#f)
     (#\357 #\277))
    (#(#f)
     (#\367 #\277 #\277))
    (#(#f)
     (#\373 #\277 #\277 #\277))
    (#(#f)
     (#\375 #\277 #\277 #\277 #\277))
    ;; Concatenation of incomplete sequences
    (#(#f #f #f #f #f #f #f #f #f #f)
     (#\300 #\340 #\200 #\360 #\200 #\200 #\370 #\200 #\200 #\200 #\374 #\200 #\200 #\200 #\200 #\337 #\357 #\277 #\367 #\277 #\277 #\373 #\277 #\277 #\277 #\375 #\277 #\277 #\277 #\277))
    ;; Impossible bytes
    (#(#f)
     (#\376))
    (#(#f)
     (#\377))
    (#(#f #f #f #f)
     (#\376 #\376 #\377 #\377))
    ;; Overlong
    (#(#f)
     (#\300 #\257))
    (#(#f)
     (#\340 #\200 #\257))
    (#(#f)
     (#\360 #\200 #\200 #\257))
    (#(#f)
     (#\370 #\200 #\200 #\200 #\257))
    (#(#f)
     (#\374 #\200 #\200 #\200 #\200 #\257))
    (#(#f)
     (#\301 #\277))
    (#(#f)
     (#\340 #\237 #\277))
    (#(#f)
     (#\360 #\217 #\277 #\277))
    (#(#f)
     (#\370 #\207 #\277 #\277 #\277))
    (#(#f)
     (#\374 #\203 #\277 #\277 #\277 #\277))
    (#(#f)
     (#\300 #\200))
    (#(#f)
     (#\340 #\200 #\200))
    (#(#f)
     (#\360 #\200 #\200 #\200))
    (#(#f)
     (#\370 #\200 #\200 #\200 #\200))
    (#(#f)
     (#\374 #\200 #\200 #\200 #\200 #\200))
    ;; illedgal surrogates
    (#(#f)
     (#\355 #\240 #\200))
    (#(#f)
     (#\355 #\255 #\277))
    (#(#f)
     (#\355 #\256 #\200))
    (#(#f)
     (#\355 #\257 #\277))
    (#(#f)
     (#\355 #\260 #\200))
    (#(#f)
     (#\355 #\276 #\200))
    (#(#f)
     (#\355 #\277 #\277))
    (#(#f #f)
     (#\355 #\240 #\200 #\355 #\260 #\200))
    (#(#f #f)
     (#\355 #\240 #\200 #\355 #\277 #\277))
    (#(#f #f)
     (#\355 #\255 #\277 #\355 #\260 #\200))
    (#(#f #f)
     (#\355 #\255 #\277 #\355 #\277 #\277))
    (#(#f #f)
     (#\355 #\256 #\200 #\355 #\260 #\200))
    (#(#f #f)
     (#\355 #\256 #\200 #\355 #\277 #\277))
    (#(#f #f)
     (#\355 #\257 #\277 #\355 #\260 #\200))
    (#(#f #f)
     (#\355 #\257 #\277 #\355 #\277 #\277))
    ;; Other illegal code positions
    (#(#f)
     (#\357 #\277 #\276))
    (#(#f)
     (#\357 #\277 #\277))))

(for-each (lambda (p)
	    (let ([code-points (car p)]
		  [s (apply string (cadr p))])
	      (if (and (positive? (vector-length code-points))
		       (vector-ref code-points 0))
		  (begin
		    (test (vector-length code-points) string-unicode-length s)
		    (test code-points string->unicode-vector s)
		    (test code-points string-any->unicode-vector s #f)
		    (test s unicode-vector->string code-points)
		    (test 0 string-unicode-index s 0)
		    (test (string-length s) string-unicode-index 
			  (string-append s "x")
			  (vector-length code-points))
		    (if ((vector-length code-points) . > . 1)
			(begin
			  (let ([post-1 (string-unicode-index s 1)])
			    (test #t positive? post-1)
			    (test (list->vector (cdr (vector->list code-points)))
				  string->unicode-vector s post-1))
			  (let ([last-1 (string-unicode-index s (sub1 (vector-length code-points)))])
			    (test #t positive? last-1)
			    (test code-points
				  list->vector (append
						(vector->list (string->unicode-vector s 0 last-1))
						(vector->list (string->unicode-vector s last-1))))))
			(test #f string-unicode-index s 1)))
		  (begin
		    (test code-points string-any->unicode-vector s #f)
		    (test (list->vector (append '(97) (vector->list code-points) '(98)))
			  string-any->unicode-vector (format "a~ab" s) #f)
		    (test (list->vector (append (vector->list code-points) (vector->list code-points)))
			  string-any->unicode-vector (format "~a~a" s s) #f)
		    (test #f string-unicode-length s)
		    (test 0 string-unicode-index s 0)))
	      (let ([v (string-any->unicode-vector s #f)])
		(let ([p (open-input-string s)])
		  (port-count-lines! p)
		  (read-string 500 p)
		  (let-values ([(l c p) (port-next-location p)])
		    (test (vector-length v) 'c c)
		    (test (add1 (vector-length v)) 'p p)))
		(let ([p (open-input-string (format "\t~a\t" s))])
		  (port-count-lines! p)
		  (read-string 500 p)
		  (let-values ([(l c p) (port-next-location p)])
		    (test p 'p (add1 (+ 2 (vector-length v))))
		    (test c 'tab (+ 16
				    (- (vector-length v)
				       (bitwise-and (vector-length v) 7))))))
		(let ([p (open-input-string (format "~a\t~a" s s))])
		  (port-count-lines! p)
		  (read-string 500 p)
		  (let-values ([(l c p) (port-next-location p)])
		    (test p 'p (add1 (+ 1 (* 2 (vector-length v)))))
		    (test c 'tab (+ 8
				    (- (vector-length v)
				       (bitwise-and (vector-length v) 7))
				    (vector-length v))))))))
	  basic-utf8-tests)

(test '(#\302 #\251) string->list (unicode-vector->string (vector 169)))
(test '(#\304 #\250) string->list (unicode-vector->string (vector 296)))

(test '("\302\251") regexp-match #rx"." "\302\251")
(test '("\302") regexp-match #rxb"." "\302\251")

(test #f regexp-match #rx"[a-z]" "\302\251")
(test '("\302\251") regexp-match #rx"\302\251" "\302\251")
(test '("\302\251") regexp-match #rx"\302\251+" "\302\251")
(test '("\302\251\302\251") regexp-match #rx"\302\251+" "\302\251\302\251")
(test '("\302\251\302\251") regexp-match #rx"\302\251+" "x\302\251\302\251y")
(test '("\302\251") regexp-match #rx"[a-z\302\251]" "\302\251mm")
(test '("\302\251mm") regexp-match #rx"[a-z\302\251]+" "\302\251mm")
(test '("\302\251") regexp-match #rx"[\302\251-\304\250]+" "xx\302\251mm")
(test '("\303\251") regexp-match #rx"[\302\251-\304\250]+" "xx\303\251mm")
(test #f regexp-match #rx"[\302\251-\304\250]+" "xx\304\251mm")
(test #f regexp-match #rx"[\302\251-\304\250]+" "xx\302\250mm")
(test '("\303\251\302\251") regexp-match #rx"[\302\251-\304\250]+" "xx\303\251\302\251mm")

(test #f regexp-match #rx"[^a-z][^a-z]" "\302\251")

;; Nots of patterns and ranges:
(test #f regexp-match #rx"[^a-z\302\251]" "\302\251mm")
(test '("") regexp-match #rx"[^a-d\302\251]*" "\302\251mm")
(test '("xx") regexp-match #rx"[^\302\251-\304\250]+" "xx\302\251mm")
(test '("xx") regexp-match #rx"[^\302\251-\304\250]+" "xx\303\251mm")
(test '("xx\304\251mm") regexp-match #rx"[^\302\251-\304\250]+" "xx\304\251mm")
(test '("xx\302\250mm") regexp-match #rx"[^\302\251-\304\250]+" "xx\302\250mm")
(test '("xx") regexp-match #rx"[^\302\251-\304\250]+" "xx\303\251\302\251mm")

;; 3-char seqs
(test '("\341\275\271") regexp-match #rx"\341\275\271" "a\341\275\271\341\275\271b")
(test '("\341\275\271\341\275\271") regexp-match #rx"\341\275\271+" "a\341\275\271\341\275\271b")

(test '("\341\275\271\302\251\341\275\271r") regexp-match #rx"[c-\341\275\271]+" "a\341\275\271\302\251\341\275\271r")
(test '("d\341\275\271\302\251\341\275\271r") regexp-match #rx"[c-\341\275\271]+" "d\341\275\271\302\251\341\275\271r")

(test '("\342\275\271") regexp-match #rx"[\341\275\271-\343\275\271]" "\342\275\271")
(test '("\341\275\271") regexp-match #rx"[\341\275\271-\343\275\271]" "\341\275\271")
(test #f regexp-match #rx"[\341\275\271-\343\275\271]" "\341\274\271")
(test #f regexp-match #rx"[\341\275\271-\343\275\271]" "\341\275\270")

;; Nots of 3-char seqs:
(test #f regexp-match #rx"[^\341\275\271-\343\275\271]" "\342\275\271")
(test #f regexp-match #rx"[^\341\275\271-\343\275\271]" "\341\275\271")
(test '("\341\274\271") regexp-match #rx"[^\341\275\271-\343\275\271]" "\341\274\271")
(test '("\341\275\270") regexp-match #rx"[^\341\275\271-\343\275\271]" "\341\275\270")


;; Regexps that shouldn't parse:
(err/rt-test (regexp "[a--b\341\275\270]") exn:misc?)
(err/rt-test (regexp "[a-b-c\341\275\270]") exn:misc?)

;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; String comparison. Relies on the default locale knowing
;;  about upper A with hat (\303\202) and lower a with hat (\303\242),
;;  and also relies on a "C" locale that can't encode those
;;  two characters. It doesn't rely on a relative order of A-hat
;;  and a-hat --- only that they're the same case-insensitively.
(let ()
  (define (stest r comp? a b)
    (test r comp? a b)
    (test r comp? (format "xx~ayy" a) (format "xx~ayy" b))
    (test r comp? (format "x\000x~ay" a) (format "x\000x~ay" b))
    (test r comp? (format "x\000~ay" a) (format "x\000~ay" b))
    (test r comp? (format "x\000~a\000y" a) (format "x\000~a\000y" b)))
  (define (go c?)
    (stest #f string=? "A" "a")
    (stest #t string-ci=? "A" "a")
    (stest #t string-unicode-ci=? "A" "a")
    (stest #f string=? "\303\202" "\303\242") 
    (stest #f string-ci=? "\303\202" "\303\242")
    (stest #f string-unicode=? "\303\202" "\303\242")
    (stest (if c? #f #t) string-unicode-ci=? "\303\202" "\303\242")
    (stest #f string<? "\303\242" "b")
    (stest (if c? #f #t) string-unicode<? "\303\242" "b")
    (stest #t string>? "\303\242" "b")
    (stest (if c? #t #f) string-unicode>? "\303\242" "b")
    (stest #t string<? "b" "\303\242")
    (stest (if c? #t #f) string-unicode<? "b" "\303\242")
    (stest #f string>? "b" "\303\242")
    (stest (if c? #f #t) string-unicode>? "b" "\303\242")
    (test "ABC" string-unicode-upcase "aBc")
    (test (if c? "\303\242" "\303\202") string-unicode-upcase "\303\242")
    (test (if c? "A\303\242\0B" "A\303\202\0B") string-unicode-upcase "a\303\242\0b")
    (test (if c? "A\303\242\0\303\242\0B" "A\303\202\0\303\202\0B") string-unicode-upcase "a\303\242\0\303\242\0b"))
  (go #f)
  (parameterize ([current-locale "C"])
    (go #t)))

;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  locale<->unicode conversions

;; Relies on a default locale that extends Latin-1:
(let-values ([(s l ok?) (string-unicode->locale "abc")])
  (test 3 'count l)
  (test #t 'ok ok?))
(let-values ([(s l ok?) (string-unicode->locale "a\300\300")])
  (test 1 'count l)
  (test #f 'ok ok?))
(let-values ([(s l ok?) (string-unicode->locale "a\302\200")])
  (test 3 'count l)
  (test #t 'ok ok?))
(test-values '("abcd" 4 #t) (lambda () (string-locale->unicode "abcd")))
(test-values '("bcd" 3 #t) (lambda () (string-locale->unicode "abcd" 1)))
(test-values '("bc" 2 #t) (lambda () (string-locale->unicode "abcd" 1 3)))
(test-values '("a" 1 #f) (lambda () (string-locale->unicode "a\302\200" 0 2)))
(test-values '(2 2 #t) (lambda () (string-locale->unicode "abcd" 1 3 (make-string 2))))
(let ([s (make-string 10)])
  (test-values '(2 2 #t) (lambda () (string-locale->unicode "abcd" 1 3 s 4 7)))
  (test #\b string-ref s 4)
  (test #\c string-ref s 5))
(let ([s (make-string 10)])
  (test-values '(1 1 #t) (lambda () (string-locale->unicode "abcd" 1 3 s 4 5)))
  (test #\b string-ref s 4))
;; The rest relies on the "C" locale:
(parameterize ([current-locale "C"])
  (test-values '("abc" 3 #t) (lambda () (string-unicode->locale "abc")))
  (test-values '("a" 1 #f) (lambda () (string-unicode->locale "a\300\300")))
  (test-values '("ab" 2 #f) (lambda () (string-unicode->locale "ab\303")))
  ;; Well-formed, but can't be converted to "C":
  (test-values '("a" 1 #f) (lambda () (string-unicode->locale "a\303\342"))))

(err/rt-test (string-unicode->locale 'ok))
(err/rt-test (string-unicode->locale "ok" -1))
(err/rt-test (string-unicode->locale "ok" 3) exn:application:mismatch?)
(err/rt-test (string-unicode->locale "ok" 1 0) exn:application:mismatch?)
(err/rt-test (string-unicode->locale "ok" 1 3) exn:application:mismatch?)
(err/rt-test (string-unicode->locale "ok" 1 2 'nope))
(err/rt-test (string-unicode->locale "ok" 1 2 "nope"))
(let ([s (make-string 4)])
  (err/rt-test (string-unicode->locale "ok" 1 3 s -1) exn:application:mismatch?)
  (err/rt-test (string-unicode->locale "ok" 1 3 s 5) exn:application:mismatch?)
  (err/rt-test (string-unicode->locale "ok" 1 3 s 2 1) exn:application:mismatch?)
  (err/rt-test (string-unicode->locale "ok" 1 3 s 2 7) exn:application:mismatch?))

(report-errs)
