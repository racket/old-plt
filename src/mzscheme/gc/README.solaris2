The collector supports both incremental collection and threads under
Solaris 2.  The incremental collector normally retrieves page dirty information
through the appropriate /proc calls.  But it can also be configured
(by defining MPROTECT_VDB instead of PROC_VDB in config.h) to use mprotect
and signals.  This may result in shorter pause times, but it is no longer
safe to issue arbitrary system calls that write to the heap.

The collector normally obtains memory through sbrk.  There is some reason
to expect that this is not safe if the client program also calls the system
malloc, or especially realloc.  The sbrk man page strongly suggests this is
not safe: "Many library routines use malloc() internally, so use brk()
and sbrk() only when you know  that malloc() definitely will not be used by
any library routine."  This doesn't make a lot of sense to me, since there
seems to be no documentation as to which routines can transitively call malloc.
Furthermore there typically isn't much of a performance advantage to be
gained from such a restriction.

To complicate matters, empirically this approach seems to work, at least
most of the time.  There have been reports of crashes in Sun's realloc
function.  But I haven't been able to reproduce this on an example small
enough to preclude other bugs.

As it stands, you have 4 choices:

1. Use the collector as is, possibly avoiding the system realloc function.
If you get a simple program that does this to crash, send me a copy, and
I'll change the default to do something else.  Please also complain to Sun,
if you find such a case.

2. Build the collector with -DREDIRECT_MALLOC=GC_malloc_uncollectable, thus
redirecting system allocation calls through the collector.  I believe
this is OK under Solaris, but there is some risk of infinite recursion if
you turn on collector log messages.

3. Change the GET_MEM definition for SPARC and SUNOS5 in gc_priv.h to
be the same as for the AMIGA or NEXT.  The collector will then obtain
memory through the system calloc function.  This is probably the safest,
but it incurs a fragmentation penalty.  Since the system malloc is likely
to reserve header space in each object, the different heap sections
are virtually guaranteed to not be adjacent.  Thus large objects have to fit
entirely in one section.

4. Change GET_MEM to allocate memory from a different part of the address
space, e.g. with mmap.  Based on previous experiences with older versions
of SunOS and other operating systems, this risks other performance problems.
I have not tried it with Solaris 2.

SOLARIS THREADS:

The collector must be compiled with -DSOLARIS_THREADS to be thread safe.
It is also essential that gc.h be included in files that call thr_create,
thr_join, thr_suspend, thr_continue, or dlopen.  Gc.h macro defines
these to also do GC bookkeeping, etc.  Gc.h must be included with SOLARIS_THREADS
defined, otherwise these replacements are not visible.

In this mode, the collector contains various workarounds for older Solaris
bugs.  Mostly, these should not be noticeable unless you look at system
call traces.  However, it cannot protect a guard page at the end of
a thread stack.  If you know that you will only be running Solaris2.5
or later, it should be possible to fix this by compiling the collector
with -DSOLARIS23_MPROTECT_BUG_FIXED.

Jeremy Fitzhardinge points out that there is a problem with the dlopen
replacement, in that startup code in the library is run while the allocation
lock is held.  This appears to be difficult to fix, since the collector does
look at data structures maintained by dlopen, and hence some locking is needed
around the dlopen call.

Hans-J. Boehm
(The above contains my personal opinions, which are probably not shared
by anyone else.)
