This is lightning.info, produced by makeinfo version 4.5 from
lightning.texi.

INFO-DIR-SECTION GNU lightning, a library for dynamic code generation
START-INFO-DIR-ENTRY
* Using and porting GNU lightning: (lightning).
END-INFO-DIR-ENTRY

   This file documents GNU lightning, Version 1.2a.  It was last
updated on 15 March 2004.

   Copyright (C) 2000 Free Software Foundation, Inc.  Authored by Paolo
Bonzini.

   This document is released under the terms of the GNU Free
Documentation License as published by the Free Software Foundation;
either version 1.1, or (at your option) any later version.

   You should have received a copy of the GNU Free Documentation
License along with GNU lightning; see the file `COPYING.DOC'.  If not,
write to the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.

   There are no Secondary Sections, no Cover Texts and no Invariant
Sections (as defined in the license); this text, along with its
equivalent in the printed manual, constitutes the Title Page.


File: lightning.info,  Node: Top,  Up: (dir)

GNU lightning
*************

   This document describes installing, using and porting the GNU
lightning library for dynamic code generation.  Unlike other dynamic
code generation systems, which are usually either inefficient or
non-portable, GNU lightning is both retargetable and very fast.

* Menu:



* Overview::              What GNU lightning is.
* Using GNU lightning::   Using GNU lightning in your programs
* Porting GNU lightning:: Retargeting GNU lightning to a new system
* Future::                Tasks for GNU lightning's subsequent releases
* Acknowledgements::      Acknowledgements for GNU lightning

--- The detailed node listing ---

Using GNU lightning:

* Installation::          Configuring and installing GNU lightning
* The instruction set::   The RISC instruction set used i GNU lightning
* GNU lightning macros::  GNU lightning's macros
* Reentrancy::            Re-entrant usage of GNU lightning
* Autoconf support::      Using `autoconf' with GNU lightning


Porting GNU lightning:

* Structure of a port::   An overview of the porting process
* Adjusting configure::   Automatically recognizing the new platform
* Run-time assemblers::   An internal layer to simplify porting
* Standard macros::       The platform-independent layer used by clients.
* Standard functions::    Doing more complex tasks.
* Floating-point macros:: Implementing macros for floating point.


Standard macros:
* Forward references::    Implementing forward references
* Common features::       Common features supported by `core-common.h'
* Delay slots::           Supporting scheduling of delay slots
* Immediate values::      Supporting arbitrarily sized immediate values
* Implementing the ABI::  Function prologs and epilogs, and argument passing
* Macro list::            Macros composing the platform-independent layer


File: lightning.info,  Node: Overview,  Next: Using GNU lightning,  Prev: Top,  Up: Top

Introduction to GNU lightning
*****************************

   Dynamic code generation is the generation of machine code at
runtime. It is typically used to strip a layer of interpretation by
allowing compilation to occur at runtime.  One of the most well-known
applications of dynamic code generation is perhaps that of interpreters
that compile source code to an intermediate bytecode form, which is
then recompiled to machine code at run-time: this approach effectively
combines the portability of bytecode representations with the speed of
machine code.  Another common application of dynamic code generation is
in the field of hardware simulators and binary emulators, which can use
the same techniques to translate simulated instructions to the
instructions of the underlying machine.

   Yet other applications come to mind: for example, windowing "bitblt"
operations, matrix manipulations, and network packet filters.  Albeit
very powerful and relatively well known within the compiler community,
dynamic code generation techniques are rarely exploited to their full
potential and, with the exception of the two applications described
above, have remained curiosities because of their portability and
functionality barriers: binary instructions are generated, so programs
using dynamic code generation must be retargeted for each machine; in
addition, coding a run-time code generator is a tedious and error-prone
task more than a difficult one.

   This manual describes the GNU lightning dynamic code generation
library.  GNU lightning provides a portable, fast and easily
retargetable dynamic code generation system.

   To be fast, GNU lightning emits machine code without first creating
intermediate data structures such as RTL representations traditionally
used by optimizing compilers (*note RTL representation: (gcc)RTL
representation.).  GNU lightning translates code directly from a
machine independent interface to that of the underlying architecture.
This makes code generation more efficient, since no intermediate data
structures have to be constructed and consumed.  A collateral benefit
it that GNU lightning consumes little space: other than the memory
needed to store generated instructions and data structures such as
parse trees, the only data structure that client will usually need is
an array of pointers to labels and unresolved jumps, which you can
often allocate directly on the system stack.

   To be portable, GNU lightning abstracts over current architectures'
quirks and unorthogonalities.  The interface that it exposes to is that
of a standardized RISC architecture loosely based on the SPARC and MIPS
chips.  There are a few general-purpose registers (six, not including
those used to receive and pass parameters between subroutines), and
arithmetic operations involve three operands--either three registers or
two registers and an arbitrarily sized immediate value.

   On one hand, this architecture is general enough that it is possible
to generate pretty efficient code even on CISC architectures such as the
Intel x86 or the Motorola 68k families.  On the other hand, it matches
real architectures closely enough that, most of the time, the
compiler's constant folding pass ends up generating code which
assembles machine instructions without further tests.

Drawbacks
=========

   GNU lightning has been useful in practice; however, it does have at
least four drawbacks: it has limited registers, no peephole optimizer,
no instruction scheduler and no symbolic debugger. Of these, the last
is the most critical even though it does not affect the quality of
generated code: the only way to debug code generated at run-time  is to
step through it at the level of host specific machine code.  A decent
knowledge of the underlying instruction set is thus needed to make
sense of the debugger's output.

   The low number of available registers (six) is also an important
limitation.  However, let's take the primary application of dynamic
code generation, that is, bytecode translators.  The underlying virtual
machines tend to have very few general purpose registers (usually 0 to
2) and the translators seldom rely on sophisticated graph-coloring
algorithms to allocate registers to temporary variables.  Rather, these
translators usually obtain performance increases because: a) they
remove indirect jumps, which are usually poorly predicted, and thus
often form a bottleneck, b) they parameterize the generated code and go
through the process of decoding the bytecodes just once.  So, their
usage of registers is rather sparse--in fact, in practice, six
registers were found to be enough for most purposes.

   The lack of a peephole optimizer is most important on machines where
a single instruction can map to multiple native instructions.  For
instance, Intel chips' division instruction hard-codes the dividend to
be in EAX and the quotient and remainder to be output, respectively, in
EAX and EDX: on such chips, GNU lightning does lots of pushing and
popping of EAX and EDX to save those registers that are not used.
Unnecessary stack operations could be removed by looking at whether
preserved registers are destroyed soon.  Unfortunately, the current
implementation of GNU lightning is so fast because it only knows about
the single instruction that is being generated; performing these
optimizations would require a flow analysis pass that would probably
hinder GNU lightning's speed.

   The lack of an instruction scheduler is not very important--pretty
good instruction scheduling can actually be obtained by separating
register writes from register reads.  The only architectures on which a
scheduler would be useful are those on which arithmetic instructions
have two operands; an example is, again, the x86, on which the single
instruction
         subr_i  R0, R1, R2       !Compute R0 = R1 - R2

is translated to two instruction, of which the second depends on the
result of the first:
         movl    %ebx, %eax       ! Move R1 into R0
         subl    %edx, %eax       ! Subtract R2 from R0


File: lightning.info,  Node: Using GNU lightning,  Next: Porting GNU lightning,  Prev: Overview,  Up: Top

Using GNU lightning
*******************

   This chapter describes installing and using GNU lightning.

* Menu:


* Installation::          Configuring and installing GNU lightning
* The instruction set::   The RISC instruction set used i GNU lightning
* GNU lightning macros::  GNU lightning's macros
* Reentrancy::            Re-entrant usage of GNU lightning
* Autoconf support::      Using `autoconf' with GNU lightning


File: lightning.info,  Node: Installation,  Next: The instruction set,  Up: Using GNU lightning

Configuring and installing GNU lightning
========================================

   The first thing to do to use GNU lightning is to configure the
program, picking the set of macros to be used on the host architecture;
this configuration is automatically performed by the `configure' shell
script; to run it, merely type:
          ./configure

   GNU lightning supports cross-compiling in that you can choose a
different set of macros from the one needed on the computer that you
are compiling GNU lightning on.  For example,
          ./configure --host=sparc-sun-linux

will select the SPARC set of runtime assemblers.  You can use
configure's ability to make reasonable assumptions about the vendor and
operating system and simply type
          ./configure --host=i386
          ./configure --host=ppc
          ./configure --host=sparc

   Another option that `configure' accepts is `--enable-assertions',
which enables several consistency checks in the run-time assemblers.
These are not usually needed, so you can decide to simply forget about
it; also remember that these consistency checks tend to slow down your
code generator.

   After you've configured GNU lightning, you don't have to compile it
because it is nothing more than a set of include files.  If you want to
compile the examples, run `make' as usual.  The next important step is:
         make install

   This ends the process of installing GNU lightning.


File: lightning.info,  Node: The instruction set,  Next: GNU lightning macros,  Prev: Installation,  Up: Using GNU lightning

GNU lightning's instruction set
===============================

   GNU lightning's instruction set was designed by deriving instructions
that closely match those of most existing RISC architectures, or that
can be easily syntesized if absent.  Each instruction is composed of:
   * an operation, like `sub' or `mul'

   * sometimes, an register/immediate flag (`r' or `i')

   * a type identifier or, occasionally, two

   The second and third field are separated by an underscore; thus,
examples of legal mnemonics are `addr_i' (integer add, with three
register operands) and `muli_l' (long integer multiply, with two
register operands and an immediate operand).  Each instruction takes
two or three operands; in most cases, one of them can be an immediate
value instead of a register.

   GNU lightning supports a full range of integer types: operands can
be 1, 2 or 4 bytes long (64-bit architectures might support 8 bytes long
operands), either signed or unsigned.  The types are listed in the
following table together with the C types they represent:

          c          signed char
          uc         unsigned char
          s          short
          us         unsigned short
          i          int
          ui         unsigned int
          l          long
          ul         unsigned long
          f          float
          d          double
          p          void *

   Some of these types may not be distinct: for example, (e.g., `l' is
equivalent to `i' on 32-bit machines, and `p' is substantially
equivalent to `ul').

   There are at least seven integer registers, of which six are
general-purpose, while the last is used to contain the stack pointer
(`SP').  The stack pointer can be used to allocate and access local
variables on the stack (which is supposed to grow downwards in memory
on all architectures).

   Of the general-purpose registers, at least three are guaranteed to be
preserved across function calls (`V0', `V1' and `V2') and at least
three are not (`R0', `R1' and `R2').  Six registers are not very much,
but this restriction was forced by the need to target CISC architectures
which, like the x86, are poor of registers; anyway, backends can
specify the actual number of available caller- and callee-save
registers.

   In addition, there is a special `RET' register which contains the
return value.  You should always remember, however, that writing this
register could overwrite either a general-purpose register or an
incoming parameter, depending on the architecture.

   There are at least six floating-point registers, named `FPR0' to
`FPR5'.  These are separate from the integer registers on all the
supported architectures; on Intel architectures, the register stack is
mapped to a flat register file.

   The complete instruction set follows; as you can see, most non-memory
operations only take integers, long integers (either signed or
unsigned) and pointers as operands; this was done in order to reduce
the instruction set, and because most architectures only provide word
and long word operations on registers.  There are instructions that
allow operands to be extended to fit a larger data type, both in a
signed and in an unsigned way.

Binary ALU operations
     These accept three operands; the last one can be an immediate
     value for integer operands, or a register for all operand types.
     `addx' operations must directly follow `addc', and `subx' must
     follow `subc'; otherwise, results are undefined.
          addr     i  ui  l  ul  p  f  d  O1 = O2 + O3
          addi     i  ui  l  ul  p        O1 = O2 + O3
          addxr    i  ui  l  ul           O1 = O2 + (O3 + carry)
          addxi    i  ui  l  ul           O1 = O2 + (O3 + carry)
          addcr    i  ui  l  ul           O1 = O2 + O3, set carry
          addci    i  ui  l  ul           O1 = O2 + O3, set carry
          subr     i  ui  l  ul  p  f  d  O1 = O2 - O3
          subi     i  ui  l  ul  p        O1 = O2 - O3
          subxr    i  ui  l  ul           O1 = O2 - (O3 + carry)
          subxi    i  ui  l  ul           O1 = O2 - (O3 + carry)
          subcr    i  ui  l  ul           O1 = O2 - O3, set carry
          subci    i  ui  l  ul           O1 = O2 - O3, set carry
          rsbr     i  ui  l  ul  p  f  d  O1 = O3 - O2
          rsbi     i  ui  l  ul  p        O1 = O3 - O2
          mulr     i  ui  l  ul     f  d  O1 = O2 * O3
          muli     i  ui  l  ul           O1 = O2 * O3
          hmulr    i  ui  l  ul           O1 = high bits of O2 * O3
          hmuli    i  ui  l  ul           O1 = high bits of O2 * O3
          divr     i  ui  l  ul     f  d  O1 = O2 / O3
          divi     i  ui  l  ul           O1 = O2 / O3
          modr     i  ui  l  ul           O1 = O2 % O3
          modi     i  ui  l  ul           O1 = O2 % O3
          andr     i  ui  l  ul           O1 = O2 & O3
          andi     i  ui  l  ul           O1 = O2 & O3
          orr      i  ui  l  ul           O1 = O2 | O3
          ori      i  ui  l  ul           O1 = O2 | O3
          xorr     i  ui  l  ul           O1 = O2 ^ O3
          xori     i  ui  l  ul           O1 = O2 ^ O3
          lshr     i  ui  l  ul           O1 = O2 << O3
          lshi     i  ui  l  ul           O1 = O2 << O3
          rshr     i  ui  l  ul           O1 = O2 >> O3(1)
          rshi     i  ui  l  ul           O1 = O2 >> O3(2)

Unary ALU operations
     These accept two operands, both of which must be registers.
          negr     i     l         f  d  O1 = -O2
          notr     i  ui l  ul           O1 = ~O2

Compare instructions
     These accept three operands; again, the last can be an immediate
     value for integer data types.  The last two operands are compared,
     and the first operand is set to either 0 or 1, according to
     whether the given condition was met or not.

     The conditions given below are for the standard behavior of C,
     where the "unordered" comparison result is mapped to false.

          ltr      i  ui  l  ul  p  f  d  O1 = (O2 <  O3)
          lti      i  ui  l  ul  p        O1 = (O2 <  O3)
          ler      i  ui  l  ul  p  f  d  O1 = (O2 <= O3)
          lei      i  ui  l  ul  p        O1 = (O2 <= O3)
          gtr      i  ui  l  ul  p  f  d  O1 = (O2 >  O3)
          gti      i  ui  l  ul  p        O1 = (O2 >  O3)
          ger      i  ui  l  ul  p  f  d  O1 = (O2 >= O3)
          gei      i  ui  l  ul  p        O1 = (O2 >= O3)
          eqr      i  ui  l  ul  p  f  d  O1 = (O2 == O3)
          eqi      i  ui  l  ul  p        O1 = (O2 == O3)
          ner      i  ui  l  ul  p  f  d  O1 = (O2 != O3)
          nei      i  ui  l  ul  p        O1 = (O2 != O3)
          unltr                     f  d  O1 = !(O2 >= O3)
          unler                     f  d  O1 = !(O2 >  O3)
          ungtr                     f  d  O1 = !(O2 <= O3)
          unger                     f  d  O1 = !(O2 <  O3)
          uneqr                     f  d  O1 = !(O2 <  O3) && !(O2 >  O3)
          ltgtr                     f  d  O1 = !(O2 >= O3) || !(O2 <= O3)
          ordr                      f  d  O1 =  (O2 == O2) &&  (O3 == O3)
          unordr                    f  d  O1 =  (O2 != O2) ||  (O3 != O3)

Transfer operations
     These accept two operands; for `ext' both of them must be
     registers, while `mov' accepts an immediate value as the second
     operand.

     Unlike `movr' and `movi', the other instructions are applied
     between operands of different data types, and they need *two* data
     type specifications.  You can use `extr' to convert between
     integer data types, in which case the first must be smaller in size
     than the second; for example `extr_c_ui' is correct while
     `extr_ul_us' is not.  You can also use `extr' to convert an
     integer to a floating point value: the only available possibilities
     are `extr_i_f' and `extr_i_d'.  The other instructions convert a
     floating point value to an integer, so the possible suffixes are
     `_f_i' and `_d_i'.

          movr                      i  ui  l  ul  p  f  d  O1 = O2
          movi                      i  ui  l  ul  p  f  d  O1 = O2
          extr        c  uc  s  us  i  ui  l  ul     f  d  O1 = O2
          roundr                    i                f  d  O1 = round(O2)
          truncr                    i                f  d  O1 = trunc(O2)
          floorr                    i                f  d  O1 = floor(O2)
          ceilr                     i                f  d  O1 = ceil(O2)

     Note that the order of the arguments is _destination first, source
     second_ as for all other GNU lightning instructions, but the order
     of the types is always reversed with respect to that of the
     arguments: _shorter_--source--_first,
     longer_--destination--_second_.  This happens for historical
     reasons.

Network extensions
     These accept two operands, both of which must be registers; these
     two instructions actually perform the same task, yet they are
     assigned to two mnemonics for the sake of convenience and
     completeness.  As usual, the first operand is the destination and
     the second is the source.
          hton       us ui          Host-to-network (big endian) order
          ntoh       us ui          Network-to-host order

Load operations
     `ld' accepts two operands while `ldx' accepts three; in both
     cases, the last can be either a register or an immediate value.
     Values are extended (with or without sign, according to the data
     type specification) to fit a whole register.
          ldr     c  uc  s  us  i  ui  l  ul  p  f  d  O1 = *O2
          ldi     c  uc  s  us  i  ui  l  ul  p  f  d  O1 = *O2
          ldxr    c  uc  s  us  i  ui  l  ul  p  f  d  O1 = *(O2+O3)
          ldxi    c  uc  s  us  i  ui  l  ul  p  f  d  O1 = *(O2+O3)

Store operations
     `st' accepts two operands while `stx' accepts three; in both
     cases, the first can be either a register or an immediate value.
     Values are sign-extended to fit a whole register.
          str     c  uc  s  us  i  ui  l  ul  p  f  d  *O1 = O2
          sti     c  uc  s  us  i  ui  l  ul  p  f  d  *O1 = O2
          stxr    c  uc  s  us  i  ui  l  ul  p  f  d  *(O1+O2) = O3
          stxi    c  uc  s  us  i  ui  l  ul  p  f  d  *(O1+O2) = O3

Stack management
     These accept a single register parameter.  These operations are not
     guaranteed to be efficient on all architectures.

          pushr                     i  ui  l  ul  p   push O1 on the stack
          popr                      i  ui  l  ul  p   pop O1 off the stack

Argument management
     These are:
          prepare                   i                f  d
          pusharg     c  uc  s  us  i  ui  l  ul  p  f  d
          getarg      c  uc  s  us  i  ui  l  ul  p  f  d
          arg         c  uc  s  us  i  ui  l  ul  p  f  d

     Of these, the first two are used by the caller, while the last two
     are used by the callee.  A code snippet that wants to call another
     procedure and has to pass registers must, in order: use the
     `prepare' instruction, giving the number of arguments to be passed
     to the procedure (once for each data type); use `pusharg' to push
     the arguments *in reverse order*; and use `calli' or `finish'
     (explained below) to perform the actual call.

     `arg' and `getarg' are used by the callee.  `arg' is different
     from other instruction in that it does not actually generate any
     code: instead, it is a function which returns a value to be passed
     to `getarg'.(3) You should call `arg' as soon as possible, before
     any function call or, more easily, right after the `prolog' or
     `leaf' instructions (which are treated later).

     `getarg' accepts a register argument and a value returned by
     `arg', and will move that argument to the register, extending it
     (with or without sign, according to the data type specification)
     to fit a whole register.  These instructions are more intimately
     related to the usage of the GNU lightning instruction set in code
     that generates other code, so they will be treated more
     specifically in *Note Generating code at run-time: GNU lightning
     macros.

     You should observe a few rules when using these macros.  First of
     all, it is not allowed to call functions with more than six
     arguments; this was done to simplify and speed up the
     implementation on architectures that use registers for parameter
     passing.

     You should not nest calls to `prepare', nor call zero-argument
     functions (which do not need a call to `prepare') inside a
     `prepare/calli' or `prepare/finish' block.  Doing this might
     corrupt already pushed arguments.

     You *cannot* pass parameters between subroutines using the six
     general-purpose registers.  This might work only when targeting
     particular architectures.

     On the other hand, it is possible to assume that callee-saved
     registers (`R0' through `R2') are not clobbered by another
     dynamically generated function which does not use them as operands
     in its code and which does not return a value.

Branch instructions
     Like `arg', these also return a value which, in this case, is to
     be used to compile forward branches as explained in *Note
     Fibonacci numbers: Fibonacci.  They accept a pointer to the
     destination of the branch and two operands to be compared; of
     these, the last can be either a register or an immediate.  They
     are:
          bltr      i  ui  l  ul  p  f  d  if (O2 <  O3) goto O1
          blti      i  ui  l  ul  p        if (O2 <  O3) goto O1
          bler      i  ui  l  ul  p  f  d  if (O2 <= O3) goto O1
          blei      i  ui  l  ul  p        if (O2 <= O3) goto O1
          bgtr      i  ui  l  ul  p  f  d  if (O2 >  O3) goto O1
          bgti      i  ui  l  ul  p        if (O2 >  O3) goto O1
          bger      i  ui  l  ul  p  f  d  if (O2 >= O3) goto O1
          bgei      i  ui  l  ul  p        if (O2 >= O3) goto O1
          beqr      i  ui  l  ul  p  f  d  if (O2 == O3) goto O1
          beqi      i  ui  l  ul  p        if (O2 == O3) goto O1
          bner      i  ui  l  ul  p  f  d  if (O2 != O3) goto O1
          bnei      i  ui  l  ul  p        if (O2 != O3) goto O1
          
          bunltr                     f  d  if !(O2 >= O3) goto O1
          bunler                     f  d  if !(O2 >  O3) goto O1
          bungtr                     f  d  if !(O2 <= O3) goto O1
          bunger                     f  d  if !(O2 <  O3) goto O1
          buneqr                     f  d  if !(O2 <  O3) && !(O2 >  O3) goto O1
          bltgtr                     f  d  if !(O2 >= O3) || !(O2 <= O3) goto O1
          bordr                      f  d  if  (O2 == O2) &&  (O3 == O3) goto O1
          bunordr                    f  d  if !(O2 != O2) ||  (O3 != O3) goto O1
          
          bmsr      i ui l  ul             if O2 &  O3 goto O1
          bmsi      i ui l  ul             if O2 &  O3 goto O1
          bmcr      i ui l  ul             if !(O2 & O3) goto O1
          bmci      i ui l  ul             if !(O2 & O3) goto O1(4)
          boaddr    i ui l  ul             O2 += O3, goto O1 on overflow
          boaddi    i ui l  ul             O2 += O3, goto O1 on overflow
          bosubr    i ui l  ul             O2 -= O3, goto O1 on overflow
          bosubi    i ui l  ul             O2 -= O3, goto O1 on overflow

Jump and return operations
     These accept one argument except `ret' which has none; the
     difference between `finish' and `calli' is that the latter does
     not clean the stack from pushed parameters (if any) and the former
     must *always* follow a `prepare' instruction.  Results are
     undefined when using function calls in a leaf function.
          calli     (not specified)                  function call to O1
          callr     (not specified)                  function call to a register
          finish    (not specified)                  function call to O1
          finishr   (not specified)                  function call to a register
          jmpi/jmpr (not specified)                  unconditional jump to O1
          prolog    (not specified)                  function prolog for O1 args
          leaf      (not specified)                  the same for leaf functions
          ret       (not specified)                  return from subroutine
          retval    c  uc s  us i  ui l  ul p  f  d  move return value
                                                     to register

     Like branch instruction, `jmpi' also returns a value which is to
     be used to compile forward branches. *Note Fibonacci numbers:
     Fibonacci.


   As a small appetizer, here is a small function that adds 1 to the
input parameter (an `int').  I'm using an assembly-like syntax here
which is a bit different from the one used when writing real
subroutines with GNU lightning; the real syntax will be introduced in
*Note Generating code at run-time: GNU lightning macros.

     incr:
          leaf      1
     in = arg_i                   ! We have an integer argument
          getarg_i  R0, in        ! Move it to R0
          addi_i    RET, R0, 1    ! Add 1, put result in return value
          ret                     ! And return the result

   And here is another function which uses the `printf' function from
the standard C library to write a number in hexadecimal notation:

     printhex:
          prolog    1
     in = arg_i                    ! Same as above
          getarg_i  R0, in
          prepare   2              ! Begin call sequence for printf
          pusharg_i R0             ! Push second argument
          pusharg_p "%x"           ! Push format string
          finish    printf         ! Call printf
          ret                      ! Return to caller

   ---------- Footnotes ----------

   (1) The sign bit is propagated for signed types.

   (2) The sign bit is propagated for signed types.

   (3) "Return a value" means that GNU lightning macros that compile
these instructions return a value when expanded.

   (4) These mnemonics mean, respectively, "branch if mask set" and
"branch if mask cleared".


File: lightning.info,  Node: GNU lightning macros,  Next: Reentrancy,  Prev: The instruction set,  Up: Using GNU lightning

Generating code at run-time
===========================

   To use GNU lightning, you should include the `lightning.h' file that
is put in your include directory by the `make install' command.  That
include files defines about four hundred public macros (plus others
that are private to GNU lightning), one for each opcode listed above.

   Each of the instructions above translates to a macro.  All you have
to do is prepend `jit_' (lowercase) to opcode names and `JIT_'
(uppercase) to register names.  Of course, parameters are to be put
between parentheses, just like with every other CPP macro.

   This small tutorial presents three examples:

* Menu:

* incr::             A function which increments a number by one
* printf::           A simple function call to printf
* RPN calculator::   A more complex example, an RPN calculator
* Fibonacci::        Calculating Fibonacci numbers


File: lightning.info,  Node: incr,  Next: printf,  Up: GNU lightning macros

A function which increments a number by one
-------------------------------------------

   Let's see how to create and use the sample `incr' function created
in *Note GNU lightning's instruction set: The instruction set:

     #include <stdio.h>
     #include "lightning.h"
     
     static jit_insn codeBuffer[1024];
     
     typedef int (*pifi)(int);    /* Pointer to Int Function of Int */
     
     int main()
     {
       pifi  incr = (pifi) (jit_set_ip(codeBuffer).iptr);
       int   in;
     
       jit_leaf(1);                     /*      leaf  1             */
       in = jit_arg_i();                /* in = arg_i               */
       jit_getarg_i(JIT_R0, in);        /*      getarg_i R0         */
       jit_addi_i(JIT_RET, JIT_R0, 1);  /*      addi_i   RET, R0, 1 */
       jit_ret();                       /*      ret                 */
     
       jit_flush_code(codeBuffer, jit_get_ip().ptr);
     
       /* call the generated code, passing 5 as an argument */
       printf("%d + 1 = %d\n", 5, incr(5));
       return 0;
     }

   Let's examine the code line by line (well, almost...):

#include "lightning.h"
     You already know about this.  It defines all of GNU lightning's
     macros.

static jit_insn codeBuffer[1024];
     You might wonder about what is `jit_insn'.  It is just a type that
     is defined by GNU lightning.  Its exact definition depends on the
     architecture; in general, defining an array of 1024 `jit_insn's
     allows one to write 100 to 400 GNU lightning instructions
     (depending on the architecture and exact instructions).

typedef int (*pifi)(int);
     Just a handy typedef for a pointer to a function that takes an
     `int' and returns another.

pifi incr = (pifi) (jit_set_ip(codeBuffer).iptr);
     This is the first GNU lightning macro we encounter that does not
     map to an instruction.  It is `jit_set_ip', which takes a pointer
     to an area of memory where compiled code will be put and returns
     the same value, cast to a `union' type whose members are pointers
     to functions returning different C types.  This union is called
     `jit_code' and is defined as follows:

              typedef union jit_code {
                char               *ptr;
                void               (*vptr)();
                char               (*cptr)();
                unsigned char      (*ucptr)();
                short              (*sptr)();
                unsigned short     (*usptr)();
                int                (*iptr)();
                unsigned int       (*uiptr)();
                long               (*lptr)();
                unsigned long      (*ulptr)();
                void *             (*pptr)();
                float              (*fptr)();
                double             (*dptr)();
              } jit_code;

     Any of the members could have been used, since the result is soon
     casted to type `pifi' but, for the sake of clarity, the program
     uses `iptr', a pointer to a function with no prototype and
     returning an `int'.

     Analogous to `jit_set_ip' is `jit_get_ip', which does not modify
     the instruction pointer--it is nothing more than a cast of the
     current IP to `jit_code'.

int       in;
     A footnote in *Note GNU lightning's instruction set: The
     instruction set, under the description of `arg', says that macros
     implementing `arg' return a value--we'll be using this variable to
     store the result of `arg'.

jit_leaf(1);
     Ok, so we start generating code for our beloved function... it will
     accept one argument and won't call any other function.

in = jit_arg_i();
jit_getarg_i(JIT_R0, in);
     We retrieve the first (and only) argument, an integer, and store it
     into the general-purpose register `R0'.

jit_addi_i(JIT_RET, JIT_R0, 1);
     We add one to the content of the register and store the result in
     the return value.

jit_ret();
     This instruction generates a standard function epilog that returns
     the contents of the `RET' register.

jit_flush_code(codeBuffer, jit_get_ip().ptr);
     This instruction is very important.  It flushes the generated code
     area out of the processor's instruction cache, avoiding the
     processor executes bogus data that it happens to find there.  The
     `jit_flush_code' function accepts the first and the last address
     to flush; we use `jit_get_ip' to find out the latter.

printf("%d + 1 = %d", 5, incr(5));
     Calling our function is this simple--it is not distinguishable from
     a normal C function call, the only difference being that `incr' is
     a variable.

   GNU lightning abstracts two phases of dynamic code generation:
selecting instructions that map the standard representation, and
emitting binary code for these instructions.  The client program has
the responsibility of describing the code to be generated using the
standard GNU lightning instruction set.

   Let's examine the code generated for `incr' on the SPARC and x86
architectures (on the right is the code that an assembly-language
programmer would write):

SPARC
              save %sp, -96, %sp
              mov  %i0, %l0                   retl
              add  %l0, 1,  %i0               add %o0, 1, %o0
              ret
              restore
     In this case, GNU lightning introduces overhead to create a
     register window (not knowing that the procedure is a leaf
     procedure) and to move the argument to the general purpose
     register `R0' (which maps to `%l0' on the SPARC).  The former
     overhead could be avoided by teaching GNU lightning about leaf
     procedures (*note Future::); the latter could instead be avoided
     by rewriting the getarg instruction as `jit_getarg_i(JIT_RET,
     in)', which was not done in this example.

x86
              pushl %ebp
              movl  %esp, %ebp
              pushl %ebx
              pushl %esi
              pushl %edi
              movl  8(%ebp), %eax        movl 4(%esp), %eax
              addl  $1, %eax             incl %eax
              popl  %edi
              popl  %esi
              popl  %ebx
              popl  %ebp
              ret                        ret
     In this case, the main overhead is due to the function's prolog and
     epilog, which is nine instructions long on the x86; a hand-written
     routine would not save unused callee-preserved registers on the
     stack.  It is to be said, however, that this is not a problem in
     more complicated uses, because more complex procedure would
     probably use the `V0' through `V2' registers (`%ebx', `%esi',
     `%edi'); in this case, a hand-written routine would have included
     the prolog too.  Also, a ten byte prolog would probably be a small
     overhead in a more complex function.

   In such a simple case, the macros that make up the back-end compile
reasonably efficient code, with the notable exception of prolog/epilog
code.


File: lightning.info,  Node: printf,  Next: RPN calculator,  Prev: incr,  Up: GNU lightning macros

A simple function call to `printf'
----------------------------------

   Again, here is the code for the example:

     #include <stdio.h>
     #include "lightning.h"
     
     static jit_insn codeBuffer[1024];
     
     typedef void (*pvfi)(int);      /* Pointer to Void Function of Int */
     
     int main()
     {
       pvfi          myFunction;             /* ptr to generated code */
       char          *start, *end;           /* a couple of labels */
       int           in;                     /* to get the argument */
     
       myFunction = (pvfi) (jit_set_ip(codeBuffer).vptr);
       start = jit_get_ip().ptr;
       jit_prolog(1);
       in = jit_arg_i();
       jit_movi_p(JIT_R0, "generated %d bytes\n");
       jit_getarg_i(JIT_R1, in);
       jit_prepare(2);
         jit_pusharg_i(JIT_R1);              /* push in reverse order */
         jit_pusharg_p(JIT_R0);
       jit_finish(printf);
       jit_ret();
       end = jit_get_ip().ptr;
     
       /* call the generated code, passing its size as argument */
       jit_flush_code(start, end);
       myFunction(end - start);
     }

   The function shows how many bytes were generated.  Most of the code
is not very interesting, as it resembles very closely the program
presented in *Note A function which increments a number by one: incr.

   For this reason, we're going to concentrate on just a few statements.

start = jit_get_ip().ptr;
...
end = jit_get_ip().ptr;
     These two instruction call the `jit_get_ip' macro which was
     mentioned in *Note A function which increments a number by one:
     incr too.  In this case we use the only field of `jit_code' that is
     not a function pointer: `ptr', which is a simple `char *'.

jit_movi_p(JIT_R0, "generated %d bytes\n");
     Note the use of the `p' type specifier, which automatically casts
     the second parameter to an `unsigned long' to make the code more
     clear and less cluttered by typecasts.

jit_prepare(2);
jit_pusharg_i(JIT_R1);
jit_pusharg_p(JIT_R0);
jit_finish(printf);
     Once the arguments to `printf' have been put in general-purpose
     registers, we can start a prepare/pusharg/finish sequence that
     moves the argument to either the stack or registers, then calls
     `printf', then cleans up the stack.  Note how GNU lightning
     abstracts the differences between different architectures and
     ABI's - the client program does not know how parameter passing
     works on the host architecture.


File: lightning.info,  Node: RPN calculator,  Next: Fibonacci,  Prev: printf,  Up: GNU lightning macros

A more complex example, an RPN calculator
-----------------------------------------

   We create a small stack-based RPN calculator which applies a series
of operators to a given parameter and to other numeric operands.
Unlike previous examples, the code generator is fully parameterized and
is able to compile different formulas to different functions.  Here is
the code for the expression compiler; a sample usage will follow.

     #include <stdio.h>
     #include "lightning.h"
     
     typedef int (*pifi)(int);       /* Pointer to Int Function of Int */
     
     pifi compile_rpn(char *expr)
     {
       pifi fn;
       int in;
       fn = (pifi) (jit_get_ip().iptr);
       jit_leaf(1);
       in = jit_arg_i();
       jit_getarg_i(JIT_R0, in);
     
       while (*expr) {
         char buf[32];
         int n;
         if (sscanf(expr, "%[0-9]%n", buf, &n)) {
           expr += n - 1;
           jit_push_i(JIT_R0);
           jit_movi_i(JIT_R0, atoi(buf));
         } else if (*expr == '+') {
           jit_pop_i(JIT_R1);
           jit_addr_i(JIT_R0, JIT_R1, JIT_R0);
         } else if (*expr == '-') {
           jit_pop_i(JIT_R1);
           jit_subr_i(JIT_R0, JIT_R1, JIT_R0);
         } else if (*expr == '*') {
           jit_pop_i(JIT_R1);
           jit_mulr_i(JIT_R0, JIT_R1, JIT_R0);
         } else if (*expr == '/') {
           jit_pop_i(JIT_R1);
           jit_divr_i(JIT_R0, JIT_R1, JIT_R0);
         } else {
           fprintf(stderr, "cannot compile: %s\n", expr);
           abort();
         }
         ++expr;
       }
       jit_movr_i(JIT_RET, JIT_R0);
       jit_ret();
       return fn;
     }

   The principle on which the calculator is based is easy: the stack
top is held in R0, while the remaining items of the stack are held on
the hardware stack.  Compiling an operand pushes the old stack top onto
the stack and moves the operand into R0; compiling an operator pops the
second operand off the stack into R1, and compiles the operation so
that the result goes into R0, thus becoming the new stack top.

   Try to locate a call to `jit_set_ip' in the source code.  You will
not find one; this means that the client has to manually set the
instruction pointer.  This technique has one advantage and one
drawback.  The advantage is that the client can simply set the
instruction pointer once and then generate code for multiple functions,
one after another, without caring about passing a different instruction
pointer each time; see *Note Re-entrant usage of GNU lightning:
Reentrancy for the disadvantage.

   Source code for the client (which lies in the same source file)
follows:

     static jit_insn codeBuffer[1024];
     
     int main()
     {
       pifi c2f, f2c;
       int i;
     
       jit_set_ip(codeBuffer);
       c2f = compile_rpn("9*5/32+");
       f2c = compile_rpn("32-5*9/");
       jit_flush_code(codeBuffer, jit_get_ip().ptr);
     
       printf("\nC:");
       for (i = 0; i <= 100; i += 10) printf("%3d ", i);
       printf("\nF:");
       for (i = 0; i <= 100; i += 10) printf("%3d ", c2f(i));
       printf("\n");
     
       printf("\nF:");
       for (i = 32; i <= 212; i += 10) printf("%3d ", i);
       printf("\nC:");
       for (i = 32; i <= 212; i += 10) printf("%3d ", f2c(i));
       printf("\n");
       return 0;
     }

   The client displays a conversion table between Celsius and Fahrenheit
degrees (both Celsius-to-Fahrenheit and Fahrenheit-to-Celsius). The
formulas are, F(c) = c*9/5+32 and C(f) = (f-32)*5/9, respectively.

   Providing the formula as an argument to `compile_rpn' effectively
parameterizes code generation, making it possible to use the same code
to compile different functions; this is what makes dynamic code
generation so powerful.

   The `rpn.c' file in the GNU lightning distribution includes a more
complete (and more complex) implementation of `compile_rpn', which does
constant folding, allows the argument to the functions to be used more
than once, and is able to assemble instructions with an immediate
parameter.

