
 [index entries: _debug_ _debugger_ _debugging_
                 _profile_ _profiler_ _profiling_
                 _coverage_ ]

_Errortrace_ is a stack-trace-on-exceptions/profiler/coverage tool for
 MzScheme.  Errortrace is not a complete debugger, and a real debugger
 in DrScheme is expected soon; meanwhile, using errortrace might be
 better than nothing.

Quick instructions
------------------

  0) Throw away .zo versions of your source

  1) Prefix your program with
      (import (lib "errortrace.ss" "errortrace"))
     or start MzScheme with the -M flag:
      mzscheme -M errortrace

  2) When an exception occurs, the exception handler
     prints something like a stack trace, most recent
     contexts first

The errortrace module is odd; don't import it into another
module. Instead, the errortrace module is meant to be invoked from the
top-level, so that it can install an evaluation handler, exception
handler, etc.

Exception Information
---------------------

Invoking the errortrace.ss module sets the eval handler to instrument
Scheme source code.

 NOTE: errortrace has no effect on code loaded as compiled byte code
 (i.e., from a .zo file) or native code (i.e., from a .dll or .so
 file).

The errortrace.ss module also sets a debug info handler to record
information about the context of exceptions, and an exception handler
to print out information recorded by the debug info handler. The load
handler is changed to correlate source code with source files.

Errortrace's instrumentation can be explicitly disabled via the
`instrumenting-enabled' boolean parameter. Instrumentation is on by
default. The `instrumenting-enabled' parameter affects only the way
that source code is compiled, not the way that exception information
is reported.

> (instrumenting-enabled) - returns #t if error tracing instrumentation is
  enabled, #f otherwise
> (instrumenting-enabled on?) - enables/disables error tracing
  instrumentation

The instrumentation for storing exception information slows most
programs by a factor of 2 or 3.

Do not load errortrace before writing .zo files. Errortrace
instruments S-expressions with unprintable values; this works fine if
the instrumented S-expression is passed to the default eval handler,
but neither the S-expression nor its byte-code form can be marshalled
to a string.

The `print-error-trace' procedure takes a port and exception and
prints the errortrace-collected debugging information contained in the
exception. It is used by the exception handler installed by
errortrace.

> (print-error-trace output-port exn) - prints the errortrace
  information in `exn' to `output-port'.

The `error-context-display-depth' parameter controls how much context
errortrace's exception handler displays. The default value is 10000.

> (error-context-display-depth) - returns the current context display
  depth
> (error-context-display-depth d) - sets the context display depth to
  `d'

Profiling
---------

Errortrace's profiling instrumentation is off by default. Enable
profiling instrumentation with the `profiling-enabled' boolean
parameter (but setting `instrumentation-enabled' to #f also disables
profiling):

> (profiling-enabled) - returns #t if profiling instrumentation is
  enabled, #f otherwise
> (profiling-enabled on?) - enables/disables profiling instrumentation

Profiling records:

 * the number of times a procedure was called.

 * the number of milliseconds consumed by the procedure's body across
   all calls (including the time consumed by any nested non-tail call
   within the procedure, but not including time consumed by a
   tail-call from the procedure).

 * an inferred name for the procedure, or the procedure's source
   expression if no name can be inferred.

 * the name of the procedure's source file, or #f if the source file
   is unknown.

 * optionally, information about the procedure call path (something
   like the stack trace) for every call to the procedure. Path
   information is collected when the `profile-paths-enabled' boolean
   parameter is #t; the default is #f, but setting the parameter to #t
   immediately affects all procedure instrumented for profiling
   information:

>   (profile-paths-enabled) - returns #t if profiling collects path
    information, #f otherwise
>   (profile-paths-enabled on?) - enables/disables collecting path
    information for profiling

Profiling information is accumulated in a hash table. If a procedure
is redefined, new profiling information is accumulated for the new
version of the procedure, but the old information is also preserved.

To retireve all profiling information accumulated so far, call
`get-profile-results':

> (get-profile-results) - returns a list of lists that contain:

  * the number of times the procedure was called;

  * the number of milliseconds of process time consumed by the
    procedure;

  * the inferred name or #f of the procedure;

  * the syntax source of the procedure; and

  * a list of call paths, recorded while `profile-paths-enabled' is
    set to #t. Each call path is a list containing two-element lists;
    each two-element list contains the calling proceure's name or
    source expression and the calling procedure's source file or #f.

Depending of the source program, profiling induces a factor of 2 to 4
slowdown (in addition to any slowdown from the exception information
instrumentation).

> (output-profile-results paths? sort-time?)

Gets the current profile results and displays them. It optionally
shows paths information (if it is recorded) and sorts by either time
or call counts.

Coverage
--------

Errortrace can track expression execution that is useful for checking
test coverage (i.e., simple expression coverage). Enable coverage
checking with the `execute-counts-enabled' boolean parameter (but
setting `instrumentation-enabled' to #f also disables execute
counting):

> (execute-counts-enabled) - returns #t if execute-counting
  instrumentation is enabled, #f otherwise
> (execute-counts-enabled on?) - enables/disables execute-counting
  instrumentation

> (get-execute-counts) - returns a list of pairs, one for each
  instrucmented expression. The first element of the pair is a syntax
  object (usually containing source location information) for the
  original expression, and the second element of the pair is the
  number of times that the expression has been evaluated.

> (annotate-executed-file filename-path) - writes the named file to
  the current output port, inserting an additional line between each
  source line to reflect execution counts (as reported by
  `get-execute-counts'). An expression underlined with "^" has been
  executed 0 times; an expression underlined with "." has been
  executed 1 time; and an expression underlined with "," has been
  executed multiple times.

_Re-using errortrace stack tracing_
-----------------------------------

The errortrace collection also includes a _stacktrace.ss_ library.
It exports the _stacktrace@_ unit and it import signature
_stacktrace-import^_, and its export signature _stacktrace^_.

The export signature contains these names:

> annotate : syntax (listof ???) boolean -> syntax
> annotate-top : syntax (listof ???) boolean -> syntax

These two functions annotate expressions with errortrace information.
The `annotate-top' function should be called with a top-level
expression, and `annotate' should be called with a nested expression
(e.g., by `profile-point').

The import signature contains these names:

> with-mark : syntax syntax -> syntax

  This procedure is called by `annotate' and `annotate-top' to wrap
  expressions with `with-continuation-mark'. The first argument is the
  source expressions and the second is the expression to be wrapped.

> profile-point : (syntax ?? ?? ?? ?? -> syntax)

  This procedure is called by `annotate' and `annotate-top' to wrap
  expressions with profile collecting information.  Returning the
  first argument means no profiling information is collected.
