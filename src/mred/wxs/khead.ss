
;; Generated by xctocc

(module kernel mzscheme
  (import (prefix kernel: #%mred-kernel))
  (import (all-except (lib "class.ss") object%))

  (install-prim-functions kernel:primitive-object? 
			  (lambda (o)
			    (= 2 (kernel:primitive-object-size o)))
			  (lambda (o)
			    (kernel:primitive-object-ref o 0))
			  (lambda (o)
			    (kernel:primitive-object-ref o 1))
			  (lambda (prim-class c s lkup)
			    (let ([o (kernel:make-primitive-object 
				      prim-class
				      2
				      lkup)])
			      (kernel:primitive-object-set! o 0 c)
			      (kernel:primitive-object-set! o 1 s)
			      o))
			  kernel:initialize-primitive-object
			  kernel:primitive-object->class
			  kernel:find-in-primitive-class)

  (define (find-method class name)
    (let loop ([l (kernel:primitive-class->method-name-list class)][p 0])
      (if (eq? name (car l))
	  (vector-ref (kernel:primitive-class->method-vector class) p)
	  (loop (cdr l) (add1 p)))))

  (define-syntax define-constant
    (lambda (stx)
      (syntax-case stx ()
	[(_ name)
	 (with-syntax ([kernel:name (datum->syntax (string->symbol
						    (format 
						     "kernel:~a"
						     (syntax-e (syntax name))))
						   #f (syntax name))])
	   (syntax (export (rename kernel:name name))))])))

  (define-syntax define-function
    (lambda (stx)
      (syntax-case stx ()
	[(_ name)
	 (syntax (define-constant name))])))

  (define-syntax define-functions
    (lambda (stx)
      (syntax-case stx ()
	[(_ name ...)
	 (syntax (begin (define-function name) ...))])))

  (define-syntax define-a-class
    (let ([defined null])
      (lambda (stx)
	(syntax-case stx ()
	  [(_ name super id ...)
	   (let ([nm (syntax-e (syntax name))]
		 [sn (syntax-e (syntax super))]
		 [ids (map syntax-e (syntax->list (syntax (id ...))))])
	     ;; find superclass
	     (let ([sup (assoc sn defined)])
	       (unless (or sup (not sn))
		 (raise-syntax-error
		  'class
		  "class not yet defined"
		  stx
		  (syntax super)))
	       ;; add this class to the list:
	       (set! defined (cons (cons nm (append (if sup
							(cdr sup)
							null)
						    ids))
				   defined))
	       (let-values ([(old new)
			     (let loop ([l ids][o null][n null])
			       (cond
				[(null? l) (values o n)]
				[(memq (car l) (cdr sup))
				 (loop (cdr l) (cons (car l) o) n)]
				[else
				 (loop (cdr l) o (cons (car l) n))]))]
			    [(kn) (string->symbol
				   (format "kernel:~a" nm))])
		 (with-syntax ([(old ...) (datum->syntax old #f #f)]
			       [(new ...) (datum->syntax new #f #f)]
			       [kernel:name (datum->syntax kn #f (syntax name))])
		   (syntax
		    (define name (make-prim-class
				  kernel:name
				  'name super
				  '(old ...)
				  '(new ...)
				  (let ([c kernel:name])
				    (list
				     (find-method c 'old)
				     ...
				     (find-method c 'new)
				     ...)))))))))]))))

  (define-syntax define-class
    (lambda (stx)
      (syntax-case stx ()
	[(_ name super id ...)
	 (syntax
	  (begin 
	    (define-a-class name super id ...)
	    (export name)))])))

  (define-syntax define-private-class
    (lambda (stx)
      (syntax-case stx ()
	[(_ name intf super id ...)
	 (syntax
	  (begin 
	    (define-a-class name super id ...)
	    (define intf (class->interface name))
	    (export intf)))])))
