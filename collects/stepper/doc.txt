What is the _Stepper_?

DrScheme includes an "algebraic stepper," a tool which proceeds
through the evaluation of a set of definitions and expressions,
one step at a time. This evaluation shows the user how DrScheme
evaluates expressions and definitions, and can help in debugging
programs.  Currently, the Stepper is available in the "Beginning
Student" and "Intermediate Student" language levels.

How do I use the Stepper?

The Stepper operates on the contents of the frontmost DrScheme
window.  A click on the "Step" button brings up the stepper
window.  The stepper window has four panes, arranged as follows:

------------------
|    finished    |
------------------
|before ->  after|
------------------
|     coming     |
------------------


The first, "finished," box shows definitions and expressions
whose evaluation is complete. This box is changed only when
another completed evaluation's result is added to it.

The second, "before," box, shows the current expression.  The
region highlighted in green is known as the "redex".  You may
pronounce this word in any way you want.  It is short for
"reducible expression," and it is the expression which is the
next to be simplified.

The third, "after," box shows the result of the reduction.  The
region highlighted in purple is the new expression which is
substituted for the green one as a result of the reduction.

Finally, the fourth box, labeled "coming" above, shows new
expressions introduced by prior reductions which have yet to be
reduced. As an example, a "local" expression may result in many
new definitions which require reduction.  The definitions which
have not yet been evaluated appear in the "coming" box.

There are three buttons at the top of the stepper window.  The
"Home" button returns to the initial state of the evaluation: that
is, no expressions have yet been evaluated.  The "Previous"
button returns to the prior step of the evaluation.  The "Next"
step shows the next step in the evaluation.

For more information on how DrScheme selects a "redex" and how
the expressions are reduced, please see <A>The Beginner Language
Semantics</A> which formally specify the set of rules governing
the language's evaluation.

Please note that the stepper only steps through the expressions
in the definitions window, and does not allow the user to enter
additional expressions.  So, for instance, a definitions buffer
which contains only procedure definitions will not result in
any reductions.


---

Preliminary _Debugger_ Documentation

The debugger is structured as an interaction between the program
being debugged and a debugger UI.  The program is annotated to
produce a stream of debugger "events" (as defined below) and to
periodically block on a debugger semaphore.  The debugger currently
uses the stepper's annotation; changes to the annotation will
be the focus of the next stage of the debugger.

A simple debugger UI is provided as part of the debugger, but
users who want to use the debugger will probably also want
to supply their own UI.  For this reason, we describe the interface
to the UI first, and then the working of the current skeleton 
UI.

Debugger Events:

A debugger-event is either:
> (make-breakpoint-halt), or
> (make-normal-breakpoint-info mark-list kind returned-value-list)
> (make-error-breakpoint-info message)
> (make-expression-finished returned-value-list)

These structures are provided by (lib "private/marks.ss" "stepper).
This library also provides many functions which are used to 
manipulate the marks in a mark-list.

Debugger UI (view-controller) signatures:

  (define-signature debugger-model^
    (go-semaphore
     user-custodian))
  
  (define-signature debugger-vc^
    (receive-result
     debugger-output-port))

A debugger UI is a unit which imports signature debugger-model^
(name-change suggestions welcomed) and exports signature
debugger-vc^ (ditto).  

> go-semaphore: when the user's program halts at a breakpoint,
it will block on this semaphore.  Therefore, the UI can
post to this semaphore to allow computation to proceed.

> user-custodian: the user-custodian governs the user's program.
Therefore, the UI can shut down this custodian to halt debugging.

> (receive-result event) : (event -> void) The user's program 
calls this procedure whenever a debugger event occurs.  Note that 
a  (make-breakpoint-halt) event will occur whenever the user's 
program blocks at a breakpoint.

> debugger-output-port : output from the user's program goes 
to this port. (NB: at the moment, this is broken for a known
reason.)  


Existing mini-UI:

The debugger starts a graphical read-eval-print loop, with the 
following bindings:

> go-semaphore: passed through from the debugger

> (events): returns a list of all events that have occurred during 
the execution of the program.

> user-custodian: passed through from the debugger.

In addition, the mini-UI prints a message to the grepl whenever
an event occurs (which is cheerfully accepted as input the next
time the user presses return...).

