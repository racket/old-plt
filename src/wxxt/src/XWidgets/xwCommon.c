/* Generated by wbuild
 * (generator version 3.2)
 */
#include <X11/IntrinsicP.h>
#include <X11/StringDefs.h>
#include <stdio.h>
#include <ctype.h>
#include <X11/Xmu/Converters.h>
#include <X11/Xmu/CharSet.h>
#include <X11/Shell.h>
#include <X11/keysym.h>
#include "wxAllocColor.h"
#include "wxAllocColor.c"
#include "wxgl.h"
#include <./xwCommonP.h>
#define focus_detail(detail) (detail ==NotifyAncestor ?"NotifyAncestor":detail ==NotifyVirtual ?"NotifyVirtual":detail ==NotifyInferior ?"NotifyInferior":detail ==NotifyNonlinear ?"NotifyNonlinear":detail ==NotifyNonlinearVirtual ?"NotifyNonlinearVirtual":detail ==NotifyPointer ?"NotifyPointer":detail ==NotifyPointerRoot ?"NotifyPointerRoot":detail ==NotifyDetailNone ?"NotifyDetailNone":"???")


static void focusIn(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void focusOut(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void checkTraverse(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void traverseDown(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void traverseUp(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void traverseLeft(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void traverseRight(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void traverseNext(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void traversePrev(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void traverseNextTop(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void traverseHome(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void traverseCurrent(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);

static XtActionsRec actionsList[] = {
{"focusIn", focusIn},
{"focusOut", focusOut},
{"checkTraverse", checkTraverse},
{"traverseDown", traverseDown},
{"traverseUp", traverseUp},
{"traverseLeft", traverseLeft},
{"traverseRight", traverseRight},
{"traverseNext", traverseNext},
{"traversePrev", traversePrev},
{"traverseNextTop", traverseNextTop},
{"traverseHome", traverseHome},
{"traverseCurrent", traverseCurrent},
};
static void _resolve_inheritance(
#if NeedFunctionPrototypes
WidgetClass
#endif
);
static void realize(
#if NeedFunctionPrototypes
Widget,XtValueMask *,XSetWindowAttributes *
#endif
);
static void class_initialize(
#if NeedFunctionPrototypes
void
#endif
);
static void initialize(
#if NeedFunctionPrototypes
Widget ,Widget,ArgList ,Cardinal *
#endif
);
static Boolean  set_values(
#if NeedFunctionPrototypes
Widget ,Widget ,Widget,ArgList ,Cardinal *
#endif
);
static void compute_inside(
#if NeedFunctionPrototypes
Widget,Position *,Position *,int *,int *
#endif
);
static Dimension  total_frame_width(
#if NeedFunctionPrototypes
Widget
#endif
);
static void expose(
#if NeedFunctionPrototypes
Widget,XEvent *,Region 
#endif
);
static void _expose(
#if NeedFunctionPrototypes
Widget,XEvent *,Region 
#endif
);
static void destroy(
#if NeedFunctionPrototypes
Widget
#endif
);
static void highlight_border(
#if NeedFunctionPrototypes
Widget
#endif
);
static void unhighlight_border(
#if NeedFunctionPrototypes
Widget
#endif
);
static Boolean  accept_focus(
#if NeedFunctionPrototypes
Widget,Time *
#endif
);
static void hilite_callbacks(
#if NeedFunctionPrototypes
Widget
#endif
);
static Boolean  would_accept_focus(
#if NeedFunctionPrototypes
Widget
#endif
);
static void traverse(
#if NeedFunctionPrototypes
Widget,TraversalDirection ,Widget ,Time *
#endif
);
static Boolean  lighter_color(
#if NeedFunctionPrototypes
Widget,Pixel ,Pixel *
#endif
);
static Boolean  darker_color(
#if NeedFunctionPrototypes
Widget,Pixel ,Pixel *
#endif
);
static Boolean  set_color(
#if NeedFunctionPrototypes
Widget,Pixel ,Pixel *
#endif
);
#define done(type, value) do {\
        if (to->addr != NULL) {\
            if (to->size < sizeof(type)) {\
                to->size = sizeof(type);\
                return False;\
            }\
            *(type*)(to->addr) = (value);\
        } else {\
            static type static_val;\
            static_val = (value);\
            to->addr = (XtPointer)&static_val;\
        }\
        to->size = sizeof(type);\
        return True;\
    }while (0 )


static Boolean  cvtStringToAlignment(
#if NeedFunctionPrototypes
Display *,XrmValuePtr ,Cardinal *,XrmValuePtr ,XrmValuePtr ,XtPointer *
#endif
);
static Boolean  cvtAlignmentToString(
#if NeedFunctionPrototypes
Display *,XrmValuePtr ,Cardinal *,XrmValuePtr ,XrmValuePtr ,XtPointer *
#endif
);
static char  extraTranslations[] = "<Key>: checkTraverse()";;
static char  extraTranslationsSmall[] = "\
        <FocusIn>: focusIn()\n\
        <FocusOut>: focusOut()";;
static Boolean  traverse_to_direction(
#if NeedFunctionPrototypes
Widget,TraversalDirection ,int ,int ,Widget *,int *
#endif
);
static void traverse_to_next(
#if NeedFunctionPrototypes
Widget,Widget ,Time *
#endif
);
static void traverse_to_prev(
#if NeedFunctionPrototypes
Widget,Widget ,Time *
#endif
);
static void traverse_to_next_top(
#if NeedFunctionPrototypes
Widget,Widget ,Time *
#endif
);
/*ARGSUSED*/
#if NeedFunctionPrototypes
static Boolean  cvtStringToAlignment(Display * display,XrmValuePtr  args,Cardinal * num_args,XrmValuePtr  from,XrmValuePtr  to,XtPointer * converter_data)
#else
static Boolean  cvtStringToAlignment(display,args,num_args,from,to,converter_data)Display * display;XrmValuePtr  args;Cardinal * num_args;XrmValuePtr  from;XrmValuePtr  to;XtPointer * converter_data;
#endif
{
    Alignment a = 0;
    char c, *t, *s = (char*) from->addr;

    if (*num_args != 0)
        XtAppErrorMsg(XtDisplayToApplicationContext(display),
                      "cvtStringToAlignment", "wrongParameters",
                      "XtToolkitError",
                      "String to Alignment conversion needs no arguments",
                      (String*) NULL, (Cardinal*) NULL);

    while (*s) {
        for (; isspace(*s); s++) ;
        for (t = s; *t && ! isspace(*t); t++) ;
        c = *t;
        *t = '\0';
        if (XmuCompareISOLatin1(s, "top") == 0) a |= XfwfTop;
        else if (XmuCompareISOLatin1(s, "bottom") == 0) a |= XfwfBottom;
        else if (XmuCompareISOLatin1(s, "center") == 0) ; /* skip */
        else if (XmuCompareISOLatin1(s, "left") == 0) a |= XfwfLeft;
        else if (XmuCompareISOLatin1(s, "right") == 0) a |= XfwfRight;
        else {
            XtDisplayStringConversionWarning(display, (char*) from->addr, 
                                             "Alignment");
            break;
        }
        *t = c;
        s = t;
    }
    done(Alignment, a);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static Boolean  cvtAlignmentToString(Display * display,XrmValuePtr  args,Cardinal * num_args,XrmValuePtr  from,XrmValuePtr  to,XtPointer * converter_data)
#else
static Boolean  cvtAlignmentToString(display,args,num_args,from,to,converter_data)Display * display;XrmValuePtr  args;Cardinal * num_args;XrmValuePtr  from;XrmValuePtr  to;XtPointer * converter_data;
#endif
{
    Alignment *a = (Alignment*) from->addr;

    if (*num_args != 0)
        XtAppErrorMsg(XtDisplayToApplicationContext(display),
                      "cvtAlignmentToString", "wrongParameters",
                      "XtToolkitError",
                      "Alignment to String conversion needs no arguments",
                      (String*) NULL, (Cardinal*) NULL);
    switch (*a) {
    case XfwfCenter: done(String, "center");
    case XfwfBottom: done(String, "bottom");
    case XfwfTop: done(String, "top");
    case XfwfLeft: done(String, "left");
    case XfwfRight: done(String, "right");
    case XfwfBottom + XfwfLeft: done(String, "bottom left");
    case XfwfBottom + XfwfRight: done(String, "bottom right");
    case XfwfTop + XfwfLeft: done(String, "top left");
    case XfwfTop + XfwfRight: done(String, "top right");
    default: done(String, "unknown");
    }
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static Boolean  traverse_to_direction(Widget self,TraversalDirection  dir,int  x,int  y,Widget * found,int * distance)
#else
static Boolean  traverse_to_direction(self,dir,x,y,found,distance)Widget self;TraversalDirection  dir;int  x;int  y;Widget * found;int * distance;
#endif
{
    int i;
    Position rx, ry;
    int dist;
    Boolean found_child = False;

    if (! ((XfwfCommonWidget)self)->xfwfCommon.traversalOn) return False;
    /*
     * First recurse to all descendants
     */
    for (i = 0; i < ((XfwfCommonWidget)self)->composite.num_children; i++)
        if (XtIsSubclass(((XfwfCommonWidget)self)->composite.children[i], xfwfCommonWidgetClass)
            && traverse_to_direction(((XfwfCommonWidget)self)->composite.children[i], dir, x, y, found, distance))
            found_child = True;
    if (found_child) return True;
    /*
     * No child found, now check own position and distance
     */
    switch (dir) {
    case TraverseHome: rx = 0; ry = 0; break;
    case TraverseLeft: rx = ((XfwfCommonWidget)self)->core.width; ry = ((XfwfCommonWidget)self)->core.height/2; break;
    case TraverseDown: rx = ((XfwfCommonWidget)self)->core.width/2; ry = 0; break;
    case TraverseRight: rx = 0; ry = ((XfwfCommonWidget)self)->core.height/2; break;
    case TraverseUp: rx = ((XfwfCommonWidget)self)->core.width/2; ry = ((XfwfCommonWidget)self)->core.height; break;
    default: break;
    }
    XtTranslateCoords(self, rx, ry, &rx, &ry);
    if ((dir == TraverseUp && ry > y)
        || (dir == TraverseLeft && rx > x)
        || (dir == TraverseDown && ry < y)
        || (dir == TraverseRight && rx < x)) return False;
    dist = (rx - x)*(rx - x) + (ry - y)*(ry - y);
    if (dist >= *distance) return False;
    /*
     * We are the best so far, but do we want the focus?
     */
    if (! ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.would_accept_focus(self)) return False;
    *distance = dist;
    *found = self;
    return True;
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void traverse_to_next(Widget self,Widget  current,Time * time)
#else
static void traverse_to_next(self,current,time)Widget self;Widget  current;Time * time;
#endif
{
    int i = 0;
    Widget parent = XtParent(self);

    while (i < ((XfwfCommonWidget)self)->composite.num_children && ((XfwfCommonWidget)self)->composite.children[i] != current) i++;
    for (i++; i < ((XfwfCommonWidget)self)->composite.num_children; i++)
        if (XtCallAcceptFocus(((XfwfCommonWidget)self)->composite.children[i], time)) return;
    if (XtIsSubclass(parent, xfwfCommonWidgetClass))
        ((XfwfCommonWidgetClass)parent->core.widget_class)->xfwfCommon_class.traverse(parent, TraverseNext, self, time);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void traverse_to_prev(Widget self,Widget  current,Time * time)
#else
static void traverse_to_prev(self,current,time)Widget self;Widget  current;Time * time;
#endif
{
    int i = 0;
    Widget parent = XtParent(self);

    while (i < ((XfwfCommonWidget)self)->composite.num_children && ((XfwfCommonWidget)self)->composite.children[i] != current) i++;
    for (i--; i >= 0; i--)
        if (XtCallAcceptFocus(((XfwfCommonWidget)self)->composite.children[i], time)) return;
    if (XtIsSubclass(parent, xfwfCommonWidgetClass))
        ((XfwfCommonWidgetClass)parent->core.widget_class)->xfwfCommon_class.traverse(parent, TraversePrev, self, time);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void traverse_to_next_top(Widget self,Widget  current,Time * time)
#else
static void traverse_to_next_top(self,current,time)Widget self;Widget  current;Time * time;
#endif
{
    Widget parent = XtParent(self);

    if (XtIsSubclass(parent, xfwfCommonWidgetClass))
        ((XfwfCommonWidgetClass)parent->core.widget_class)->xfwfCommon_class.traverse(parent, TraverseNextTop, current, time);
    else
        XtCallCallbackList(self, ((XfwfCommonWidget)self)->xfwfCommon.nextTop, NULL);
}

static XtResource resources[] = {
{XtNtraversalOn,XtCTraversalOn,XtRBoolean,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.traversalOn),XtOffsetOf(XfwfCommonRec,xfwfCommon.traversalOn),XtRImmediate,(XtPointer)True },
{XtNtraversalTranslationDone,XtCTraversalTranslationDone,XtRBoolean,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.traversalTranslationDone),XtOffsetOf(XfwfCommonRec,xfwfCommon.traversalTranslationDone),XtRImmediate,(XtPointer)False },
{XtNhighlightThickness,XtCHighlightThickness,XtRDimension,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.highlightThickness),XtOffsetOf(XfwfCommonRec,xfwfCommon.highlightThickness),XtRImmediate,(XtPointer)2 },
{XtNhighlightColor,XtCHighlightColor,XtRPixel,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.highlightColor),XtOffsetOf(XfwfCommonRec,xfwfCommon.highlightColor),XtRString,(XtPointer)XtDefaultForeground },
{XtNhighlightPixmap,XtCHighlightPixmap,XtRPixmap,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.highlightPixmap),XtOffsetOf(XfwfCommonRec,xfwfCommon.highlightPixmap),XtRImmediate,(XtPointer)None },
{XtNnextTop,XtCNextTop,XtRCallback,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.nextTop),XtOffsetOf(XfwfCommonRec,xfwfCommon.nextTop),XtRImmediate,(XtPointer)NULL },
{XtNuserData,XtCUserData,XtRPointer,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.userData),XtOffsetOf(XfwfCommonRec,xfwfCommon.userData),XtRImmediate,(XtPointer)NULL },
{XtNuseExposeCallback,XtCUseExposeCallback,XtRBoolean,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.useExposeCallback),XtOffsetOf(XfwfCommonRec,xfwfCommon.useExposeCallback),XtRImmediate,(XtPointer)False },
{XtNexposeCallback,XtCExposeCallback,XtRCallback,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.exposeCallback),XtOffsetOf(XfwfCommonRec,xfwfCommon.exposeCallback),XtRImmediate,(XtPointer)NULL },
{XtNfocusHiliteChange,XtCFocusHiliteChange,XtRCallback,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.focusHiliteChange),XtOffsetOf(XfwfCommonRec,xfwfCommon.focusHiliteChange),XtRImmediate,(XtPointer)NULL },
{XtNonDestroy,XtCOnDestroy,XtRCallback,sizeof(((XfwfCommonRec*)NULL)->xfwfCommon.onDestroy),XtOffsetOf(XfwfCommonRec,xfwfCommon.onDestroy),XtRImmediate,(XtPointer)NULL },
};

XfwfCommonClassRec xfwfCommonClassRec = {
{ /* core_class part */
/* superclass   	*/  (WidgetClass) &compositeClassRec,
/* class_name   	*/  "XfwfCommon",
/* widget_size  	*/  sizeof(XfwfCommonRec),
/* class_initialize 	*/  class_initialize,
/* class_part_initialize*/  _resolve_inheritance,
/* class_inited 	*/  FALSE,
/* initialize   	*/  initialize,
/* initialize_hook 	*/  NULL,
/* realize      	*/  realize,
/* actions      	*/  actionsList,
/* num_actions  	*/  12,
/* resources    	*/  resources,
/* num_resources 	*/  11,
/* xrm_class    	*/  NULLQUARK,
/* compres_motion 	*/  True ,
/* compress_exposure 	*/  XtExposeCompressMaximal ,
/* compress_enterleave 	*/  True ,
/* visible_interest 	*/  False ,
/* destroy      	*/  destroy,
/* resize       	*/  XtInheritResize,
/* expose       	*/  expose,
/* set_values   	*/  set_values,
/* set_values_hook 	*/  NULL,
/* set_values_almost 	*/  XtInheritSetValuesAlmost,
/* get_values+hook 	*/  NULL,
/* accept_focus 	*/  accept_focus,
/* version      	*/  XtVersion,
/* callback_private 	*/  NULL,
/* tm_table      	*/  NULL,
/* query_geometry 	*/  XtInheritQueryGeometry,
/* display_acceleator 	*/  XtInheritDisplayAccelerator,
/* extension    	*/  NULL 
},
{ /* composite_class part */
XtInheritGeometryManager,
XtInheritChangeManaged,
XtInheritInsertChild,
XtInheritDeleteChild,
NULL
},
{ /* XfwfCommon_class part */
compute_inside,
total_frame_width,
_expose,
highlight_border,
unhighlight_border,
hilite_callbacks,
would_accept_focus,
traverse,
lighter_color,
darker_color,
set_color,
/* traversal_trans */  NULL ,
/* traversal_trans_small */  NULL ,
/* travMode */  1 ,
},
};
WidgetClass xfwfCommonWidgetClass = (WidgetClass) &xfwfCommonClassRec;
/*ARGSUSED*/
static void focusIn(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    Time time = CurrentTime;

    if (event->type != FocusIn)
        XtError("focusIn action may only be bound to FocusIn events");
    if (! ((XfwfCommonWidget)self)->xfwfCommon.traversalOn)
        return;

    if (event->xfocus.detail == NotifyAncestor
        || event->xfocus.detail == NotifyInferior
        || event->xfocus.detail == NotifyNonlinear) {
        if (!((XfwfCommonWidget)self)->xfwfCommon.traversal_focus)
	  ((XfwfCommonWidgetClass)self->core.widget_class)->core_class.accept_focus(self, &time);
    } else if (event->xfocus.detail != NotifyPointer) {
      if (((XfwfCommonWidget)self)->xfwfCommon.traversal_focus) {
        ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.unhighlight_border(self);
        ((XfwfCommonWidget)self)->xfwfCommon.traversal_focus = False;
        ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.hilite_callbacks(self);
      }
   }
}

/*ARGSUSED*/
static void focusOut(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    if (event->type != FocusOut)
        XtError("focusOut action may only be bound to FocusOut events");
    if (((XfwfCommonWidget)self)->xfwfCommon.traversal_focus) {
      if (event->xfocus.detail == NotifyAncestor
        || event->xfocus.detail == NotifyInferior
        || event->xfocus.detail == NotifyNonlinear) {
          ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.unhighlight_border(self);
          ((XfwfCommonWidget)self)->xfwfCommon.traversal_focus = False;
          ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.hilite_callbacks(self);
       }
    }
}

/*ARGSUSED*/
static void checkTraverse(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
  static KeyCode up, down, left, right, next, prior, tab, enter, home;
  char *action;

  if (!up) {
    Display *d = XtDisplay(self);
    up = XKeysymToKeycode(d, XK_Up);
    down = XKeysymToKeycode(d, XK_Down);
    left = XKeysymToKeycode(d, XK_Left);
    right = XKeysymToKeycode(d, XK_Right);
    next = XKeysymToKeycode(d, XK_Next);
    prior = XKeysymToKeycode(d, XK_Prior);
    enter = XKeysymToKeycode(d, XK_KP_Enter);
    home = XKeysymToKeycode(d, XK_Home);
    tab = XKeysymToKeycode(d, XK_Tab);
  }

  if (event->xkey.keycode == up)
    action = "traverseUp";
  else if (event->xkey.keycode == down)
    action = "traverseDown";
  else if (event->xkey.keycode == left)
    action = "traverseLeft";
  else if (event->xkey.keycode == right)
    action = "traverseRight";
  else if (event->xkey.keycode == next)
    action = "traverseNext";
  else if (event->xkey.keycode == prior)
    action = "traversePrev";
  else if (event->xkey.keycode == enter)
    action = "traverseNextTop";
  else if (event->xkey.keycode == home)
    action = "traverseHome";
  else if (event->xkey.keycode == tab) {
    if (event->xkey.state & ShiftMask)
      action = "traversePrev";
    else
      action = "traverseNext";
  } else
    action = NULL;

  if (action)
    XtCallActionProc(self, action, event, NULL, 0);
  else if (((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.travMode == 2)
    ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.travMode = 0;
}

/*ARGSUSED*/
static void traverseDown(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traverse(self, TraverseDown, self, &event->xkey.time);
}

/*ARGSUSED*/
static void traverseUp(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traverse(self, TraverseUp, self, &event->xkey.time);
}

/*ARGSUSED*/
static void traverseLeft(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traverse(self, TraverseLeft, self, &event->xkey.time);
}

/*ARGSUSED*/
static void traverseRight(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traverse(self, TraverseRight, self, &event->xkey.time);
}

/*ARGSUSED*/
static void traverseNext(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traverse(self, TraverseNext, self, &event->xkey.time);
}

/*ARGSUSED*/
static void traversePrev(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traverse(self, TraversePrev, self, &event->xkey.time);
}

/*ARGSUSED*/
static void traverseNextTop(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traverse(self, TraverseNextTop, self, &event->xkey.time);
}

/*ARGSUSED*/
static void traverseHome(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traverse(self, TraverseHome, self, &event->xkey.time);
}

/*ARGSUSED*/
static void traverseCurrent(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    Time time = CurrentTime;

    if (((XfwfCommonWidget)self)->xfwfCommon.traversalOn) (void) ((XfwfCommonWidgetClass)self->core.widget_class)->core_class.accept_focus(self, &time);
}

static void _resolve_inheritance(class)
WidgetClass class;
{
  XfwfCommonWidgetClass c = (XfwfCommonWidgetClass) class;
  XfwfCommonWidgetClass super;
  static CompositeClassExtensionRec extension_rec = {
    NULL, NULLQUARK, XtCompositeExtensionVersion,
    sizeof(CompositeClassExtensionRec), True};
  CompositeClassExtensionRec *ext;
  ext = (XtPointer)XtMalloc(sizeof(*ext));
  *ext = extension_rec;
  ext->next_extension = c->composite_class.extension;
  c->composite_class.extension = ext;
  if (class == xfwfCommonWidgetClass) return;
  super = (XfwfCommonWidgetClass)class->core_class.superclass;
  if (c->xfwfCommon_class.compute_inside == XtInherit_compute_inside)
    c->xfwfCommon_class.compute_inside = super->xfwfCommon_class.compute_inside;
  if (c->xfwfCommon_class.total_frame_width == XtInherit_total_frame_width)
    c->xfwfCommon_class.total_frame_width = super->xfwfCommon_class.total_frame_width;
  if (c->xfwfCommon_class._expose == XtInherit__expose)
    c->xfwfCommon_class._expose = super->xfwfCommon_class._expose;
  if (c->xfwfCommon_class.highlight_border == XtInherit_highlight_border)
    c->xfwfCommon_class.highlight_border = super->xfwfCommon_class.highlight_border;
  if (c->xfwfCommon_class.unhighlight_border == XtInherit_unhighlight_border)
    c->xfwfCommon_class.unhighlight_border = super->xfwfCommon_class.unhighlight_border;
  if (c->xfwfCommon_class.hilite_callbacks == XtInherit_hilite_callbacks)
    c->xfwfCommon_class.hilite_callbacks = super->xfwfCommon_class.hilite_callbacks;
  if (c->xfwfCommon_class.would_accept_focus == XtInherit_would_accept_focus)
    c->xfwfCommon_class.would_accept_focus = super->xfwfCommon_class.would_accept_focus;
  if (c->xfwfCommon_class.traverse == XtInherit_traverse)
    c->xfwfCommon_class.traverse = super->xfwfCommon_class.traverse;
  if (c->xfwfCommon_class.lighter_color == XtInherit_lighter_color)
    c->xfwfCommon_class.lighter_color = super->xfwfCommon_class.lighter_color;
  if (c->xfwfCommon_class.darker_color == XtInherit_darker_color)
    c->xfwfCommon_class.darker_color = super->xfwfCommon_class.darker_color;
  if (c->xfwfCommon_class.set_color == XtInherit_set_color)
    c->xfwfCommon_class.set_color = super->xfwfCommon_class.set_color;
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void realize(Widget self,XtValueMask * mask,XSetWindowAttributes * attributes)
#else
static void realize(self,mask,attributes)Widget self;XtValueMask * mask;XSetWindowAttributes * attributes;
#endif
{
  if (wx_common_use_visual) {
    Display *dpy;
    int scrn;
    dpy = XtDisplay(self);
    scrn = XScreenNumberOfScreen(XtScreen(self));
    attributes->colormap = XCreateColormap(dpy, 
					   RootWindow(dpy, scrn),
					   wx_common_use_visual, AllocNone);
    *mask = *mask | CWColormap;
    XtCreateWindow(self, InputOutput, wx_common_use_visual, *mask, attributes);
  } else {
    compositeClassRec.core_class.realize(self, mask, attributes);
  }
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void class_initialize(void)
#else
static void class_initialize()
#endif
{
    extern void XawInitializeWidgetSet(void);

    XtSetTypeConverter(XtRString, "Alignment", cvtStringToAlignment,
                       NULL, 0, XtCacheNone, NULL);
    XtSetTypeConverter("Alignment", XtRString, cvtAlignmentToString,
                       NULL, 0, XtCacheNone, NULL);
    /* XawInitializeWidgetSet(); */ /* unnecessary for fvwm with >>Style "*" Lenience<< */
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void initialize(Widget  request,Widget self,ArgList  args,Cardinal * num_args)
#else
static void initialize(request,self,args,num_args)Widget  request;Widget self;ArgList  args;Cardinal * num_args;
#endif
{
    Dimension frame;

    if (((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traversal_trans == NULL)
        ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traversal_trans = XtParseTranslationTable(extraTranslations);
    if (((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traversal_trans_small == NULL)
        ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traversal_trans_small = XtParseTranslationTable(extraTranslationsSmall);
    if (((XfwfCommonWidget)self)->xfwfCommon.traversalOn) {
	XtAugmentTranslations(self, ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traversal_trans_small);
        ((XfwfCommonWidgetClass)self->core.widget_class)->core_class.visible_interest = True;
    }
    ((XfwfCommonWidget)self)->xfwfCommon.traversal_focus = False;
    ((XfwfCommonWidget)self)->xfwfCommon.bordergc = NULL;
    frame = ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.total_frame_width(self);
    if (((XfwfCommonWidget)self)->core.width < 2 * frame) ((XfwfCommonWidget)self)->core.width = 2 * frame;
    if (((XfwfCommonWidget)self)->core.height < 2 * frame) ((XfwfCommonWidget)self)->core.height = 2 * frame;
    if (((XfwfCommonWidget)self)->core.width == 0) ((XfwfCommonWidget)self)->core.width = 2;
    if (((XfwfCommonWidget)self)->core.height == 0) ((XfwfCommonWidget)self)->core.height = 2;
    /* create_bordergc($); - Now done on demand */
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static Boolean  set_values(Widget  old,Widget  request,Widget self,ArgList  args,Cardinal * num_args)
#else
static Boolean  set_values(old,request,self,args,num_args)Widget  old;Widget  request;Widget self;ArgList  args;Cardinal * num_args;
#endif
{
    Boolean need_redraw = False;
    Widget parent = XtParent(self);
    Time time = CurrentTime;

    if (((XfwfCommonWidget)self)->xfwfCommon.traversalOn != ((XfwfCommonWidget)old)->xfwfCommon.traversalOn && ((XfwfCommonWidget)self)->xfwfCommon.traversalOn) {	
	XtAugmentTranslations(self, ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traversal_trans_small);
        ((XfwfCommonWidgetClass)self->core.widget_class)->core_class.visible_interest = True;
    }
    if ((((XfwfCommonWidget)self)->core.sensitive != ((XfwfCommonWidget)old)->core.sensitive
    ||  ((XfwfCommonWidget)self)->core.ancestor_sensitive != ((XfwfCommonWidget)old)->core.ancestor_sensitive
    ||  ((XfwfCommonWidget)self)->xfwfCommon.traversalOn != ((XfwfCommonWidget)old)->xfwfCommon.traversalOn)
    &&  ((XfwfCommonWidget)self)->xfwfCommon.traversal_focus) {
        if (XtIsSubclass(parent, xfwfCommonWidgetClass)) {
	    if (((XfwfCommonWidget)self)->core.sensitive == FALSE) {
        	((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.unhighlight_border(self);
        	((XfwfCommonWidget)self)->xfwfCommon.traversal_focus = False;
	        ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.hilite_callbacks(self);
	    }
            ((XfwfCommonWidgetClass)parent->core.widget_class)->xfwfCommon_class.traverse(parent, TraverseHome, self, &time);
	}
    }
    if (((XfwfCommonWidget)self)->xfwfCommon.highlightThickness != ((XfwfCommonWidget)old)->xfwfCommon.highlightThickness)
        need_redraw = True;
    if (((XfwfCommonWidget)self)->xfwfCommon.highlightPixmap != ((XfwfCommonWidget)old)->xfwfCommon.highlightPixmap) {
        if (((XfwfCommonWidget)self)->xfwfCommon.bordergc) create_bordergc(self);
        need_redraw = True;
    } else if (((XfwfCommonWidget)self)->xfwfCommon.highlightColor != ((XfwfCommonWidget)old)->xfwfCommon.highlightColor) {
        ((XfwfCommonWidget)self)->xfwfCommon.highlightPixmap = None;
        if (((XfwfCommonWidget)self)->xfwfCommon.bordergc) create_bordergc(self);
        need_redraw = True;
    }
    return need_redraw;
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void compute_inside(Widget self,Position * x,Position * y,int * w,int * h)
#else
static void compute_inside(self,x,y,w,h)Widget self;Position * x;Position * y;int * w;int * h;
#endif
{
    *x = ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness;
    *y = ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness;
    *w = ((XfwfCommonWidget)self)->core.width - 2 * ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness;
    *h = ((XfwfCommonWidget)self)->core.height - 2 * ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness;
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static Dimension  total_frame_width(Widget self)
#else
static Dimension  total_frame_width(self)Widget self;
#endif
{
    return ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness;
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void expose(Widget self,XEvent * event,Region  region)
#else
static void expose(self,event,region)Widget self;XEvent * event;Region  region;
#endif
{
    if (((XfwfCommonWidget)self)->xfwfCommon.useExposeCallback) {
	XfwfExposeInfo einfo;
	einfo.region = region;
	einfo.event  = event;
	XtCallCallbacks(self, XtNexposeCallback, (XtPointer)&einfo);
    } else {
	((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class._expose(self, event, region);
    }
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void _expose(Widget self,XEvent * event,Region  region)
#else
static void _expose(self,event,region)Widget self;XEvent * event;Region  region;
#endif
{
    if (! XtIsRealized(self)) return;
    if (((XfwfCommonWidget)self)->xfwfCommon.traversal_focus) {
      if (!((XfwfCommonWidget)self)->xfwfCommon.bordergc) create_bordergc(self);
      if (region != NULL) XSetRegion(XtDisplay(self), ((XfwfCommonWidget)self)->xfwfCommon.bordergc, region);
      ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.highlight_border(self);
      if (region != NULL) XSetClipMask(XtDisplay(self), ((XfwfCommonWidget)self)->xfwfCommon.bordergc, None);
    }
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void destroy(Widget self)
#else
static void destroy(self)Widget self;
#endif
{
#if 0
    Widget parent = XtParent(self);
    Time time = CurrentTime;

    /* For MrEd: no focus delegation. If the widget is being destroyed,
       it can't still have the efefctive focus. (Either the widget is hidden
       or its parent is hidden.) */
    if (((XfwfCommonWidget)self)->xfwfCommon.traversal_focus) {
        ((XfwfCommonWidget)self)->core.sensitive = False;
        if (XtIsSubclass(parent, xfwfCommonWidgetClass))
            ((XfwfCommonWidgetClass)parent->core.widget_class)->xfwfCommon_class.traverse(parent, TraverseHome, self, &time);
    }
#endif

    XtCallCallbackList(self, ((XfwfCommonWidget)self)->xfwfCommon.onDestroy, NULL);
    if (((XfwfCommonWidget)self)->xfwfCommon.bordergc) XtReleaseGC(self, ((XfwfCommonWidget)self)->xfwfCommon.bordergc); ((XfwfCommonWidget)self)->xfwfCommon.bordergc = NULL;
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void highlight_border(Widget self)
#else
static void highlight_border(self)Widget self;
#endif
{
    XRectangle rect[4];
    int t;

    /* There's another function like this in xwEnforcer, for some reason */

    if (((XfwfCommonWidget)self)->xfwfCommon.highlightThickness == 0) return;

    t = 1 /* $highlightThickness */; 

    rect[0].x = 1;
    rect[0].y = 0;
    rect[0].width = ((XfwfCommonWidget)self)->core.width - 2;
    rect[0].height = t;

    rect[1].x = 0;
    rect[1].y = 1;
    rect[1].width = t;
    rect[1].height = ((XfwfCommonWidget)self)->core.height - 2;

    rect[2].x = ((XfwfCommonWidget)self)->core.width - t;
    rect[2].y = 1;
    rect[2].width = t;
    rect[2].height = ((XfwfCommonWidget)self)->core.height - 2;

    rect[3].x = 1;
    rect[3].y = ((XfwfCommonWidget)self)->core.height - t;
    rect[3].width = ((XfwfCommonWidget)self)->core.width - 2;
    rect[3].height = t;

    if (!((XfwfCommonWidget)self)->xfwfCommon.bordergc) create_bordergc(self);
    XFillRectangles(XtDisplay(self), XtWindow(self), ((XfwfCommonWidget)self)->xfwfCommon.bordergc, &rect[0], 4);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void unhighlight_border(Widget self)
#else
static void unhighlight_border(self)Widget self;
#endif
{
    if (((XfwfCommonWidget)self)->xfwfCommon.highlightThickness == 0) return;

    XClearArea(XtDisplay(self), XtWindow(self), 
               0, 0, ((XfwfCommonWidget)self)->core.width, ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness, False);
    XClearArea(XtDisplay(self), XtWindow(self),
               0, 0, ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness, ((XfwfCommonWidget)self)->core.height, False);
    XClearArea(XtDisplay(self), XtWindow(self),
               ((XfwfCommonWidget)self)->core.width - ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness, 0, 
               ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness, ((XfwfCommonWidget)self)->core.height, False);
    XClearArea(XtDisplay(self), XtWindow(self),
               0, ((XfwfCommonWidget)self)->core.height - ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness,
               ((XfwfCommonWidget)self)->core.width, ((XfwfCommonWidget)self)->xfwfCommon.highlightThickness, False);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static Boolean  accept_focus(Widget self,Time * time)
#else
static Boolean  accept_focus(self,time)Widget self;Time * time;
#endif
{
    int i;

    if (! XtIsRealized(self) || ! ((XfwfCommonWidget)self)->core.sensitive || ! ((XfwfCommonWidget)self)->xfwfCommon.traversalOn
        /* || ! $visible */ || ! ((XfwfCommonWidget)self)->core.ancestor_sensitive || ! ((XfwfCommonWidget)self)->core.managed
        || ! ((XfwfCommonWidget)self)->core.mapped_when_managed || ((XfwfCommonWidget)self)->core.being_destroyed) return False;
    for (i = 0; i < ((XfwfCommonWidget)self)->composite.num_children; i++)
        if (XtCallAcceptFocus(((XfwfCommonWidget)self)->composite.children[i], time)) return True;
    if (! ((XfwfCommonWidget)self)->xfwfCommon.traversal_focus) {
      int ok;
#if 0
      XSetInputFocus(XtDisplay(self), XtWindow(self), RevertToParent, *time);
      ok = 1;
#else
      Widget parent;
      parent = self;
      while (parent 
	     && !XtIsTopLevelShell(parent) 
	     && !XtIsTransientShell(parent))
	parent = XtParent(parent);
      
      if (parent) {
	XtSetKeyboardFocus(parent, self);
	ok = 1;
      } else 
	ok = 0;

      if (!((XfwfCommonWidget)self)->xfwfCommon.traversalTranslationDone) {
        XtAugmentTranslations(self, ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.traversal_trans);
	((XfwfCommonWidget)self)->xfwfCommon.traversalTranslationDone = True;
      }
#endif
      if (ok) {
        ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.highlight_border(self);
	((XfwfCommonWidget)self)->xfwfCommon.traversal_focus = True;
	((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.hilite_callbacks(self);
      }

      return ok ? True : False;
    }
    return True;
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static void hilite_callbacks(Widget self)
#else
static void hilite_callbacks(self)Widget self;
#endif
{
  XtPointer on = (XtPointer)(long)((XfwfCommonWidget)self)->xfwfCommon.traversal_focus;

  while (self && XtIsSubclass(self, xfwfCommonWidgetClass) && !((XfwfCommonWidget)self)->xfwfCommon.focusHiliteChange)
    self = XtParent(self);

  if (self && XtIsSubclass(self, xfwfCommonWidgetClass))
    XtCallCallbackList(self, ((XfwfCommonWidget)self)->xfwfCommon.focusHiliteChange, on);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static Boolean  would_accept_focus(Widget self)
#else
static Boolean  would_accept_focus(self)Widget self;
#endif
{
    int i;
    Widget child;

    if (! XtIsRealized(self) || ! ((XfwfCommonWidget)self)->core.sensitive || ! ((XfwfCommonWidget)self)->core.ancestor_sensitive || ! ((XfwfCommonWidget)self)->core.visible || ! ((XfwfCommonWidget)self)->xfwfCommon.traversalOn)
        return False;
    else {
        for (i = 0; i < ((XfwfCommonWidget)self)->composite.num_children; i++) {
            child = ((XfwfCommonWidget)self)->composite.children[i];
            if (XtIsSubclass(child, xfwfCommonWidgetClass)
                && ((XfwfCommonWidgetClass)child->core.widget_class)->xfwfCommon_class.would_accept_focus(child))
                return False;
        }
        return True;
    }
}
#define LARGE_NUMBER 2000000000 


/*ARGSUSED*/
#if NeedFunctionPrototypes
static void traverse(Widget self,TraversalDirection  dir,Widget  current,Time * time)
#else
static void traverse(self,dir,current,time)Widget self;TraversalDirection  dir;Widget  current;Time * time;
#endif
{
    Widget w, parent = XtParent(self);
    Position x, y;
    int distance = LARGE_NUMBER;

    if (dir == TraverseNextTop)
        traverse_to_next_top(self, current, time);
    else if (dir == TraverseNext)
        traverse_to_next(self, current, time);
    else if (dir == TraversePrev)
        traverse_to_prev(self, current, time);
    else if (XtIsSubclass(parent, xfwfCommonWidgetClass))
        ((XfwfCommonWidgetClass)parent->core.widget_class)->xfwfCommon_class.traverse(parent, dir, current, time);
    else {
        switch (dir) {
        case TraverseHome: x = 0; y = 0; break;
        case TraverseLeft: x = 0; y = ((XfwfCommonWidget)current)->core.height/2; break;
        case TraverseDown: x = ((XfwfCommonWidget)current)->core.width/2; y = ((XfwfCommonWidget)current)->core.height; break;
        case TraverseRight: x = ((XfwfCommonWidget)current)->core.width; y = ((XfwfCommonWidget)current)->core.height/2; break;
        case TraverseUp: x = ((XfwfCommonWidget)current)->core.width/2; y = 0; break;
	default: break;
        }
        if (dir != TraverseHome) XtTranslateCoords(current, x, y, &x, &y);
        if (traverse_to_direction(self, dir, x, y, &w, &distance))
            XtCallAcceptFocus(w, time);
    }
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static Boolean  lighter_color(Widget self,Pixel  base,Pixel * result)
#else
static Boolean  lighter_color(self,base,result)Widget self;Pixel  base;Pixel * result;
#endif
{
  return get_scaled_color(self, 1.35, base, result);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static Boolean  darker_color(Widget self,Pixel  base,Pixel * result)
#else
static Boolean  darker_color(self,base,result)Widget self;Pixel  base;Pixel * result;
#endif
{
  return get_scaled_color(self, 0.6, base, result);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
static Boolean  set_color(Widget self,Pixel  base,Pixel * result)
#else
static Boolean  set_color(self,base,result)Widget self;Pixel  base;Pixel * result;
#endif
{
  return get_scaled_color(self, 0.85, base, result);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
void XfwfCallComputeInside(Widget self,Position * x,Position * y,int * w,int * h)
#else
void XfwfCallComputeInside(self,x,y,w,h)Widget self;Position * x;Position * y;int * w;int * h;
#endif
{
    if (XtIsSubclass(self, xfwfCommonWidgetClass) && ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.compute_inside) {
	int ww, hh;
        ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.compute_inside(self, x, y, &ww, &hh);
	*w = max(0, ww);
	*h = max(0, hh);
    } else 
        XtWarning
            ("XfwfCallComputeInside only applies to subclasses of Common");
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
Dimension  XfwfCallFrameWidth(Widget self)
#else
Dimension  XfwfCallFrameWidth(self)Widget self;
#endif
{
    if (XtIsSubclass(self, xfwfCommonWidgetClass) && ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.total_frame_width)
        return ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class.total_frame_width(self);
    else 
        XtWarning
            ("XfwfCallFrameWidth only applies to subclasses of Common");
    return 0;
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
Boolean  XfwfChooseColor(Widget self,double  factor,Pixel  base,Pixel * result)
#else
Boolean  XfwfChooseColor(self,factor,base,result)Widget self;double  factor;Pixel  base;Pixel * result;
#endif
{
    Colormap colormap;
    XColor color, dummy;
    static XColor gray75;

    if (XtIsRealized(self))
	colormap = ((XfwfCommonWidget)self)->core.colormap;
    else
	colormap = wx_default_colormap;
    color.pixel = base;

    XQueryColor(XtDisplay(self), colormap, &color);
    color.red = min(65535, factor * color.red);
    color.green = min(65535, factor * color.green);
    color.blue = min(65535, factor * color.blue);
    if (!wxAllocColor(XtDisplay(self), colormap, &color))
	return False;
    if (base == color.pixel) {
      if (!gray75.pixel)
    	if (!XAllocNamedColor(XtDisplay(self), colormap, "gray75", &gray75, &dummy)) {
	  return False;
        }
      color.red = gray75.red;
      color.green = gray75.green;
      color.blue = gray75.blue;
      color.pixel = gray75.pixel;
     }
    *result = color.pixel;
    return True;
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
void XfwfCallExpose(Widget self,XEvent * event,Region  region)
#else
void XfwfCallExpose(self,event,region)Widget self;XEvent * event;Region  region;
#endif
{
    if (XtIsSubclass(self, xfwfCommonWidgetClass) && ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class._expose)
        ((XfwfCommonWidgetClass)self->core.widget_class)->xfwfCommon_class._expose(self, event, region);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
void create_bordergc(Widget self)
#else
void create_bordergc(self)Widget self;
#endif
{
    XtGCMask mask;
    XGCValues values;

    if (((XfwfCommonWidget)self)->xfwfCommon.bordergc) XtReleaseGC(self, ((XfwfCommonWidget)self)->xfwfCommon.bordergc);
    if (((XfwfCommonWidget)self)->xfwfCommon.highlightPixmap != None) {
        mask = GCFillStyle | GCTile;
        values.fill_style = FillTiled;
        values.tile = ((XfwfCommonWidget)self)->xfwfCommon.highlightPixmap;
    } else {
	Pixel res;
        mask = GCFillStyle | GCForeground;
        values.fill_style = FillSolid;
	lighter_color(self, ((XfwfCommonWidget)self)->xfwfCommon.highlightColor, &res);
        values.foreground = res;
    }
    ((XfwfCommonWidget)self)->xfwfCommon.bordergc = XtGetGC(self, mask, &values);
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
Boolean  get_scaled_color(Widget self,float  scale,Pixel  base,Pixel * result)
#else
Boolean  get_scaled_color(self,scale,base,result)Widget self;float  scale;Pixel  base;Pixel * result;
#endif
{
  /* These two must be mutually prime: */
#define CACHE_SIZE 29
#define CACHE_STEP 10
  static struct {
    int set;
    float scale;
    Pixel in, out;
  } cache[CACHE_SIZE];
  static int reset = 0;
  int i;

  for (i = 0; i < CACHE_SIZE; i++) {
    if (cache[i].set 
	&& (cache[i].scale == scale)
	&& (cache[i].in == base)) {
      *result = cache[i].out;
      return TRUE;
    }
  }

  if (!XfwfChooseColor(self, scale, base, result))
    return FALSE;
  
  cache[reset].scale = scale;
  cache[reset].in = base;
  cache[reset].out = *result;
  cache[reset].set = 1;

  if (!cache[reset].set) {
    cache[reset].set = 1;
    reset++;
  } else
    reset += CACHE_STEP;

  reset = (reset % CACHE_SIZE);

  return TRUE;
}
/*ARGSUSED*/
#if NeedFunctionPrototypes
Boolean  has_focus_now(Widget self)
#else
Boolean  has_focus_now(self)Widget self;
#endif
{
  return ((XfwfCommonWidget)self)->xfwfCommon.traversal_focus;
}
