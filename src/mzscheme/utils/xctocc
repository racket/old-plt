#!/usr/local/bin/perl

# Copyright (c) 1995 Matthew Flatt

# This file reads C++ class descriptsions from files ending in ".xc".
# It produces a C++ file suitable for linking with libscheme plus
# objscheme.cc.

# See xctocc.dvi for information about using this program.

# SORRY, SORRY, SORRY, SORRY, SORRY, SORRY, SORRY, SORRY, SORRY, SORRY.
# No one should write code like this. It's horrible. It's immoral.
#
# Still, it works well enough for now.

# Get the directory where this file is, and add to include path:
{$0 =~ /^(.*)\/.*$/;  $my_dir = $1; 
 if ($my_dir !~ ?^/?) {
     open(DIRNAME, "pwd | ");
     $pwd = <DIRNAME>;
     close(DIRNAME);
     chop($pwd);
     $my_dir = $pwd . "/" . $my_dir;}
 if ($my_dir =~ ?/$?) {chop ($my_dir);}}
push(@INC, $my_dir);

require "parse.pl";
require "common.pl";

$cc_suffix = "cc";

if ($ARGV[0] eq '-cxx') {
    $cc_suffix = "cxx";
    shift(@ARGV);
}

$file = $infile = $ARGV[0];

if ($file =~ s/.xc$//) {
} else {
    print STDERR "Bad extension \"$infile\".\n";
    exit 1;
}

if (!open(IN, "$file.xc")) {
    print STDERR "Couldn't open \"${file}.xc\"\n";
    exit 1;
}

if (!open(OUT, ">${file}.${cc_suffix}")) {
    print STDERR "Couldn't write \"${file}.${cc_suffix}\"\n";
    exit 1;
}

if (!open(HEADER, ">${file}.h")) {
    print STDERR "Couldn't write \"${file}.h\"\n";
    exit 1;
}

$setup_d_start = "#ifndef WXS_SETUP_ONLY\n";
$setup_d_end = "#endif\n";

print HEADER $setup_d_start;

select(OUT);

$base = '';

$dummyfields = " \"initialization\" : x create";
$scheme_args = "Scheme_Object *obj, int n,  Scheme_Object *p[]";
$global_scheme_args = "int n,  Scheme_Object *p[]";

print "/* DO NOT EDIT THIS FILE. */\n";
print "/* This file was generated by xctocc from \"${file}.xc\". */\n\n";

@common_names = ();
if (open(COMMONL, "common.txt")) {
    while(<COMMONL>) {
	chop;
	push(@common_names, $_);
    }
    close(COMMONL);
}

$thisfile = "$file.xc";
&ReadFile();

print HEADER $setup_d_end;

close(IN);
close(OUT);
close(HEADER);

sub IgnoreLine
{
    print $_[0];
}

sub PrintHeader
{
    print "#include \"wxscheme.h\"\n";
    print "#include \"${file}.h\"\n";
    print "#include \"wxscomon.h\"\n";
    print "\n";
}

sub PrintDefine
{
    print $_[0];
}

sub DoPrintClass 
{

    if ($common) {
	if (!open(COMMONL, ">common.txt")) {
	    print STDERR "Couldn't write \"common.txt\"\n";
	    exit 1;
	}
    }

    if (!$global && !$common) {
	$globalname = "";

	print "class ${newclass} : public ${oldclass} {\n";
	print " public:\n";
	# print "  Scheme_Object *obj;\n";
	foreach $var (@vars) {
	    print "  $var\n";
	}

	print "\n";

	# Print creation prototypes:
	if ($#creators >= 0) {
	    foreach $creator (@creators) {
		&ReadFields($dummyfields . $creator);
		print "  ${newclass}(Scheme_Object * obj";
		print ", " if ($#paramtypes >= 0);
		&PrintParams(1);
		print ");\n";
	    }
	}

	# destruction
	print "  ~${newclass}();\n"
    } else {
	$newclass = "";

	select(HEADER);
    }

    # Print method prototypes
    if (!$global && !$common) {
	$pos = 0;
	foreach $function (@functions) {
	    if (!&Overridden($function, $pos)) {
		&ReadFields($function);
		if ($virtual) {
		    &OIStart;
		    print "  " . &NormalType($returntype) 
			. " ${globalname}${func}(";
		    &PrintParams(1);
		    print ");\n";
		    &OIEnd;
		}
	    }
	    $pos += 1;
	}
    }

    if (!$global && !$common) {
	print "};\n\n";
	# End of class definition
    } else {
	select(OUT);
    }

    if (!$global && !$common) {
	print "Scheme_Object *${newclass}_class;\n\n";
	
	#Do creation methods
	if ($#creators >= 0) {
	    foreach $creator (@creators) {
		&ReadFields($dummyfields . $creator);
		&OIStart;
		print "${newclass}::${newclass}(Scheme_Object * o";
		print ", " if ($#paramtypes >= 0);
		&PrintParams(0);
		print ")\n";
		print ": ${oldclass}(";
		&PrintArgs(1);
		print ")\n";
		print "{\n";
		print "  __gc_external = (void *)o;\n";
		print "  objscheme_backpointer(&__gc_external);\n";
		# print "  objscheme_save_object(this, o);\n";
		print "  objscheme_note_creation(o);\n";
		print "}\n";
		&OIEnd;
		print "\n";
	    }
	}

	# destruction
	print "${newclass}::~${newclass}()\n{\n  ";
	print "  objscheme_destroy(this, (Scheme_Object *)__gc_external);\n}\n\n";
    }

    #Do regular methods
    @funcs = ();
    $pos = 0;
    foreach $function (@functions) {
	if (!&Overridden($function, $pos)) {
	    &PrintMethod($function);
	    @l = grep($_ =~ /^$func$/, @funcs);
	    if ($#l < $[) {
		@funcs = (@funcs, $func);
	    }
	}
	$pos += 1;
    }

    ##Regular glue code

    foreach $func (@funcs) {
	&PrintFunction($func);
    }
    
    foreach $ivar (@ivars) {
	&ReadIvarFields($ivar);
	&OIStart;
	print "static Scheme_Object *objscheme_${oldclass}_Get${ivarname}(";
	print $scheme_args;
	print ")\n{\n  ";
	print "Scheme_Class_Object *cobj;\n  ";
	print &NormalType($ivartype, 1) . " v;\n\n";
	print "  objscheme_check_valid(obj);\n";
	print "  if (n) scheme_wrong_count($getname, 0, 0, n, p);\n";
	print "  cobj = (Scheme_Class_Object *)obj;\n";
	print "  if (cobj->primflag)\n";
	print "    v = ";
	&PrintIndirect($ivartype);
	print "(($newclass *)cobj->primdata)->${oldclass}::${ivarname}";
	print ";\n  else\n    v = ";
	&PrintIndirect($ivartype);
	print "(($oldclass *)cobj->primdata)->${ivarname}";

	print ";\n\n  return ";
	&PrintBundleVar("v", $ivartype, '', 1);
	print ";\n}\n";

	if (!$readonly) {
	    print "\nstatic Scheme_Object *objscheme_${oldclass}_Set${ivarname}(";
	    print $scheme_args;
	    print ")\n{\n  ";
	    print "objscheme_check_valid(obj);\n  ";
	    print "Scheme_Class_Object *cobj=(Scheme_Class_Object *)obj;\n  ";
	    print &NormalType($ivartype, 1) . " v;\n\n";
	    print "  if (n != 1) scheme_wrong_count($setname, 1, 1, n, p);\n\n";
	    print "  v = ";
	    &PrintUnbundleVar("p[0]", $ivartype);
	    print ";\n  ";
	    if (substr($ivartype, -1) eq '%' || substr($ivartype, -1) eq '&') {
		print "memcpy(";
		print "&(($oldclass *)cobj->primdata)->${ivarname}";
		print ", v, sizeof(*v));\n";
	    } else {
		print "(($oldclass *)cobj->primdata)->${ivarname}";
		print " = v;\n\n";
	    }
	    print "  return scheme_void;\n}\n";
	}
	&OIEnd;
	print "\n";
    }

    ## General glue code

    if (!$global && !$common) {
	# Init function
	if ($#creators >= 0) {
	    @savefunctions = @functions;
	    @savefuncnames = @funcnames;
	    @functions = ();
	    @funcnames = ();
	    foreach $creator (@creators) {
		$function = $dummyfields . $creator;
		@functions = (@functions, $function);
		@funcnames = (@funcnames, "create");
	    }
	    &PrintFunction("create", 1);
	    @functions = @savefunctions;
	    @funcnames = @savefuncnames;
	}

	# Destroy function
	if (0) {
	    print "static Scheme_Object *objscheme_destroy_${newclass}(";
	    print $scheme_args;
	    print ")\n{\n";
	    print "  Scheme_Class_Object *cobj=(Scheme_Class_Object *)obj;\n";
	    print "  if (n) scheme_signal_error(\"";
	    print "destroy: method takes no arguments";
	    print "\");\n";
	    print "  if (cobj->primflag > 1) return scheme_void;\n";
	    print "  if (cobj->primflag) {\n";
	    print "    cobj->primflag = 2;\n\n";
	    print "    delete (${newclass} *)(cobj->primdata);\n";
	    print "  } else\n";
	    print "    delete (${oldclass} *)(cobj->primdata);\n";
	    print "\n";
	    print "  cobj->primflag = -1;\n\n";
	    print "  return scheme_void;\n}\n\n";
	}
	
	# Class Name function
	print "static Scheme_Object *objscheme_classname_${newclass}(";
	print $scheme_args;
	print ")\n{\n";
	print " WXS_USE_ARGUMENT(obj);\n";
	print "  if (n) scheme_wrong_count(${classstring} \"::get-class-name\", ";
	print "0, 0, n, p);\n";
	print "  return scheme_intern_symbol(${classstring});\n";
	print "}\n\n";
    }

    # Setup function
    if (!$global && !$common) {
	$proto = "void objscheme_setup_${oldclass}(void *env)";
        print HEADER $setup_d_end;
	print HEADER "$proto;\n";
	print HEADER $setup_d_start;
	print "$proto\n{\n";
	
	if (1) {
	    print "if (${newclass}_class) {\n";
	    print "    objscheme_add_global_class(${newclass}_class, ";
	    print " ${classstring}, env);\n";
	    print "} else {\n";
	}

	# Count methods to be installed:
	@funcs = ();
	$nmethod = 1; # count get-class-name, first
	foreach $function (@functions) {
	    &ReadFields($function);
	    @l = grep($_ =~ /^$func$/, @funcs);
	    if ($#l < $[) {
		@funcs = (@funcs, $func);
		$nmethod += 1;
	    }
	}
	foreach $ivar (@ivars) {
	    &ReadIvarFields($ivar);
	    $nmethod += 1;
	    if (!$readonly) {
		$nmethod += 1;
	    }
	}

	# Create class:
	print "  ${newclass}_class = objscheme_def_prim_class(env, ";
	print "${classstring}, ";
	if ($parentstring ne '') {
	    print "${parentstring}";
	} else {
	    print "NULL";
	}
	print ", ";
	if ($#creators >= 0) {
	    print "${newclass}_ConstructScheme";
	} else {
	    print "NULL";
	}
	print ", ${nmethod})";
	print ";\n\n";

	# print "  scheme_add_method(${newclass}_class, ";
	# print "\"destroy\", objscheme_destroy_${newclass});\n\n";

	print "  scheme_add_method_w_arity(${newclass}_class,";
	print "\"get-class-name\",objscheme_classname_${newclass}, 0, 0);\n\n";

	@funcs = ();
	foreach $function (@functions) {
	    &ReadFields($function);
	    @l = grep($_ =~ /^$func$/, @funcs);
	    if ($#l < $[) {
		@funcs = (@funcs, $func);
		if (!$delegate) {
		    &OIStart;
		    if ($justoneok{$func}) {
			print " scheme_add_method_w_arity";
		    } else {
			print " scheme_add_method";
		    }
		    print "(${newclass}_class, ";
		    $cleanfunc = $func;
		    $cleanfunc = &OperatorClean($cleanfunc);
		    print "${fname}, ${newclass}${cleanfunc}";
		    if ($justoneok{$func}) {
			print ", ";
			print $justonemin{$func};
			print ", ";
			print $justonemax{$func};
		    }
		    print ");\n";
		    &OIEnd;
		}
	    }
	}
	
	print "\n";

	foreach $ivar (@ivars) {
	    &ReadIvarFields($ivar);
	    &OIStart;
	    print "  scheme_add_method_w_arity(${newclass}_class,";
	    print "${getname}, objscheme_${oldclass}_Get${ivarname}, 0, 0);\n";
	    if (!$readonly) {
		print "  scheme_add_method_w_arity(${newclass}_class,";
		print "${setname}, objscheme_${oldclass}_Set${ivarname}, 1, 1);\n";
	    }
	    &OIEnd;
	}

	print "\n";

	print "  scheme_made_class(${newclass}_class);\n\n";

	if ($idfield ne '' && $classid ne '') {
	    print "  objscheme_install_bundler(";
	    print "(Objscheme_Bundler)objscheme_bundle_";
	    print "${oldclass}, ${classid});\n"
	}

	print "\n";
	if (1) {
	    print "}\n";
	}
    } elsif (!$common) {
	$proto = "void objscheme_setup_${globalname}(void *env)";
        print HEADER $setup_d_end;
	print HEADER "$proto;\n";
        print HEADER $setup_d_start;
	print "$proto\n{\n";
	@funcs = ();
	foreach $function (@functions) {
	    &ReadFields($function);
	    @l = grep($_ =~ /^$func$/, @funcs);
	    if ($#l < $[) {
		@funcs = (@funcs, $func);
		&OIStart;
		print "  scheme_install_xc_global(${fname},";
		if ($justoneok{$func}) {
		    print " scheme_make_prim_w_arity";
		} else {
		    print " scheme_make_prim";
		}
		print "(${globalname}${func}";
		if ($justoneok{$func}) {
		    print ", ${fname}, ";
		    print $justonemin{$func};
		    print ", ";
		    print $justonemax{$func};
		}
		print ")";
		print ", env);\n";
		&OIEnd;
	    }
	}
    }

    foreach $constant (@constants) {
	&ReadConstFields($constant);
	&OIStart;
	print "  scheme_install_xc_global(${const}, ";
	&PrintBundleVar($cname, $ctype);
	print ", env);\n";
	&OIEnd;
    }

    if (!$common) {
	print "}\n\n";
    }

    if (!$global && !$common) {
	$proto="int objscheme_istype_${oldclass}"
	    . "(Scheme_Object *obj, const char *stop, int nullOK)";
	print HEADER "$proto;\n";
	print "$proto\n";
	print "{\n";
	print "  if (nullOK && SCHEME_NULLP(obj)) return 1;\n";
	print "  if (SAME_TYPE(SCHEME_TYPE(obj), scheme_object_type)\n";
	print "      && scheme_is_subclass(";
	print "((Scheme_Class_Object *)obj)->sclass,";
	print "          ${newclass}_class))\n";
	print "    return 1;\n";
	print "  else {\n";
	print "    if (!stop)\n";
	print "       return 0;\n";
	$cs = &Unquote($classstring, 1);
	print "    scheme_wrong_type(stop, \"$cs\", -1, 0, &obj);\n";
	print "    return 0;\n";
	print "  }\n";
	print "}\n\n";
	
	# Bundle function
	$proto="Scheme_Object *objscheme_bundle_${oldclass}"
	    . "(class ${oldclass} *realobj)";
	print HEADER "$proto;\n";
	print "$proto\n";
	print "{\n  Scheme_Class_Object *obj;\n  Scheme_Object *sobj;\n\n";
	print "  if (!realobj) return scheme_null;\n\n";
	print "  if (realobj->__gc_external)\n";
	print "    return (Scheme_Object *)realobj->__gc_external;\n";
	if ($idfield ne '') {
	    print "  if (";
	    if ($classid ne '') {
		print "(realobj->${idfield} != ${classid}) && ";
	    }
	    print "(sobj = objscheme_bundle_by_type(realobj, ";
	    print "realobj->${idfield})))\n";
	    print "    return sobj;\n";
	}
	print "  obj = (Scheme_Class_Object *)";
	print "scheme_make_uninited_object(${newclass}_class);\n\n";
	print "  obj->primdata = realobj;\n";
	print "  objscheme_register_primpointer(&obj->primdata);\n";
	print "  obj->primflag = 0;\n\n";
	print "  realobj->__gc_external = (void *)obj;\n";
	print "  objscheme_backpointer(&realobj->__gc_external);\n";
	# print "  objscheme_note_creation((Scheme_Object *)obj);\n";
	print "  return (Scheme_Object *)obj;\n}\n\n";

	# Unbundle function
	$proto = "class ${oldclass} *objscheme_unbundle_${oldclass}"
	    . "(Scheme_Object *obj, const char *where, int nullOK)";
	print HEADER "$proto;\n";
	print "$proto\n";
	print "{\n";
	print "  if (nullOK && SCHEME_NULLP(obj)) return NULL;\n\n";
	print "  (void)objscheme_istype_${oldclass}(obj, where, nullOK);\n";

	print "  Scheme_Class_Object *o = ";
	print "(Scheme_Class_Object *)obj;\n";

	print "  objscheme_check_valid(obj);\n";
	print "  if (o->primflag)\n";
	print "    return (${newclass} *)o->primdata;\n";
	print "  else\n";
	print "    return (${oldclass} *)o->primdata;\n";
	print "}\n\n";
    }

    if ($common) {
	close(COMMONL);
    }
}

sub CalcNumRequired
{
    local($forscheme) = @_;

    $paramnum = 0;
    @defvs = @defvals;
    @scms = @schemes;
    foreach $paramtype (@paramtypes) {
	$defval = shift(@defvs);
	$scheme = shift(@scms);
	if (($defval ne '') && ($defval ne '.')) {
	    return $paramnum;
	}
	if (!$forscheme || $scheme) {
	    $paramnum += 1;
	}
    }
    return $paramnum;
}

sub CalcNumPossible
{
    local($forscheme) = @_;
    local($offset);

    $offset = 0;
    if ($forscheme) {
	foreach $scheme (@schemes) {
	    $offset += 1 if (!$scheme);
	}
    }

    return $#paramtypes + 1 - $offset;
}

sub PrintFailureHandling
{
    local($callback) = @_;

    if (($exception eq 'SUPER') && !$virtualonly) {
	print "return " if ($returntype ne 'void');
	if ($common) {
	    print "f(real_obj";
	    if ($#paramtypes >= 0) {
		print ", ";
	    }
	} else {
	    if ($common) {
		print "f(";
	    } else {
		if ($callback) {
		    print "obj->";
		}
		print "${oldclass}::${func}(";
	    }
	}
	&PrintArgs(1);
	print ");";
    } elsif ($exception ne '' && $exception ne 'SUPER') {
	print &ApplyMacros($exception);
    } else {
	print "return;";
    }
}

sub PrintMethod
{
    ($s) = @_;

    &ReadFields($s);

    $save_onlyif = $onlyif;

    $common_name = &MakeCommonName();

    if (!$common) {
	@l = grep($_ =~ /^$common_name$/, @common_names);
	if ($#l >= $[) {
	    $use_common = 1;
	} else {
	    $use_common = 0;
	}

	if ($use_common) {
	    # Print callback for Scheme-based calls. This will be used
	    # by PrintSpecificFunction
	    print "static ";
	    print &NormalType($returntype);
	    $func2 = $func;
	    $func2 = &OperatorClean($func2);
	    print " ${newclass}_${func2}_${common_name}_Scb(";
	    print "Scheme_Object *obj";
	    if ($#paramtypes >= 0) {
		print",";
	    }
	    &PrintParams(0);
	    print "){\n";
	    &PrintCallRealMethod("", "return ", 1);
	    print "\n}\n\n";
	}
    }

    if ($global || (!$virtual && !$common)) {
	return;
    }

    &OIStart;

    # Define Class function
    # 
    if ($common) {
	$methodfuncname = $common_name;
	print COMMONL "$common_name\n";
    } else {
	$methodfuncname = "${newclass}::${func}";
	

	if ($use_common) {
	    # print callback function
	    print "static ";
	    print &NormalType($returntype);
	    print " ${newclass}_${func}_cb(${newclass} *obj";
	    if ($#paramtypes >= 0) {
		print",";
	    }
	    &PrintParams(0);
	    print ") {\n";
	    &PrintFailureHandling(1);
	    print "\n}\n\n";
	}
    }

    print &NormalType($returntype) . " ${methodfuncname}(";
    
    if ($common) {
	select(HEADER);

	print "typedef ";
	print &NormalType($returntype);
	print " (*";
	print "${methodfuncname}_ftype";
	print ")(void *";
	if ($#paramtypes >= 0) {
	    print",";
	}
	&PrintParams(0);
	print ");\n";

	print "typedef ";
	print &NormalType($returntype);
	print " (*";
	print "${methodfuncname}_Sftype";
	print ")(Scheme_Object *";
	if ($#paramtypes >= 0) {
	    print",";
	}
	&PrintParams(0);
	print ");\n";

	print &NormalType($returntype) . " ${methodfuncname}(";
	print "void *, Scheme_Object *, char *,";
	print "${methodfuncname}_ftype f";
	if ($#paramtypes >= 0) {
	    print",";
	}
	&PrintParams(0);
	print ");\n";

	print &NormalType($returntype) . " ${methodfuncname}_Scheme(";
	print "${methodfuncname}_Sftype, char *, Scheme_Object *, int, ";
	print "Scheme_Object **, int";
	if ($#paramtypes >= 0) {
	    print",";
	}
	&PrintParams(0, 'd', 1);
	print ");\n";

	select(OUT);

	print "void *real_obj, Scheme_Object *obj, char *name,\n";
	print "${methodfuncname}_ftype f";
	if ($#paramtypes >= 0) {
	    print",\n";
	}
    }

    &PrintParams(0);
    $pcount = $paramnum;

    print ")\n";
    print "{\n";
    
    if ($hidden) {
	 print "}\n\n";
	 return;
    }

    if (!$common) {
	if ($use_common) {
	    if ($returntype ne 'void') {
		print "return ";
	    }
	    print "$common_name((void *)this, (Scheme_Object *)__gc_external, $fname, ";
	    print "(${common_name}_ftype)${newclass}_${func}_cb";
	    if ($#paramtypes >= 0) {
		print", ";
	    }
	    &PrintArgs(1);
	    print ");\n}\n\n";
	    
	    return;
	}
    }

    # Local variables
    if ($numschemes > 0) {
	print "  Scheme_Object *p[${numschemes}];\n";
    } else {
	print "  Scheme_Object **p = NULL;\n";
    }
    print "  Scheme_Object *v;\n  jmp_buf savebuf;\n";
    print "  Scheme_Object *method;\n  int sj;\n";
    print "  static void *mcache = 0;\n\n";

    print "  method = objscheme_find_method((Scheme_Object *)__gc_external, ";
    if ($common) {
	print "NULL, ";
    } else {
	print "${newclass}_class, ";
    }
    if ($common) {
	print "name";
    } else {
	print $fname;
    }
    print ", &mcache);\n";
    print "  if (method && !OBJSCHEME_PRIM_METHOD(method)) {\n";
    print "    COPY_JMPBUF(savebuf, scheme_error_buf);\n";
    print "    sj = scheme_setjmp(scheme_error_buf);\n";
    print "  } else sj = 1;\n";
    print "  if (sj) {\n";

    print "    if (method && !OBJSCHEME_PRIM_METHOD(method))\n";
    print "      COPY_JMPBUF(scheme_error_buf, savebuf);\n    ";
    
    &PrintFailureHandling();

    print "\n  } else {\n";
    
    print "  " . &ApplyMacros($methpre) . "\n";

    # Setup param array:
    $paramnum = 0;
    $offset = 0;
    @bunds = @bundles;
    @scms = @schemes;
    foreach $paramtype (@paramtypes) {
	$bundle = shift(@bunds);
	$scheme = shift(@scms);

	if ($scheme) {
	    print "  p[${paramnum}] = ";
	    $var = "x" . ($paramnum + $offset);

	    &PrintBundleVar($var, $paramtype, $bundle);
	    
	    print ";\n";

	    $paramnum += 1;
	} else {
	    $offset += 1;
	}
    }

    print "  " . &ApplyMacros($methprecall) . "\n";

    print "\n  v = scheme_apply(";
    print "method, ";
    print "${numschemes}, p);\n";

    print "  " . &ApplyMacros($methpostcall) . "\n";

    &PrintUnbundledEffects();

    print "  " . &ApplyMacros($methpost) . "\n";

    print "  COPY_JMPBUF(scheme_error_buf, savebuf);\n\n";
    
    if ($returntype ne 'void') {
	print "  return ";
	&PrintUnbundleVar("v", $returntype, $returnunbundle, 1, &GetMethod(1) . "\", extracting return value\"");
	print ";\n";
    }
    print "  }\n}\n";

    $onlyif = $save_onlyif;
    &OIEnd;
    print "\n";
}

sub PrintFunction 
{
    ($thefunc, $iscreator) = @_;

    # Define Scheme callback
    #

    $numfuncs = 0;
    $thisfuncs = ();
    $fp = 0;
    foreach $func (@funcnames) {
	if ($thefunc eq $func) {
	    $function = $functions[$fp];
	    &ReadFields($function);
	    if ($numfuncs > 0) {
		$thefunction = $function;
		@argtypes = @schemeparams;
		@argtypeids = @typeids;
		$numposs = &CalcNumRequired(1);
		$found = 1;
		$argpos = 0;
		$foundpos = 0;
		$foundlen = $numfuncs; 
		while ($found && ($argpos < $numposs)) {
		    $found = 0;
		    $checkid = ($argtypeids[$argpos] ne '');
		    foreach $pos (0..($foundlen - 1)) {
			&ReadFields($thisfuncs[$pos + $foundpos]);
			$numposs2 = &CalcNumRequired(1);
			if ($numposs2 > $argpos
			    && (($checkid &&
				 ($typeids[$argpos] eq $argtypeids[$argpos]))
				|| ($schemeparams[$argpos] 
				    eq $argtypes[$argpos]))) {
			    if ($found) {
				$foundlen += 1;
			    } else {
				$foundpos = $pos + $foundpos;
				$foundlen = 1;
				$found = 1;
			    }
			}
		    }
		    $argpos += 1;
		}
		if (!$found) {
		    $foundlen = 0;
		} elsif ($argpos >= $numposs) {
		    &ReadFields($thisfuncs[$foundpos]);
		    $numposs2 = &CalcNumRequired(1);
		    if ($numposs2 == $numposs) {
			$foundlen = -1;
			$thisfuncs[$foundpos] = $thefunction;
		    }
		}
		if ($foundlen >= 0) {
		    splice(@thisfuncs, $foundpos+$foundlen, 0, $thefunction);
		    $numfuncs += 1;
		}
	    } else {
		$numfuncs = 1;
		$thisfuncs[0] = $function;
	    }
	}
	$fp += 1;
    }

    &ReadFields($thisfuncs[0]);

    if ($delegate) {
	return; # Superclass will dispatch for us
    }

    if ($numfuncs == 1) {
	&OIStart;
    }

    print "#pragma argsused\n";

    if ($iscreator) {
	print "static Scheme_Object *${newclass}_ConstructScheme(${scheme_args})";
	print "\n{\n";

	print "  ${newclass} *realobj;\n";
    } else {
	if ($common) {
	    print &NormalType($returntype);
	    $common_name = &MakeCommonName();
	    print " ${common_name}_Scheme(";
	    print "${common_name}_Sftype f, char *name,";
	    print "Scheme_Object *obj, int n, ";
	    print "Scheme_Object **p, int req";
	    if ($#paramtypes >= 0) {
		print",";
	    }
	    &PrintParams(0, 'd', 1);
	} else {
	    print "static Scheme_Object *";
	    $func2 = $func;
	    $func2 = &OperatorClean($func2);
	    if ($common) {
		$common_name = &MakeCommonName();
		print "${common_name}_Scheme";
	    } else {
		print "${globalname}${newclass}${func2}";
	    }
	    print "(";
	    if (!$global) {
		print "${scheme_args}";
	    } else {
		print "${global_scheme_args}";
	    }
	}

	print ")\n{\n";

	if (!$common) {
	    print " WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)\n";
	}

	if ($returntype ne 'void') {
	    print "  " . &NormalType($returntype, 1) . " r;\n";
	}

	if (!$global && !$common) {
	    print "  objscheme_check_valid(obj);\n";
	}
    }

    if ($numfuncs == 1) {
	if (!$iscreator) {
	    $justoneok{$func} = 1;
	    $justonemin{$func} = &CalcNumRequired(1);
	    $justonemax{$func} = &CalcNumPossible(1);
	}
	&PrintSpecificFunction("", $iscreator, !$iscreator, "");
    } else {
	print "  ";

	foreach $pos (0..($numfuncs-2)) {
	    &ReadFields($thisfuncs[$pos + 1]);
	    @schemeparams2 = @schemeparams;
	    @typeids2 = @typeids;
	    &ReadFields($thisfuncs[$pos]);

	    print "if (";

	    # Figure out how many things we'll check
	    $pos = 0;
	    while ($schemeparams[$pos] eq $schemeparams2[$pos]
		   || (($typeids[$pos] ne '')
		       && ($typeids[$pos] eq $typeids2[$pos]))) {
		if ($schemeparams[$pos] eq undef) {
		    print STDERR "error: duplicate function ${newclass}::$func\n";
		    exit(-1);
		}
		$pos += 1;
	    }
	    $checkcount = $pos;
	    $pos += 1;
	    print "(n >= $pos)";

	    # Check them:
	    $pos = 0;
	    @checks = @typechecks;
	    @scms = @schemes;
	    while ($pos < $checkcount) {
		$scheme = 0;
		while (!$scheme) {
		    $check = shift(@checks);
		    $scheme = shift(@scms);
		}
		print " && ";
		&PrintTypecheck("p[${pos}]", $schemeparams[$pos], $check, 0);
		$pos += 1;
	    }
	    print " && ";
	    $scheme = 0;
	    while (!$scheme) {
		$check = shift(@checks);
		$scheme = shift(@scms);
	    }
	    &PrintTypecheck("p[${pos}]", $schemeparams[$pos], $check, 0);
	    
	    print ") {\n";
	    if ($casename eq "") {
		print STDERR "Warning: unnamed ${newclass}::$func case\n";
		$casename = "";
	    } else {
		$casename = " ($casename case)";
	    }
	    &PrintSpecificFunction("  ", $iscreator, 0, $casename);
	    print "  } else ";
	}

	&ReadFields($thisfuncs[$numfuncs - 1]);

	if ($numfuncs > 1) {
	    if ($casename eq "") {
		print STDERR "Warning: unnamed ${newclass}::$func case\n";
		$casename = "";
	    } else {
		$casename = " ($casename case)";
	    }
   	} else {
	    $casename = "";
	}

	print " {\n";
	&PrintSpecificFunction("  ", $iscreator, 0, $casename);
	print "  }";
	print "\n\n";
    }

    if ($iscreator) {
	print "  ((Scheme_Class_Object *)obj)->primdata = realobj;\n";
	print "  objscheme_register_primpointer(&((Scheme_Class_Object *)obj)";
	print "->primdata);\n";
	print "  ((Scheme_Class_Object *)obj)->primflag = 1;\n";
	print "  return obj;\n";
	print "}\n";
    } else {
	print "  return ";

	if ($returntype eq 'void') {
	    if (!$common) {
		print "scheme_void";
	    }
	} else {
	    if (!$common) {
		&PrintBundleVar("r", $returntype, $returnbundle, 1);
	    } else {
		if (&CallByRef($returntype)) {
		    print "*";
		}
		print "r";
	    }
	}
	print ";\n}\n";
    }

    if ($numfuncs == 1) {
	&OIEnd;
    }

    print "\n";
}

sub PrintCallRealMethod
{
    local($prefix, $ret_val, $direct) = @_;

    if ($global) {
	print "$prefix  ";
	print $ret_val if ($returntype ne 'void');
	print "${func}(";
	&PrintArgs($direct);
	print ");\n\n";
    } else {
	print "$prefix  ";
	if ($virtual) {
	    print "if (((Scheme_Class_Object *)obj)->primflag)\n";
	    print "$prefix    ";
	    print $ret_val if ($returntype ne 'void');
	    &PrintIndirect($returntype) if (!$direct);
	    print "(($newclass *)((Scheme_Class_Object *)obj)->primdata)->";
	    if (!$virtualonly) {
		if ($implementor ne "") {
		    print $implementor;
		} else {
		    print $oldclass;
		}
		print "::";
	    }
	    print "${func}(";
	    &PrintArgs($direct);
	    print ");\n";
	    print "$prefix  else\n";
	    print "$prefix    ";
	}
	print $ret_val if ($returntype ne 'void');
	&PrintIndirect($returntype) if (!$direct);
	if (!$externalmethod) {
	    print "(($oldclass *)((Scheme_Class_Object *)obj)->primdata)";
	    print "->";
	}
	print "${func}(";
	if ($externalmethod) {
	    print "(($oldclass *)((Scheme_Class_Object *)obj)->primdata)";
	    print ", " if ($#paramtypes >= 0);
	}
	&PrintArgs($direct);
	print ");\n";
	print "\n";
    }
}

sub PrintSpecificFunction
{
    local($prefix, $iscreator, $just_one, $casename) = @_;

    return if ($hidden);

    &OIStart;

    $req = &CalcNumRequired(1);
    $aname = &Unquote($method);
    
    if (!$common) {
	$common_name = &MakeCommonName();
	@l = grep($_ =~ /^$common_name$/, @common_names);
	if ($#l >= $[) {
	    $use_common = 1;
	} else {
	    $use_common = 0;
	}

	if ($use_common) {
	    print "r = " if ($returntype ne 'void');
	    &PrintIndirect($returntype);
	    print "${common_name}_Scheme(";
	    print "(${common_name}_Sftype)";
	    $func2 = $func;
	    $func2 = &OperatorClean($func2);
	    print "${newclass}_${func2}_${common_name}_Scb";
	    print ", \"${aname}${casename}\", ";
	    if ($global) {
		print "NULL";
	    } else {
		print "obj";
	    }
	    print ", n, p, ${req}";
	    foreach $defv (@defvals) {
		if (($defval ne '') && ($defval ne '.')) {
		    print ", $defval";
		} else {
		    print ", 0";
		}
	    }
	    print ");\n";
	    return;
	}
    }

    &PrintLocals($prefix);
    print "\n";
    print "$prefix  " . &ApplyMacros($gluepre) . "\n";

    if (!$just_one) {
	$possible = &CalcNumPossible(1);
	print "$prefix  if (";
	if (!$common && $req == $possible) {
	    print "n != $req";
	    $minimumok = $possible;
	} else {
	    if ($common || $req) {
		if ($common) {
		    $req_arg = "req";
		} else {
		    $req_arg = $req;
		}
		print "(n < $req_arg) ||";
		$minimumok = $req_arg;
	    } else {
		$minimumok = "0";
	    }
	    print "(n > $possible)";
	}
	print ") \n";
	
	print "$prefix    scheme_wrong_count(";
	if ($common) {
	    print "name";
	} else {
	    print "\"${aname}${casename}\"";
	}
	
	print ", ${minimumok}, ${possible}, n, p);\n";
    }

    &PrintUnbundles($prefix, "\"${aname}${casename}\"");
    print "\n";
    print "$prefix  " . &ApplyMacros($glueprecall) . "\n";

    if ($iscreator) {
	print "$prefix  realobj = new ${newclass}(obj";
	print ", " if ($#paramtypes >= 0);
	&PrintArgs();
	print ");\n";
    } elsif ($common) {
	print "$prefix  "; 
	print "r = " if ($returntype ne 'void');
	if (&CallByRef($returntype)) {
	    print "&";
	}
	print "f(obj";
	print ", " if ($#paramtypes >= 0);
	&PrintArgs(0);
	print ");\n";
    } else {
	&PrintCallRealMethod($prefix, "r = ");
    }

    print "$prefix  " . &ApplyMacros($gluepostcall) . "\n";

    &PrintBundledEffects($prefix);

    print "$prefix  " . &ApplyMacros($gluepost) . "\n";

    if (($onlyif ne '') && ($returntype ne 'void')) {
	print "#else\n";
	print " scheme_signal_error(";
	print "\"%s: provided arglist unsupported on this platform\"";
	print ", \"${aname}${casename}\");\n";
#	print "${prefix}r = ";
#	if ($exception ne '' && $exception ne 'SUPER') {
#	    print &ApplyMacros($exception);
#	} else {
#	    print "0";
#	}
#	print ";\n";
    }

    &OIEnd;
}

sub PrintIndirect
{
    local($type) = @_;

    if ((substr($type, -1) eq '%') || (substr($type, -1) eq '&')) {
	print "&";
    }
}

sub PrintBundleObject
{
    local($var, $paramtype, $nullOK) = @_;

    $nullOK = '0' if ($nullOK eq '');

    print "objscheme_bundle_${paramtype}($var)";
    print HEADER "extern Scheme_Object *objscheme_bundle_${paramtype}";
    print HEADER "(class ${paramtype} *);\n";
}

sub PrintBundleVar
{
    local($var, $paramtype, $bundle, $outgoing) = @_;

    if (($bundle ne undef) && ($bundle ne '')) {
	print &ApplyMacros($bundle, $var);
    } elsif (substr($paramtype, 0, 7) eq 'unknown') {
	print "objscheme_bundle_generic((void *)$var)";
    } elsif (substr($paramtype, -1) eq '*') {
	substr($paramtype, -1) = '';
	print "objscheme_box(";
	&PrintBundleVar("(*$var)", $paramtype);
	print ")";
    } elsif (substr($paramtype, -1) eq '?') {
	substr($paramtype, -1) = '';
	print "(($var) ? ";
	print "objscheme_box(";
	&PrintBundleVar("(*$var)", $paramtype);
	print ")";
	print " : scheme_null)";
    } elsif (substr($paramtype, -1) eq '&') {
	substr($paramtype, -1) = '';
	$var = "&$var" unless $outgoing;
	&PrintBundleVar("$var", $paramtype);
    } elsif (substr($paramtype, -1) eq '+') {
	substr($paramtype, -1) = '';
	print "objscheme_box(";
	&PrintBundleVar($var, $paramtype);
	print ")";
    } elsif ($paramtype eq 'bool') {
	print "($var ? scheme_true : scheme_false)";
    } elsif ($paramtype eq 'char') {
	print "scheme_make_char($var)";
    } elsif ($paramtype eq 'uchar') {
	print "scheme_make_char((char)$var)";
    } elsif ($paramtype eq 'int' 
	     || $paramtype eq 'nnint' 
	     || $paramtype eq 'unsigned') {
	print "scheme_make_integer($var)";
    } elsif ($paramtype eq 'short') {
	print "scheme_make_integer($var)";
    } elsif ($paramtype eq 'byte' || $paramtype eq 'ubyte') {
	print "scheme_make_integer($var)";
    } elsif ($paramtype eq 'long' || $paramtype eq 'Long') {
	print "scheme_make_integer($var)";
    } elsif (($paramtype eq 'float') || ($paramtype eq 'double')
	     || ($paramtype eq 'Double')) {
	print "scheme_make_double($var)";
    } elsif (($paramtype eq 'string') || ($paramtype eq 'cstring')
	     || ($paramtype eq 'custring') || ($paramtype eq 'ustring')
	     || ($paramtype eq 'ncustring') || ($paramtype eq 'nustring')
	     || ($paramtype eq 'nstring') || ($paramtype eq 'ncstring')) {
	print "objscheme_bundle_string((char *)$var)";
    } elsif (($paramtype eq 'pathname') 
	     || ($paramtype eq 'cpathname')
	     || ($paramtype eq 'npathname')
	     || ($paramtype eq 'ncpathname')) {
	print "objscheme_bundle_pathname((char *)$var)";
    } elsif (substr($paramtype, -1) eq '!') {
	substr($paramtype, -1) = '';
	&PrintBundleObject($var, $paramtype);
    } elsif (substr($paramtype, -1) eq '^') {
	substr($paramtype, -1) = '';
	&PrintBundleObject($var, $paramtype, 1);
    } elsif (substr($paramtype, -1) eq '%') {
	substr($paramtype, -1) = '';
	$var = "&$var" unless $outgoing;
	&PrintBundleObject($var, $paramtype);
    } else {
	print STDERR "Unknown type ${paramtype} in $func.\n";
    }
}

sub PrintUnbundleObject
{
    local($var, $paramtype, $nullOK, $mname) = @_;
    local($stop);

    $nullOK = '0' if ($nullOK eq '');

    if (!$common) {
	if (($mname eq '') || ($mname eq undef)) {
	    $stop = &GetMethod(1);
	} else {
	    $stop = $mname;
	}
    } else {
	$stop = "name";
    }

    print "objscheme_unbundle_${paramtype}($var, $stop, $nullOK)";
    print HEADER "extern class ${paramtype} *";
    print HEADER "objscheme_unbundle_${paramtype}" .
	"(Scheme_Object *, const char *, int);\n";
}
    
sub PrintUnbundleVar
{
    local($var, $paramtype, $unbundle, $outgoing, $mname) = @_;
    local($stop);

    if (($mname eq "") || ($mname eq undef)) {
	$stop = &GetMethod(1);
    } else {
	$stop = $mname;
    }

    if (($unbundle ne undef) && ($unbundle ne '')) {
	print &ApplyMacros($unbundle, $var);
    } elsif (substr($paramtype, 0, 7) eq 'unknown') {
	print "(";
	print substr($paramtype, 8);
	print ")objscheme_unbundle_generic($var, $stop)";
    } elsif (substr($paramtype, -1) eq '*' || substr($paramtype, -1) eq '?') {
	substr($paramtype, -1) = '';
	&PrintUnbundleVar("objscheme_unbox($var, $stop)", $paramtype, "", "", $stop);
    } elsif (substr($paramtype, -1) eq '&') {
	substr($paramtype, -1) = '';
	print "*" if ($outgoing);
	&PrintUnbundleVar("$var", $paramtype, "", "", $stop);
    } elsif (substr($paramtype, -1) eq '+') {
	substr($paramtype, -1) = '';
	&PrintUnbundleVar("objscheme_unbox($var, $stop)", $paramtype, "", "", $stop);
    } elsif ($paramtype eq 'bool') {
	print "objscheme_unbundle_bool(${var}, $stop)";
    } elsif ($paramtype eq 'char') {
	print "objscheme_unbundle_char(${var}, $stop)";
    } elsif ($paramtype eq 'uchar') {
	print "((unsigned char)objscheme_unbundle_char(${var}, $stop))";
    } elsif (($paramtype eq 'int') || ($paramtype eq 'unsigned') 
	     || ($paramtype eq 'byte')
	     || ($paramtype eq 'ubyte')
	     || ($paramtype eq 'short') || ($paramtype eq 'long')
	     || ($paramtype eq 'Long')) {
	print "objscheme_unbundle_integer($var, $stop)";
    } elsif (($paramtype eq 'nnint')) {
	print "objscheme_unbundle_nonnegative_integer($var, $stop)";
    } elsif (($paramtype eq 'float') || ($paramtype eq 'double')
	     || ($paramtype eq 'Double')) {
	print "objscheme_unbundle_float($var, $stop)";
    } elsif (($paramtype eq 'nnfloat')) {
	print "objscheme_unbundle_nonnegative_float($var, $stop)";
    } elsif ($paramtype eq 'string' || $paramtype eq 'cstring'
	     || $paramtype eq 'ustring' || $paramtype eq 'custring') {
	print "(${paramtype})objscheme_unbundle_string(${var}, $stop)";
    } elsif ($paramtype eq 'nstring' || $paramtype eq 'ncstring'
	     || $paramtype eq 'nustring' || $paramtype eq 'ncustring') {
	print "(${paramtype})objscheme_unbundle_nullable_string($var, $stop)";
    } elsif ($paramtype eq 'pathname' || $paramtype eq 'cpathname') {
	print "(${paramtype})objscheme_unbundle_pathname(${var}, $stop)";
    } elsif ($paramtype eq 'npathname' || $paramtype eq 'ncpathname') {
	print "(${paramtype})objscheme_unbundle_nullable_pathname(${var}, $stop)";
    } elsif (substr($paramtype, -1) eq '!') {
	substr($paramtype, -1) = '';
	&PrintUnbundleObject($var, $paramtype, 0, $mname);
    } elsif (substr($paramtype, -1) eq '^') {
	substr($paramtype, -1) = '';
	&PrintUnbundleObject($var, $paramtype, 1, $mname);
    } elsif (substr($paramtype, -1) eq '%') {
	substr($paramtype, -1) = '';
	print "*" if ($outgoing);
	&PrintUnbundleObject("$var", $paramtype, 0, $mname);
    } else {
	print STDERR "Unknown type ${paramtype} in $func.\n";
    }
}

sub NormalType {
    local($paramtype, $islocal) = @_;

    if (substr($paramtype, -1) eq '*' || substr($paramtype, -1) eq '?') {
	substr($paramtype, -1) = '';
	$paramtype = &NormalType($paramtype) . '*';
    } elsif (substr($paramtype, 0, 7) eq 'unknown') {
	return substr($paramtype, 8);
    } elsif (substr($paramtype, -1) eq '!') {
	substr($paramtype, -1) = '*';
	$paramtype = "class " . $paramtype;
    } elsif (substr($paramtype, -1) eq '^') {
	substr($paramtype, -1) = '*';
	$paramtype = "class " . $paramtype;
    } elsif (substr($paramtype, -1) eq '%') {
	if ($islocal) {
	    substr($paramtype, -1) = '*';
	} else {
	    substr($paramtype, -1) = '&';
	}
	$paramtype = "class " . $paramtype;
    } elsif (substr($paramtype, -1) eq '+') {
	substr($paramtype, -1) = '';
	$paramtype = &NormalType($paramtype);
	if ($islocal) {
	     $paramtype = $paramtype . '*';
	} else {
	     $paramtype = $paramtype . '&';
	}
    } elsif (substr($paramtype, -2) eq '[]') {
	substr($paramtype, -2) = '*';	
    } elsif ($islocal && (substr($paramtype, -1) eq '&')) {
	substr($paramtype, -1) = '';
	$paramtype = &NormalType($paramtype) . '*';
    } elsif ($paramtype eq 'uchar') {
	$paramtype = 'unsigned char';
    } elsif ($paramtype eq 'bool') {
	$paramtype = $bool;
    } elsif ($paramtype eq 'Long') {
	$paramtype = 'long';
    } elsif ($paramtype eq 'Double') {
	$paramtype = 'double';
    }

    return $paramtype;
}

sub PrintParams {

    ($dodefval, $prefix, $pointify) = @_;

    if ($prefix eq '') {
	$prefix = 'x';
    }

    $paramnum = 0;
    @defvs = @defvals;
    foreach $paramtype (@paramtypes) {
	$defval = shift(@defvs);

	print ", " if ($paramnum > 0);

	print &NormalType($paramtype, $pointify) . " ${prefix}${paramnum}";
	if ($dodefval && ($defval ne '') && ($defval ne '.')) {
	    print " = ${defval}";
	}
	$paramnum += 1;
    }
}

sub PrintArgs 
{
    local($direct) = @_;

    $paramnum = 0;
    foreach $paramtype (@paramtypes) {
	print ", " if ($paramnum > 0);
	print "*" if (($direct != 1) && &CallByRef($paramtype));
	print "x${paramnum}";
	$paramnum += 1;
    }
}

sub PrintLocals
{
    local($prefix) = @_;
    
    $paramnum = 0;
    foreach $paramtype (@paramtypes) {
	$pt = $paramtype;
	if (&NeedsDeref($pt)) {
	    $temp = $pt;
	    substr($temp, -1)  = '';
	    print "$prefix  " . &NormalType($temp) . " _x${paramnum};\n";
	    $deref = 1;
	} else {
	    $deref = 0;
	}
	print "$prefix  " . &NormalType($pt, 1) . " x${paramnum}";
	if ($deref) {
	    print " = &_x${paramnum}";
	}
        print ";\n";
	$paramnum += 1;
    }
}

sub PrintUnbundles
{
    local($prefix, $mname) = @_;

    $paramnum = 0;
    @defvs = @defvals;
    @unbunds = @unbundles;
    @scms = @schemes;
    $offset = 0;
    foreach $paramtype (@paramtypes) {
	$defval = shift(@defvs);
	$unbundle = shift(@unbunds);
	$scheme = shift(@scms);

	if ($scheme || ($unbundle ne '')) {
	    print "$prefix  ";
	    if ((($defval ne '') && ($defval ne '.')) || $common) {
		print "if (n > " . ($paramnum -  $offset) . ") {\n$prefix    ";
	    }
	    $svar = "p[" . ($paramnum - $offset) . "]";
	    $xvar = "x${paramnum}";
	    if (&NeedsDeref($paramtype)) {
		print "if (SCHEME_NULLP($svar))\n";
		if (&CanBeNull($paramtype)) {
		    print "$prefix    $xvar = NULL;";
		} else {
		    print "$prefix    scheme_wrong_type($mname, ";
		    print "\"non-null\", ($paramnum - $offset), n, p);"
		}
		print "\n$prefix  else\n$prefix    *";
	    }
	    print "$xvar = ";
	    &PrintUnbundleVar($svar, $paramtype, $unbundle, "", $mname);
	    print ";\n";
	    if ($common || (($defval ne '') && ($defval ne '.'))) {
		print "$prefix  } else\n$prefix    ";
		print "x${paramnum} = ";
		if ($common) {
		    print "d${paramnum}";
		} else {
		    print "${defval}";
		}
		print ";\n";
	    }
	} 

	if (!$scheme) {
	    $offset += 1;
	}
	$paramnum += 1;
    }
}

sub PrintBundledEffects
{
    local($prefix) = @_;

    $paramnum = 0;
    $offset = 0;
    foreach $paramtype (@paramtypes) {
	if ($schemes[$paramnum]) {
	    if (&NeedsDeref($paramtype)) {
		$pos = $paramnum - $offset;
		print "$prefix  if (n > $pos";
		print " && !SCHEME_NULLP(p[$pos])" if &CanBeNull($paramtype);
		print ")\n$prefix    objscheme_set_box(p[$pos], ";
		substr($paramtype, -1) = '';
		&PrintBundleVar("_x${paramnum}", $paramtype, $bundle);
		print ");\n";
	    }
	} else {
	    $offset += 1;
	}
	$paramnum += 1;
    }
}

sub PrintUnbundledEffects
{
    local($prefix) = @_;

    $paramnum = 0;
    $offset = 0;
    foreach $paramtype (@paramtypes) {
	if ($schemes[$paramnum]) {
	    if (&NeedsDeref($paramtype)) {
		# substr($paramtype, -1) = '';
		print "$prefix  ";
		if (!&CallByRef($paramtype)) {
		    print "if (x${paramnum}) *";
		}
		print "x${paramnum} = ";
		$svar = "p[". ($paramnum - $offset) . "]";
		&PrintUnbundleVar($svar, $paramtype, undef, undef, &GetMethod(1) . "\", extracting return value via box\"");
		print ";\n";
	    }
	} else {
	    $offset += 1;
	}
	$paramnum += 1;
    }	
}

sub PrintTypecheckObj
{
    local($var, $paramtype, $stop, $nullOK) = @_;

    $nullOK = '0' if ($nullOK eq '');
    $stop = &GetMethod($stop);

    print "objscheme_istype_${paramtype}($var, $stop, $nullOK)";
    print HEADER "extern int objscheme_istype_${paramtype}";
    print HEADER "(Scheme_Object *, const char *, int);\n";
}

sub PrintTypecheck
{
    local($var, $paramtype, $check, $stop) = @_;

    $stop = &GetMethod($stop);

    if (substr($paramtype, 0, 7) eq 'unknown') {
	print "objscheme_istype_generic($var, $stop)";
    } elsif (($check ne undef) && ($check ne '')) {
	print &ApplyMacros($check, $var, $stop);
    } elsif (substr($paramtype, -1) eq '*') {
	print "(objscheme_istype_box($var, $stop) && ";
	substr($paramtype, -1) = '';
	&PrintTypecheck("objscheme_unbox($var, $stop)", $paramtype, '', $stop);
	print ")";
    } elsif (substr($paramtype, -1) eq '+') {
	print "(objscheme_istype_box($var, $stop) && ";
	substr($paramtype, -1) = '';
	&PrintTypecheck("objscheme_unbox($var, $stop)", $paramtype, '', $stop);
	print ")";
    } elsif (substr($paramtype, -1) eq '?') {
	print "(SCHEME_NULLP($var) || (objscheme_istype_box($var, $stop) && ";
	substr($paramtype, -1) = '';
	&PrintTypecheck("objscheme_unbox($var, $stop)", $paramtype, '', $stop);
	print "))";
    } elsif (substr($paramtype, -1) eq '&') {
	substr($paramtype, -1) = '';
	&PrintTypecheck($var, $paramtype);
    } elsif ($paramtype eq 'bool') {
	print "objscheme_istype_bool($var, $stop)";
    } elsif ($paramtype eq 'char' || $paramtype eq 'uchar') {
	print "objscheme_istype_char($var, $stop)";
    } elsif (($paramtype eq 'int') || ($paramtype eq 'unsigned') 
	     || ($paramtype eq 'nnint') 
	     || ($paramtype eq 'byte') || ($paramtype eq 'ubyte')
	     || ($paramtype eq 'short') || ($paramtype eq 'long') 
	     || ($paramtype eq 'float') || ($paramtype eq 'nnfloat') 
	     || ($paramtype eq 'double')) {
	print "objscheme_istype_number($var, $stop)";
    } elsif (($paramtype eq 'Long')) {
	print "objscheme_istype_integer($var, $stop)";
    } elsif (($paramtype eq 'Double')) {
	print "objscheme_istype_float($var, $stop)";
    } elsif ($paramtype eq 'string' || $paramtype eq 'cstring'
	     || $paramtype eq 'ustring' || $paramtype eq 'custring') {
	print "objscheme_istype_string($var, $stop)";
    } elsif ($paramtype eq 'nstring' || $paramtype eq 'ncstring'
	     || $paramtype eq 'nustring' || $paramtype eq 'ncustring') {
	print "(SCHEME_NULLP($var) || objscheme_istype_string($var, $stop))";
    } elsif ($paramtype eq 'pathname' || $paramtype eq 'cpathname') {
	print "objscheme_istype_pathname($var, $stop)";
    } elsif ($paramtype eq 'npathname' || $paramtype eq 'ncpathname') {
	print "(SCHEME_NULLP($var) || objscheme_istype_pathname($var, $stop))";
    } elsif (substr($paramtype, -1) eq '!') {
	substr($paramtype, -1) = '';
	&PrintTypecheckObj($var, $paramtype, $stop);
    } elsif (substr($paramtype, -1) eq '^') {
	substr($paramtype, -1) = '';
	&PrintTypecheckObj($var, $paramtype, $stop, 1);
    } elsif (substr($paramtype, -1) eq '%') {
	substr($paramtype, -1) = '';
	&PrintTypecheckObj("$var", $paramtype, $stop);
    } else {
	print STDERR "Unknown type ${paramtype} in $func.\n";
    }
}

sub NeedsDeref
{
    local($paramtype) = @_;

    return ((substr($paramtype,0,7) ne 'unknown')
	    && ((substr($paramtype, -1) eq '*')
		|| (substr($paramtype, -1) eq '+')
		|| (substr($paramtype, -1) eq '?')))
}

sub CanBeNull
{
    return (substr($_[0], -1) eq '?');
}

sub CallByRef
{
    local($paramtype) = @_;

    return ((substr($paramtype, -1) eq '&')
	    || (substr($paramtype, -1) eq '+')
	    || (substr($paramtype, -1) eq '%'));
}

sub GetMethod
{
    local ($stop) = @_;

    if ($stop > 0) {
	return $method;
    } else {
	return "NULL";
    }
}

sub Overridden
{
    local($function, $pos) = @_;

    &ReadFields($function);
    $thefunc = $func;
    @theparamtypes = @paramtypes;
    $thepos = $pos;
    $fp = 0;
    foreach $func (@funcnames) {
	if ($fp >= $thepos) {
	    return 0;
	}
	if ($thefunc eq $func) {
	    &ReadFields($functions[$fp]);
	    if ($#paramtypes == $#theparamtypes) {
		$same = 1;
		foreach $pos (0 .. $#paramtypes) {
		    if ($paramtypes[$pos] ne $theparamtypes[$pos]) {
			$same = 0;
		    }
		}
		if ($same) {
		    return 1;
		}
	    }
	}
	$fp += 1;
    }

    return 0;
}

sub OperatorClean
{
    if (index($_[0], "operator") == $[) {
	$_[0] =~ s/</LT/g;
	$_[0] =~ s/>/GT/g;
	$_[0] =~ s/\*/STAR/g;
	$_[0] =~ s/\-/MINUS/g;
	$_[0] =~ s/\+/PLUS/g;
	$_[0] =~ s/\&/AND/g;
	$_[0] =~ s/\|/OR/g;
	$_[0] =~ s/\!/BANG/g;
	$_[0] =~ s/\:/COLON/g;
	$_[0] =~ s/\@/AT/g;
	$_[0] =~ s/\=/EQUAL/g;
	$_[0] =~ s/\$/DOLLAR/g;
	$_[0] =~ s/\%/MOD/g;
	$_[0] =~ s/\#/NUMBER/g;
	$_[0] =~ s/\~/TILDE/g;
	$_[0] =~ s/\//SLASH/g;
    }
	
    return $_[0];
}

sub OIStart
{
    if ($onlyif ne '') {
	print "#if $onlyif\n";
    }
}

sub OIEnd
{
    if ($onlyif ne '') {
	print "#endif\n";
    }
}
