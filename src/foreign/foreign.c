/********************************************
 ** Do not edit this file!
 ** This file is generated from ./foreign.ssc,
 ** to make changes, edit that file and
 ** run it to generate an updated version
 ** of this file.
 ********************************************/


#include "escheme.h"
#ifdef WINDOWS_DYNAMIC_LOAD
#include <windows.h>
#else
#include <dlfcn.h>
#endif
#include <ffi.h>
/* needed for standard integer type names */
#ifdef WINDOWS_DYNAMIC_LOAD
#include <wtypes.h>
typedef INT8   int8_t;  
typedef UINT8  uint8_t;
typedef INT16  int16_t;
typedef UINT16 uint16_t;
typedef INT32  int32_t;
typedef UINT32 uint32_t;
#else
#include <inttypes.h>
#endif

/*****************************************************************************/
/* Library objects */

/* ffi-lib structure definition */
static Scheme_Type ffi_lib_tag;
typedef struct ffi_lib_struct {
  Scheme_Type type;
  void* handle;
  Scheme_Object* name;
  Scheme_Hash_Table* objects;
} ffi_lib_struct;
#define SCHEME_FFILIBP(x) (SCHEME_TYPE(x)==ffi_lib_tag)
#undef MYNAME
#define MYNAME "ffi-lib?"
static Scheme_Object *FP_ffi_lib_p(int argc, Scheme_Object *argv[])
{ return SCHEME_FFILIBP(argv[0]) ? scheme_true : scheme_false; }

static Scheme_Hash_Table *opened_libs;

/* (ffi-lib filename) -> ffi-lib */
#undef MYNAME
#define MYNAME "ffi-lib"
static Scheme_Object *FP_ffi_lib(int argc, Scheme_Object *argv[])
{
  char *name, *fname;
  void *handle;
  ffi_lib_struct *lib;
  if (!(SCHEME_STRINGP(argv[0]) || SCHEME_FALSEP(argv[0])))
    scheme_wrong_type(MYNAME, "string-or-false", 0, argc, argv);
  /* leave the filename as given, the system will look for it */
  /* (`#f' means open the executable) */
  name = SCHEME_FALSEP(argv[0]) ? "" : SCHEME_STR_VAL(argv[0]);
  fname = SCHEME_FALSEP(argv[0]) ? NULL : SCHEME_STR_VAL(argv[0]);
  lib = (ffi_lib_struct*)scheme_hash_get(opened_libs, (Scheme_Object*)name);
  if (!lib) {
#ifdef WINDOWS_DYNAMIC_LOAD
    handle = (fname==NULL) ? LoadLibrary(fname) : GetModuleHandle(NULL);
    if (handle == NULL) {
      long err;
      err = GetLastError();
      scheme_raise_exn(MZEXN_I_O_FILESYSTEM,
                       argv[0], scheme_intern_symbol("no-ffi-lib"),
                       MYNAME": couldn't open %V (%E)", argv[0], err);
    }
#else
    handle = dlopen(fname, RTLD_NOW | RTLD_GLOBAL);
    if (handle == NULL)
      scheme_raise_exn(MZEXN_I_O_FILESYSTEM,
                       argv[0], scheme_intern_symbol("no-ffi-lib"),
                       MYNAME": couldn't open %V (%s)", argv[0], dlerror());
#endif
    lib = (ffi_lib_struct*)scheme_malloc_stubborn(sizeof(ffi_lib_struct));
    lib->type = ffi_lib_tag;
    lib->handle = (handle);
    lib->name = (argv[0]);
    lib->objects = (scheme_make_hash_table(SCHEME_hash_string));
    scheme_end_stubborn_change(lib);
    scheme_hash_set(opened_libs, (Scheme_Object*)name, (Scheme_Object*)lib);
    /* no dlclose finalizer - since the hash table always keeps a reference */
    /* maybe add some explicit unload at some point */
  }
  return (Scheme_Object*)lib;
}

/* (ffi-lib-name ffi-lib) -> string */
#undef MYNAME
#define MYNAME "ffi-lib-name"
static Scheme_Object *FP_ffi_lib_name(int argc, Scheme_Object *argv[])
{
  char *name;
  if (!SCHEME_FFILIBP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-lib", 0, argc, argv);
  return ((ffi_lib_struct*)argv[0])->name;
}

/*****************************************************************************/
/* Pull pointers (mostly functions) out of ffi-lib objects */

/* ffi-obj structure definition */
static Scheme_Type ffi_obj_tag;
typedef struct ffi_obj_struct {
  Scheme_Type type;
  void* obj;
  char* name;
  ffi_lib_struct* lib;
} ffi_obj_struct;
#define SCHEME_FFIOBJP(x) (SCHEME_TYPE(x)==ffi_obj_tag)
#undef MYNAME
#define MYNAME "ffi-obj?"
static Scheme_Object *FP_ffi_obj_p(int argc, Scheme_Object *argv[])
{ return SCHEME_FFIOBJP(argv[0]) ? scheme_true : scheme_false; }

/* (ffi-obj objname ffi-lib-or-libname) -> ffi-obj */
#undef MYNAME
#define MYNAME "ffi-obj"
static Scheme_Object *FP_ffi_obj(int argc, Scheme_Object *argv[])
{
  ffi_obj_struct *obj;
  void *dlobj;
  ffi_lib_struct *lib = NULL;
  char *dlname;
  const char *err;
  if (SCHEME_FFILIBP(argv[1]))
    lib = (ffi_lib_struct*)argv[1];
  else if (SCHEME_STRINGP(argv[1]) || SCHEME_FALSEP(argv[1]))
    lib = (ffi_lib_struct*)(FP_ffi_lib(1,&argv[1]));
  else
    scheme_wrong_type(MYNAME, "ffi-lib", 1, argc, argv);
  if (!SCHEME_STRINGP(argv[0]))
    scheme_wrong_type(MYNAME, "string", 0, argc, argv);
  dlname = SCHEME_STR_VAL(argv[0]);
  obj = (ffi_obj_struct*)scheme_hash_get(lib->objects, (Scheme_Object*)dlname);
  if (!obj) {
#ifdef WINDOWS_DYNAMIC_LOAD
    dlobj = GetProcAddress(lib->handle, dlname);
    if (!dlobj) {
      long err;
      err = GetLastError();
      scheme_raise_exn(MZEXN_I_O_FILESYSTEM,
                       argv[0],
                       scheme_intern_symbol("no-ffi-obj"),
                       MYNAME": couldn't get \"%s\" from %V (%E)",
                       dlname, lib->name, err);
    }
#else
    dlobj = dlsym(lib->handle, dlname);
    if (!dlobj) {
      err = dlerror();
      if (err != NULL)
        scheme_raise_exn(MZEXN_I_O_FILESYSTEM,
                         argv[0],
                         scheme_intern_symbol("no-ffi-obj"),
                         MYNAME": couldn't get \"%s\" from %V (%s)",
                         dlname, lib->name, err);
    }
#endif
    obj = (ffi_obj_struct*)scheme_malloc_stubborn(sizeof(ffi_obj_struct));
    obj->type = ffi_obj_tag;
    obj->obj = (dlobj);
    obj->name = (dlname);
    obj->lib = (lib);
    scheme_end_stubborn_change(obj);
    scheme_hash_set(lib->objects, (Scheme_Object*)dlname, (Scheme_Object*)obj);
  }
  return (obj == NULL) ? scheme_false : (Scheme_Object*)obj;
}

/* (ffi-obj-lib ffi-obj) -> ffi-lib */
#undef MYNAME
#define MYNAME "ffi-obj-lib"
static Scheme_Object *FP_ffi_obj_lib(int argc, Scheme_Object *argv[])
{
  if (!SCHEME_FFIOBJP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-obj", 0, argc, argv);
  return (Scheme_Object*)(((ffi_obj_struct*)argv[0])->lib);
}

/* (ffi-obj-name ffi-obj) -> string */
#undef MYNAME
#define MYNAME "ffi-obj-name"
static Scheme_Object *FP_ffi_obj_name(int argc, Scheme_Object *argv[])
{
  if (!SCHEME_FFIOBJP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-obj", 0, argc, argv);
  return scheme_make_string(((ffi_obj_struct*)argv[0])->name);
}

/*****************************************************************************/
/* Types */

/* These are not defined in MzScheme because:
 * - SCHEME_UINT_VAL is not really a simple accessor like other SCHEME_X_VALs
 * - scheme_make_integer_from_unsigned behaves the same as the signed version
 */
#define SCHEME_UINT_VAL(obj) ((unsigned)(SCHEME_INT_VAL(obj)))
#define scheme_make_integer_from_unsigned(i) \
  ((Scheme_Object *)((((unsigned long)i) << 1) | 0x1))

#ifndef SIXTY_FOUR_BIT_INTEGERS

/* longs and ints are really the same */
#define scheme_get_realint_val(x,y) \
  scheme_get_int_val(x,(long*)(y))
#define scheme_get_unsigned_realint_val(x,y) \
  scheme_get_unsigned_int_val(x,(long*)(y))
#define scheme_make_realinteger_value \
  scheme_make_integer_value
#define scheme_make_realinteger_value_from_unsigned \
  scheme_make_integer_value_from_unsigned

#else

/* Modified versions of stuff from number.c  */
/* These will make sense in MzScheme when longs are not the same as ints */
int scheme_get_realint_val(Scheme_Object *o, int *v)
{
  if (SCHEME_INTP(o)) {
    *v = (int)(SCHEME_INT_VAL(o));
    return 1;
  } else if (SCHEME_BIGNUMP(o)) {
    long l;
    int res = scheme_bignum_get_int_val(o, &l);
    *v = (int)l;
    return res;
  } else
    return 0;
}
int scheme_get_unsigned_realint_val(Scheme_Object *o, unsigned int *v)
{
  if (SCHEME_INTP(o)) {
    int i = (int)(SCHEME_INT_VAL(o));
    if (i < 0)
      return 0;
    *v = i;
    return 1;
  } else if (SCHEME_BIGNUMP(o)) {
    long l;
    int res = scheme_bignum_get_unsigned_int_val(o, &l);
    *v = (int)l;
    return res;
  } else
    return 0;
}
Scheme_Object *
scheme_make_realinteger_value(int ri)
{
  long i = (long)ri;
  Scheme_Object *o = scheme_make_integer(i);
  if (SCHEME_INT_VAL(o) == i)
    return o;
  else
    return scheme_make_bignum(i);
}
Scheme_Object *
scheme_make_realinteger_value_from_unsigned(unsigned int ri)
{
  unsigned long i = (unsigned long)ri;
  Scheme_Object *o = scheme_make_integer(i);
  if ((SCHEME_INT_VAL(o) >= 0)
      && ((unsigned long)SCHEME_INT_VAL(o)) == i)
    return o;
  else
    return scheme_make_bignum_from_unsigned(i);
}

#endif

/***********************************************************************
 * The following are the only primitive types.
 * The tricky part is figuring out what width-ed types corrspond to what
 * internal types.  Matthew says:
 *   MzScheme expects to be compiled such that sizeof(int) == 4,
 *   sizeof(long) == sizeof(void*), sizeof(short) >= 2,
 *   sizeof(char) == 1, sizeof(float) == 4, and sizeof(double) == 8.
 *   So, on a 64-bit OS, MzScheme expects only `long' to change.
 **********************************************************************/

/* returns #<void> when used as output type, not for input types. */
#define FFI_void (1)
/* Type Name:   void
 * LibFfi type: ffi_type_void
 * C type:      -none-
 * Predicate:   -none-
 * Scheme->C:   -none-
 * C->Scheme:   scheme_void
 */

#define FFI_int8 (2)
/* Type Name:   int8
 * LibFfi type: ffi_type_sint8
 * C type:      int8_t
 * Predicate:   SCHEME_INTP(<Scheme>)
 * Scheme->C:   SCHEME_INT_VAL(<Scheme>)
 * C->Scheme:   scheme_make_integer(<C>)
 */

#define FFI_uint8 (3)
/* Type Name:   uint8
 * LibFfi type: ffi_type_uint8
 * C type:      uint8_t
 * Predicate:   SCHEME_INTP(<Scheme>)
 * Scheme->C:   SCHEME_UINT_VAL(<Scheme>)
 * C->Scheme:   scheme_make_integer_from_unsigned(<C>)
 */

/* `byte' is a convenient name for uint8 */
/* Alias type: `byte'
 * Aliased to: `uint8'
 */

#define FFI_int16 (4)
/* Type Name:   int16
 * LibFfi type: ffi_type_sint16
 * C type:      int16_t
 * Predicate:   SCHEME_INTP(<Scheme>)
 * Scheme->C:   SCHEME_INT_VAL(<Scheme>)
 * C->Scheme:   scheme_make_integer(<C>)
 */

#define FFI_uint16 (5)
/* Type Name:   uint16
 * LibFfi type: ffi_type_uint16
 * C type:      uint16_t
 * Predicate:   SCHEME_INTP(<Scheme>)
 * Scheme->C:   SCHEME_UINT_VAL(<Scheme>)
 * C->Scheme:   scheme_make_integer_from_unsigned(<C>)
 */

/* `word' is a convenient name for uint16 */
/* Alias type: `word'
 * Aliased to: `uint16'
 */

/* Treats integers properly: */
#define FFI_int32 (6)
/* Type Name:   int32
 * LibFfi type: ffi_type_sint32
 * C type:      int32_t
 * Predicate:   scheme_get_realint_val(<Scheme>,&aux)
 * Scheme->C:   -none- (set by the predicate)
 * C->Scheme:   scheme_make_realinteger_value(<C>)
 */

/* Treats integers properly: */
#define FFI_uint32 (7)
/* Type Name:   uint32
 * LibFfi type: ffi_type_uint32
 * C type:      unsigned int
 * Predicate:   scheme_get_unsigned_realint_val(<Scheme>,&aux)
 * Scheme->C:   -none- (set by the predicate)
 * C->Scheme:   scheme_make_realinteger_value_from_unsigned(<C>)
 */

/* `int' and `uint' are always synonyms for int32/uint32 (see above) */
/* Alias type: `int'
 * Aliased to: `int32'
 */

/* Alias type: `uint'
 * Aliased to: `uint32'
 */

/* This is like int32, but always assumes fixnum: */
#define FFI_fixint (8)
/* Type Name:   fixint
 * LibFfi type: ffi_type_sint32
 * C type:      int32_t
 * Predicate:   SCHEME_INTP(<Scheme>)
 * Scheme->C:   SCHEME_INT_VAL(<Scheme>)
 * C->Scheme:   scheme_make_integer(<C>)
 */

/* This is like uint32, but always assumes fixnum: */
#define FFI_ufixint (9)
/* Type Name:   ufixint
 * LibFfi type: ffi_type_uint32
 * C type:      uint32_t
 * Predicate:   SCHEME_INTP(<Scheme>)
 * Scheme->C:   SCHEME_UINT_VAL(<Scheme>)
 * C->Scheme:   scheme_make_integer_from_unsigned(<C>)
 */

/* This is what mzscheme defines as long: */
#ifndef SIXTY_FOUR_BIT_INTEGERS
#define ffi_type_smzlong ffi_type_sint32
#define ffi_type_umzlong ffi_type_uint32
#else
#define ffi_type_smzlong ffi_type_sint64
#define ffi_type_umzlong ffi_type_uint64
#endif

/* This is what mzscheme defines as long: */
#define FFI_long (10)
/* Type Name:   long
 * LibFfi type: ffi_type_smzlong
 * C type:      long
 * Predicate:   scheme_get_int_val(<Scheme>,&aux)
 * Scheme->C:   -none- (set by the predicate)
 * C->Scheme:   scheme_make_integer_value(<C>)
 */

/* This is what mzscheme defines as ulong: */
#define FFI_ulong (11)
/* Type Name:   ulong
 * LibFfi type: ffi_type_umzlong
 * C type:      unsigned long
 * Predicate:   scheme_get_unsigned_int_val(<Scheme>,&aux)
 * Scheme->C:   -none- (set by the predicate)
 * C->Scheme:   scheme_make_integer_value_from_unsigned(<C>)
 */

/* This is what mzscheme defines as long, assuming fixnums: */
#define FFI_fixnum (12)
/* Type Name:   fixnum
 * LibFfi type: ffi_type_smzlong
 * C type:      long
 * Predicate:   SCHEME_INTP(<Scheme>)
 * Scheme->C:   SCHEME_INT_VAL(<Scheme>)
 * C->Scheme:   scheme_make_integer(<C>)
 */

/* This is what mzscheme defines as ulong, assuming fixnums: */
#define FFI_ufixnum (13)
/* Type Name:   ufixnum
 * LibFfi type: ffi_type_umzlong
 * C type:      unsigned long
 * Predicate:   SCHEME_INTP(<Scheme>)
 * Scheme->C:   SCHEME_UINT_VAL(<Scheme>)
 * C->Scheme:   scheme_make_integer_from_unsigned(<C>)
 */

#define FFI_float (14)
/* Type Name:   float
 * LibFfi type: ffi_type_float
 * C type:      float
 * Predicate:   SCHEME_FLTP(<Scheme>)
 * Scheme->C:   SCHEME_FLT_VAL(<Scheme>)
 * C->Scheme:   scheme_make_float(<C>)
 */

#define FFI_double (15)
/* Type Name:   double
 * LibFfi type: ffi_type_double
 * C type:      double
 * Predicate:   SCHEME_DBLP(<Scheme>)
 * Scheme->C:   SCHEME_DBL_VAL(<Scheme>)
 * C->Scheme:   scheme_make_double(<C>)
 */

/* Booleans -- implemented as an int which is 1 or 0: */
#define FFI_bool (16)
/* Type Name:   bool
 * LibFfi type: ffi_type_sint
 * C type:      int
 * Predicate:   1
 * Scheme->C:   SCHEME_TRUEP(<Scheme>)
 * C->Scheme:   (<C>?scheme_true:scheme_false)
 */

/* Strings -- no copying of C strings is done, #f is NULL.
 * (note: this is not like char* which is just a pointer) */
#define FFI_string (17)
/* Type Name:   string
 * LibFfi type: ffi_type_pointer
 * C type:      char*
 * Predicate:   SCHEME_FALSEP(<Scheme>)||SCHEME_STRINGP(<Scheme>)
 * Scheme->C:   SCHEME_FALSEP(<Scheme>)?NULL:SCHEME_STR_VAL(<Scheme>)
 * C->Scheme:   (<C>==NULL)?scheme_false:scheme_make_string_without_copying(<C>)
 */

/* This is for any C pointer: #f is NULL, ffi-ptr values as well as
 * ffi-obj and string values pass their pointer.  When used as a return
 * value, either an ffi-ptr object or #f is returned. */
#define FFI_pointer (18)
/* Type Name:   pointer
 * LibFfi type: ffi_type_pointer
 * C type:      void*
 * Predicate:   SCHEME_FFIANYPTRP(<Scheme>)
 * Scheme->C:   SCHEME_FFIANYPTR_VAL(<Scheme>)
 * C->Scheme:   scheme_make_ffiptr(<C>)
 */

/* This is used for passing and Scheme_Object* value as is.  Useful for
 * functions that know about Scheme_Object*s, like MzScheme's. */
#define FFI_scheme (19)
/* Type Name:   scheme
 * LibFfi type: ffi_type_pointer
 * C type:      Scheme_Object*
 * Predicate:   1
 * Scheme->C:   <Scheme>
 * C->Scheme:   <C>
 */

/* Special type, not actually used for anything except to mark points
 * that are treated like pointers but not referenced.  Used for
 * creating function types. */
#define FFI_fmark (20)
/* Type Name:   fmark
 * LibFfi type: ffi_type_pointer
 * C type:      -none-
 * Predicate:   -none-
 * Scheme->C:   -none-
 * C->Scheme:   -none-
 */

typedef union FFIAny {
  int8_t x_int8;
  uint8_t x_uint8;
  int16_t x_int16;
  uint16_t x_uint16;
  int32_t x_int32;
  unsigned int x_uint32;
  int32_t x_fixint;
  uint32_t x_ufixint;
  long x_long;
  unsigned long x_ulong;
  long x_fixnum;
  unsigned long x_ufixnum;
  float x_float;
  double x_double;
  int x_bool;
  char* x_string;
  void* x_pointer;
  Scheme_Object* x_scheme;
} FFIAny;

/* This is a tag that is used to identify user-made struct types. */
#define FFI_struct (21)

/*****************************************************************************/
/* Type objects */

/* This struct is used for both user types and primitive types (including
 * struct types).  If it is a primitive type then basetype will be NULL, and
 * scheme_to_c will have the &ffi_type pointer, and c_to_scheme will have an
 * integer (a label value) for non-struct type. */
/* ffi-type structure definition */
static Scheme_Type ffi_type_tag;
typedef struct ffi_type_struct {
  Scheme_Type type;
  Scheme_Object* basetype;
  Scheme_Object* scheme_to_c;
  Scheme_Object* c_to_scheme;
} ffi_type_struct;
#define SCHEME_FFITYPEP(x) (SCHEME_TYPE(x)==ffi_type_tag)
#undef MYNAME
#define MYNAME "ffi-type?"
static Scheme_Object *FP_ffi_type_p(int argc, Scheme_Object *argv[])
{ return SCHEME_FFITYPEP(argv[0]) ? scheme_true : scheme_false; }

#define FFITYPE_BASETYPE(x) (((ffi_type_struct*)(x))->basetype)
#define FFITYPE_PRIMP(x) (NULL == (FFITYPE_BASETYPE(x)))
#define FFITYPE_USERP(x) (!(FFITYPE_PRIMP(x)))
#define FFITYPE_PRIMTYPE(x) ((ffi_type*)(((ffi_type_struct*)(x))->scheme_to_c))
#define FFITYPE_PRIMLABEL(x) ((int)(((ffi_type_struct*)(x))->c_to_scheme))
#define FFITYPE_USER_S2C(x) (((ffi_type_struct*)(x))->scheme_to_c)
#define FFITYPE_USER_C2S(x) (((ffi_type_struct*)(x))->c_to_scheme)

/* Returns #f for primitive types. */
#undef MYNAME
#define MYNAME "ffi-type-basetype"
static Scheme_Object *FP_ffi_type_basetype(int argc, Scheme_Object *argv[])
{
  Scheme_Object *base;
  if (!SCHEME_FFITYPEP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-type", 0, argc, argv);
  base = FFITYPE_BASETYPE(argv[0]);
  if (NULL == base) return scheme_false;
  else              return base;
}

#undef MYNAME
#define MYNAME "ffi-type-scheme->c"
static Scheme_Object *FP_ffi_type_scheme2c(int argc, Scheme_Object *argv[])
{
  if (!SCHEME_FFITYPEP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-type", 0, argc, argv);
  return (FFITYPE_PRIMP(argv[0])) ? scheme_false :
           ((ffi_type_struct*)(argv[0]))->scheme_to_c;
}

#undef MYNAME
#define MYNAME "ffi-type-c->scheme"
static Scheme_Object *FP_ffi_type_c2scheme(int argc, Scheme_Object *argv[])
{
  if (!SCHEME_FFITYPEP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-type", 0, argc, argv);
  return (FFITYPE_PRIMP(argv[0])) ? scheme_false :
           ((ffi_type_struct*)(argv[0]))->c_to_scheme;
}

/* Returns a primitive type, or NULL if not a type */
static Scheme_Object *ffi_base_ctype(Scheme_Object *type)
{
  if (!SCHEME_FFITYPEP(type)) return NULL;
  while (FFITYPE_USERP(type)) type = FFITYPE_BASETYPE(type);
  return type;
}

/* Returns the size, 0 for void, -1 if no such type */
static int ffi_sizeof(Scheme_Object *type)
{
  type = ffi_base_ctype(type);
  if (type == NULL) return -1;
  switch (FFITYPE_PRIMLABEL(type)) {
  case FFI_void: return 0;
  case FFI_int8: return sizeof(int8_t);
  case FFI_uint8: return sizeof(uint8_t);
  case FFI_int16: return sizeof(int16_t);
  case FFI_uint16: return sizeof(uint16_t);
  case FFI_int32: return sizeof(int32_t);
  case FFI_uint32: return sizeof(unsigned int);
  case FFI_fixint: return sizeof(int32_t);
  case FFI_ufixint: return sizeof(uint32_t);
  case FFI_long: return sizeof(long);
  case FFI_ulong: return sizeof(unsigned long);
  case FFI_fixnum: return sizeof(long);
  case FFI_ufixnum: return sizeof(unsigned long);
  case FFI_float: return sizeof(float);
  case FFI_double: return sizeof(double);
  case FFI_bool: return sizeof(int);
  case FFI_string: return sizeof(char*);
  case FFI_pointer: return sizeof(void*);
  case FFI_scheme: return sizeof(Scheme_Object*);
  case FFI_fmark: return 0;
  /* for structs */
  default: return FFITYPE_PRIMTYPE(type)->size;
  }
}

/* (make-ffi-type basetype scheme->c c->scheme) -> ffi-type */
/* The scheme->c can throw type errors to check for valid arguments */
/* a #f means no conversion function, if both are #f -- then just return the */
/* basetype. */
#undef MYNAME
#define MYNAME "make-ffi-type"
static Scheme_Object *FP_make_ffi_type(int argc, Scheme_Object *argv[])
{
  ffi_type_struct *type;
  if (!SCHEME_FFITYPEP(argv[0]))
    scheme_wrong_type(MYNAME, "C-type", 0, argc, argv);
  else if (!(SCHEME_FALSEP(argv[1]) || SCHEME_PROCP(argv[1])))
    scheme_wrong_type(MYNAME, "procedure-or-false", 1, argc, argv);
  else if (!(SCHEME_FALSEP(argv[2]) || SCHEME_PROCP(argv[2])))
    scheme_wrong_type(MYNAME, "procedure-or-false", 2, argc, argv);
  else if (SCHEME_FALSEP(argv[1]) && SCHEME_FALSEP(argv[2]))
    return argv[0];
  else {
    type = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
    type->type = ffi_type_tag;
    type->basetype = (argv[0]);
    type->scheme_to_c = (argv[1]);
    type->c_to_scheme = (argv[2]);
    scheme_end_stubborn_change(type);
    return (Scheme_Object*)type;
  }
  return NULL; /* shush the compiler */
}

/* (make-ffi-struct-type types) -> ffi-type */
/* This creates a new primitive type that is a struct.  This type can be used
 * with ffi-ptr objects, except that the contents is used rather than the
 * pointer value.  Marshaling to lists or whatever should be done in Scheme. */
#undef MYNAME
#define MYNAME "make-ffi-struct-type"
static Scheme_Object *FP_make_ffi_struct_type(int argc, Scheme_Object *argv[])
{
  Scheme_Object *p, *base;
  ffi_type **elements;
  ffi_type *libffi_type, **dummy;
  ffi_type_struct *type;
  ffi_cif cif;
  int i, nargs = scheme_proper_list_length(argv[0]);
  if (nargs < 0)
    scheme_wrong_type(MYNAME, "proper list", 0, argc, argv);
  /* allocate the type elements */
  elements = scheme_malloc_stubborn((nargs+1) * sizeof(ffi_type*));
  elements[nargs] = NULL;
  for (i=0, p=argv[0]; i<nargs; i++, p=SCHEME_CDR(p)) {
    if (NULL == (base = ffi_base_ctype(SCHEME_CAR(p))))
      scheme_wrong_type(MYNAME, "list-of-C-types", 0, argc, argv);
    if (FFITYPE_PRIMLABEL(base) == FFI_void)
      scheme_wrong_type(MYNAME, "list-of-non-void-C-types", 0, argc, argv);
    elements[i] = FFITYPE_PRIMTYPE(base);
  }
  scheme_end_stubborn_change(elements);
  /* allocate the new libffi type object */
  libffi_type = scheme_malloc_stubborn(sizeof(ffi_type));
  libffi_type->size      = 0;
  libffi_type->alignment = 0;
  libffi_type->type      = FFI_TYPE_STRUCT;
  libffi_type->elements  = elements;
  /* use ffi_prep_cif to set the size and alignment information */
  dummy = &libffi_type;
  if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ffi_type_void, dummy) != FFI_OK)
    scheme_signal_error("internal error: ffi_prep_cif did not return FFI_OK");
  scheme_end_stubborn_change(libffi_type);
  type = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  type->type = ffi_type_tag;
  type->basetype = (NULL);
  type->scheme_to_c = ((Scheme_Object*)libffi_type);
  type->c_to_scheme = ((Scheme_Object*)FFI_struct);
  scheme_end_stubborn_change(type);
  return (Scheme_Object*)type;
}

/*****************************************************************************/
/* Pointer objects */

/* ffi-ptr structure definition */
static Scheme_Type ffi_ptr_tag;
typedef struct ffi_ptr_struct {
  Scheme_Type type;
  void* ptr;
} ffi_ptr_struct;
#define SCHEME_FFIPTRP(x) (SCHEME_TYPE(x)==ffi_ptr_tag)
#undef MYNAME
#define MYNAME "ffi-ptr?"
static Scheme_Object *FP_ffi_ptr_p(int argc, Scheme_Object *argv[])
{ return SCHEME_FFIPTRP(argv[0]) ? scheme_true : scheme_false; }

#define SCHEME_FFIANYPTRP(x) \
  (SCHEME_FALSEP(x)||SCHEME_FFIPTRP(x)||SCHEME_FFIOBJP(x)||SCHEME_STRINGP(x))
#define SCHEME_FFIANYPTR_VAL(x) \
  (SCHEME_FALSEP(x)?NULL: \
    (SCHEME_FFIPTRP(x)?(((ffi_ptr_struct*)x)->ptr): \
      (SCHEME_FFIOBJP(x)?(((ffi_obj_struct*)x)->obj): \
       SCHEME_STR_VAL(x))))

/* Not a user-level function */
static Scheme_Object *ffi_make_ptr(void* p)
{
  ffi_ptr_struct *ptr;
  if (p == NULL) return scheme_false;
  ptr = (ffi_ptr_struct*)scheme_malloc_stubborn(sizeof(ffi_ptr_struct));
  ptr->type = ffi_ptr_tag;
  ptr->ptr = (p);
  scheme_end_stubborn_change(ptr);
  return (Scheme_Object*)ptr;
}
#define scheme_make_ffiptr(x) \
  ((x==NULL)?scheme_false:ffi_make_ptr(x))

/*****************************************************************************/
/* Callback type */

/* ffi-callback structure definition */
static Scheme_Type ffi_callback_tag;
typedef struct ffi_callback_struct {
  Scheme_Type type;
  void* callback;
  Scheme_Object* proc;
  Scheme_Object* itypes;
  Scheme_Object* otype;
} ffi_callback_struct;
#define SCHEME_FFICALLBACKP(x) (SCHEME_TYPE(x)==ffi_callback_tag)
#undef MYNAME
#define MYNAME "ffi-callback?"
static Scheme_Object *FP_ffi_callback_p(int argc, Scheme_Object *argv[])
{ return SCHEME_FFICALLBACKP(argv[0]) ? scheme_true : scheme_false; }

/*****************************************************************************/
/* Scheme<-->C conversions */

static Scheme_Object *ffi_c_to_scheme(Scheme_Object *type, void *src)
{
  Scheme_Object *res, *base;
  if (!SCHEME_FFITYPEP(type))
    scheme_raise_exn
      (MZEXN_APPLICATION_TYPE, type, scheme_intern_symbol("C-type"),
       "C->Scheme: expected C-type, given: %V", type);
  base = FFITYPE_BASETYPE(type);
  if (base != NULL) {
    res = ffi_c_to_scheme(base, src);
    if (SCHEME_FALSEP(FFITYPE_USER_C2S(type)))
      return res;
    else
      return _scheme_apply(FFITYPE_USER_C2S(type), 1, (Scheme_Object**)(&res));
  } else if (FFITYPE_PRIMLABEL(type) == FFI_fmark) {
    return (Scheme_Object*)src;
  } else switch (FFITYPE_PRIMLABEL(type)) {
    case FFI_void: return scheme_void;
    case FFI_int8: return scheme_make_integer(((int8_t*)src)[0]);
    case FFI_uint8: return scheme_make_integer_from_unsigned(((uint8_t*)src)[0]);
    case FFI_int16: return scheme_make_integer(((int16_t*)src)[0]);
    case FFI_uint16: return scheme_make_integer_from_unsigned(((uint16_t*)src)[0]);
    case FFI_int32: return scheme_make_realinteger_value(((int32_t*)src)[0]);
    case FFI_uint32: return scheme_make_realinteger_value_from_unsigned(((unsigned int*)src)[0]);
    case FFI_fixint: return scheme_make_integer(((int32_t*)src)[0]);
    case FFI_ufixint: return scheme_make_integer_from_unsigned(((uint32_t*)src)[0]);
    case FFI_long: return scheme_make_integer_value(((long*)src)[0]);
    case FFI_ulong: return scheme_make_integer_value_from_unsigned(((unsigned long*)src)[0]);
    case FFI_fixnum: return scheme_make_integer(((long*)src)[0]);
    case FFI_ufixnum: return scheme_make_integer_from_unsigned(((unsigned long*)src)[0]);
    case FFI_float: return scheme_make_float(((float*)src)[0]);
    case FFI_double: return scheme_make_double(((double*)src)[0]);
    case FFI_bool: return (((int*)src)[0]?scheme_true:scheme_false);
    case FFI_string: return (((char**)src)[0]==NULL)?scheme_false:scheme_make_string_without_copying(((char**)src)[0]);
    case FFI_pointer: return scheme_make_ffiptr(((void**)src)[0]);
    case FFI_scheme: return ((Scheme_Object**)src)[0];
    case FFI_fmark: return scheme_void;
    case FFI_struct: return scheme_make_ffiptr(src); /* !!! */
    default: scheme_signal_error("corrupt ffi type: %V", type);
  }
  return NULL; /* shush the compiler */
}

/* Usually writes the C object to dst and returns NULL.  When copy_structs is 0
 * (false) and the type is a struct, then return a pointer to the struct
 * object (not touching dst). */
static void* ffi_scheme_to_c(Scheme_Object *type, void *dst,
                             Scheme_Object *val, int copy_structs)
{
  if (!SCHEME_FFITYPEP(type))
    scheme_raise_exn
      (MZEXN_APPLICATION_TYPE, type, scheme_intern_symbol("C-type"),
       "Scheme->C: expected C-type, given: %V", type);
  while (FFITYPE_USERP(type)) {
    if (!SCHEME_FALSEP(FFITYPE_USER_S2C(type)))
      val = _scheme_apply(FFITYPE_USER_S2C(type), 1, (Scheme_Object**)(&val));
    type = FFITYPE_BASETYPE(type);
  }
  if (FFITYPE_PRIMLABEL(type) == FFI_fmark) {
    if (SCHEME_FFICALLBACKP(val))
      ((void**)dst)[0] = ((ffi_callback_struct*)val)->callback;
    else if (SCHEME_FFIPTRP(val))
      ((void**)dst)[0] = ((void**)dst)[0];
    else if (SCHEME_FFIOBJP(val))
      ((void**)dst)[0] = ((ffi_obj_struct*)val)->obj;
    else /* ((void**)dst)[0] = val; */
         scheme_raise_exn(MZEXN_APPLICATION_TYPE, type,
                          scheme_intern_symbol("C-function-value"),
                          "Scheme->C: expected some function value "
                          "(callout/callback), given: %V",
                          type);
  } else switch (FFITYPE_PRIMLABEL(type)) {
    case FFI_void:
      scheme_raise_exn(MZEXN_APPLICATION_TYPE, type, scheme_intern_symbol("non-void-C-type"), "Scheme->C: expected non-void-C-type, given: %V", type);
    case FFI_int8:
      if (SCHEME_INTP(val)) (((int8_t*)dst)[0]) = (int8_t)(SCHEME_INT_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("int8"), "Scheme->C: expected int8, given: %V", val);
      return NULL;
    case FFI_uint8:
      if (SCHEME_INTP(val)) (((uint8_t*)dst)[0]) = (uint8_t)(SCHEME_UINT_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("uint8"), "Scheme->C: expected uint8, given: %V", val);
      return NULL;
    case FFI_int16:
      if (SCHEME_INTP(val)) (((int16_t*)dst)[0]) = (int16_t)(SCHEME_INT_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("int16"), "Scheme->C: expected int16, given: %V", val);
      return NULL;
    case FFI_uint16:
      if (SCHEME_INTP(val)) (((uint16_t*)dst)[0]) = (uint16_t)(SCHEME_UINT_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("uint16"), "Scheme->C: expected uint16, given: %V", val);
      return NULL;
    case FFI_int32:
      if (!(scheme_get_realint_val(val,&(((int32_t*)dst)[0])))) scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("int32"), "Scheme->C: expected int32, given: %V", val);
      return NULL;
    case FFI_uint32:
      if (!(scheme_get_unsigned_realint_val(val,&(((unsigned int*)dst)[0])))) scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("uint32"), "Scheme->C: expected uint32, given: %V", val);
      return NULL;
    case FFI_fixint:
      if (SCHEME_INTP(val)) (((int32_t*)dst)[0]) = (int32_t)(SCHEME_INT_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("fixint"), "Scheme->C: expected fixint, given: %V", val);
      return NULL;
    case FFI_ufixint:
      if (SCHEME_INTP(val)) (((uint32_t*)dst)[0]) = (uint32_t)(SCHEME_UINT_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("ufixint"), "Scheme->C: expected ufixint, given: %V", val);
      return NULL;
    case FFI_long:
      if (!(scheme_get_int_val(val,&(((long*)dst)[0])))) scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("long"), "Scheme->C: expected long, given: %V", val);
      return NULL;
    case FFI_ulong:
      if (!(scheme_get_unsigned_int_val(val,&(((unsigned long*)dst)[0])))) scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("ulong"), "Scheme->C: expected ulong, given: %V", val);
      return NULL;
    case FFI_fixnum:
      if (SCHEME_INTP(val)) (((long*)dst)[0]) = (long)(SCHEME_INT_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("fixnum"), "Scheme->C: expected fixnum, given: %V", val);
      return NULL;
    case FFI_ufixnum:
      if (SCHEME_INTP(val)) (((unsigned long*)dst)[0]) = (unsigned long)(SCHEME_UINT_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("ufixnum"), "Scheme->C: expected ufixnum, given: %V", val);
      return NULL;
    case FFI_float:
      if (SCHEME_FLTP(val)) (((float*)dst)[0]) = (float)(SCHEME_FLT_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("float"), "Scheme->C: expected float, given: %V", val);
      return NULL;
    case FFI_double:
      if (SCHEME_DBLP(val)) (((double*)dst)[0]) = (double)(SCHEME_DBL_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("double"), "Scheme->C: expected double, given: %V", val);
      return NULL;
    case FFI_bool:
      if (1) (((int*)dst)[0]) = (int)(SCHEME_TRUEP(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("bool"), "Scheme->C: expected bool, given: %V", val);
      return NULL;
    case FFI_string:
      if (SCHEME_FALSEP(val)||SCHEME_STRINGP(val)) (((char**)dst)[0]) = (char*)(SCHEME_FALSEP(val)?NULL:SCHEME_STR_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("string"), "Scheme->C: expected string, given: %V", val);
      return NULL;
    case FFI_pointer:
      if (SCHEME_FFIANYPTRP(val)) (((void**)dst)[0]) = (void*)(SCHEME_FFIANYPTR_VAL(val));
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("pointer"), "Scheme->C: expected pointer, given: %V", val);
      return NULL;
    case FFI_scheme:
      if (1) (((Scheme_Object**)dst)[0]) = (Scheme_Object*)(val);
      else scheme_raise_exn(MZEXN_APPLICATION_TYPE, val, scheme_intern_symbol("scheme"), "Scheme->C: expected scheme, given: %V", val);
      return NULL;
    case FFI_fmark:
      scheme_raise_exn(MZEXN_APPLICATION_TYPE, type, scheme_intern_symbol("non-void-C-type"), "Scheme->C: expected non-void-C-type, given: %V", type);
    case FFI_struct: /* !!! */
      if (!SCHEME_FFIANYPTRP(val))
        scheme_raise_exn(MZEXN_APPLICATION_TYPE, val,
                         scheme_intern_symbol("pointer"),
                         "Scheme->C: expected struct pointer, given: %V",
                         val);
      if (copy_structs) {
        memcpy(dst, SCHEME_FFIANYPTR_VAL(val), FFITYPE_PRIMTYPE(type)->size);
        return NULL;
      } else {
        return SCHEME_FFIANYPTR_VAL(val);
      }
    default: scheme_signal_error("corrupt ffi type: %V", type);
  }
  return NULL; /* shush the compiler */
}

/*****************************************************************************/
/* Pointer type user functions */

/* (ffi-sizeof type) -> int, returns 0 for void, error if not a C type */
#undef MYNAME
#define MYNAME "ffi-sizeof"
static Scheme_Object *FP_ffi_sizeof(int argc, Scheme_Object *argv[])
{
  int size = ffi_sizeof(argv[0]);
  if (size >= 0) return scheme_make_integer(size);
  else scheme_wrong_type(MYNAME, "C-type", 0, argc, argv);
  return NULL; /* shush the compiler */
}

/* (ffi-alignof type) -> int, returns 0 for void, error if not a C type */
#undef MYNAME
#define MYNAME "ffi-alignof"
static Scheme_Object *FP_ffi_alignof(int argc, Scheme_Object *argv[])
{
  Scheme_Object *type = ffi_base_ctype(argv[0]);
  if (type == NULL) scheme_wrong_type(MYNAME, "C-type", 0, argc, argv);
  else return scheme_make_integer(FFITYPE_PRIMTYPE(type)->alignment);
  return NULL; /* shush the compiler */
}

static Scheme_Object *atomic_sym;
static Scheme_Object *stubborn_sym;
static Scheme_Object *uncollectable_sym;
static Scheme_Object *eternal_sym;

/* (ffi-malloc num type ffi-ptr flag) -> pointer */
/* The arguments for this function are:
 * - num: bytes to allocate, or the number of instances of type when given,
 * - type: malloc the size of this type (or num instances of it),
 * - ffi-ptr: a source pointer to copy contents from,
 * - mode: a symbol for different allocation functions to use - one of
 *   'atomic, 'stubborn, 'uncollectable, 'eternal
 * The arguments can be specified in any order at all since they are all
 * different types, the only requirement is for a size, either a number of
 * bytes or a type. */
#undef MYNAME
#define MYNAME "ffi-malloc"
static Scheme_Object *FP_ffi_malloc(int argc, Scheme_Object *argv[])
{
  int i, size=0, num=0;
  void *from = NULL, *res;
  Scheme_Object *mode = NULL, *a;
  for (i=0; i<argc; i++) {
    a = argv[i];
    if (SCHEME_INTP(a)) {
      if (num != 0)
        scheme_signal_error(MYNAME": specifying a second integer size: %V", a);
      num = SCHEME_INT_VAL(a);
      if (num <= 0)
        scheme_wrong_type(MYNAME, "positive-integer", 0, argc, argv);
    } else if (SCHEME_FFITYPEP(a)) {
      if (size != 0)
        scheme_signal_error(MYNAME": specifying a second type: %V", a);
      size = ffi_sizeof(a);
      if (size < 0)
        scheme_wrong_type(MYNAME, "C-type", i, argc, argv);
      else if (size == 0)
        scheme_wrong_type(MYNAME, "non-void-C-type", i, argc, argv);
    } else if (SCHEME_SYMBOLP(a)) {
      if (mode != NULL)
        scheme_signal_error(MYNAME": specifying a second mode symbol: %V", a);
      mode = a;
    } else if (SCHEME_FFIANYPTRP(a) && !SCHEME_FALSEP(a)) {
      if (from != NULL)
        scheme_signal_error(MYNAME": specifying a second source pointer: %V",
                            a);
      from = SCHEME_FFIANYPTR_VAL(a);
    } else {
      scheme_wrong_type(MYNAME, "ffi-malloc-argument", i, argc, argv);
    }
  }
  if ((num == 0) && (size == 0)) scheme_signal_error(MYNAME": no size given");
  size = ((size==0) ? 1 : size) * ((num==0) ? 1 : num);
  if (mode == NULL)                      res = scheme_malloc(size);
  else if (SAME_OBJ(mode, atomic_sym))   res = scheme_malloc_atomic(size);
  else if (SAME_OBJ(mode, stubborn_sym)) res = scheme_malloc_stubborn(size);
  else if (SAME_OBJ(mode, eternal_sym))  res = scheme_malloc_eternal(size);
  /* else if (SAME_OBJ(mode, uncollectable_sym)) */
  /*   res = scheme_malloc_uncollectable(size); */
  else scheme_signal_error(MYNAME": bad allocation mode: %V", mode);
  if ((from != NULL) && (res != NULL)) memcpy(res, from, size);
  return scheme_make_ffiptr(res);
}

/* (ffi-end-stubborn-change ptr) */
#undef MYNAME
#define MYNAME "ffi-end-stubborn-change"
static Scheme_Object *FP_ffi_end_stubborn_change(int argc, Scheme_Object *argv[])
{
  void *ptr;
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-ptr", 0, argc, argv);
  ptr = SCHEME_FFIANYPTR_VAL(argv[0]);
  if (ptr == NULL) scheme_wrong_type(MYNAME, "non-null-ptr", 0, argc, argv);
  scheme_end_stubborn_change(ptr);
  return scheme_void;
}

static Scheme_Object *abs_sym;

/* (ptr-ref ffi-ptr type [[abs] n]) -> the object at the given location */
/* n defaults to 0 which is the only value that should be used with ffi_objs */
/* if n is given, an 'abs flag can precede it to make n be a byte offset rather
 * than some multiple of sizeof(type). */
/* WARNING: there are *NO* checks at all, this is raw C level code. */
#undef MYNAME
#define MYNAME "ptr-ref"
static Scheme_Object *FP_ptr_ref(int argc, Scheme_Object *argv[])
{
  int size; void *ptr; Scheme_Object *base;
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-ptr", 0, argc, argv);
  ptr = SCHEME_FFIANYPTR_VAL(argv[0]);
  if (ptr == NULL)
    scheme_wrong_type(MYNAME, "non-null-ptr", 0, argc, argv);
  if (NULL == (base = ffi_base_ctype(argv[1])))
    scheme_wrong_type(MYNAME, "C-type", 1, argc, argv);
  else size = ffi_sizeof(base);
  if (FFITYPE_PRIMLABEL(base) == FFI_fmark) {
    if (argc > 2)
      scheme_signal_error
        (MYNAME": referencing a special value with extra arguments");
    else
      ptr = argv[0];
  } else if (size < 0) {
    /* should not happen */
    scheme_wrong_type(MYNAME, "C-type", 1, argc, argv);
  } else if (size == 0) {
    scheme_wrong_type(MYNAME, "non-void-C-type", 1, argc, argv);
  } else if (argc > 3) {
    if (!SAME_OBJ(argv[2],abs_sym))
      scheme_wrong_type(MYNAME, "abs-flag", 2, argc, argv);
    if (!SCHEME_INTP(argv[3]))
      scheme_wrong_type(MYNAME, "integer", 3, argc, argv);
    (char*)ptr += SCHEME_INT_VAL(argv[3]);
  } else if (argc > 2) {
    if (!SCHEME_INTP(argv[2]))
      scheme_wrong_type(MYNAME, "integer", 2, argc, argv);
    (char*)ptr += size * SCHEME_INT_VAL(argv[2]);
  }
  return ffi_c_to_scheme(argv[1], ptr);
}

/* (ptr-set! ffi-ptr type [[abs] n] value) -> void */
/* n defaults to 0 which is the only value that should be used with ffi_objs */
/* if n is given, an 'abs flag can precede it to make n be a byte offset rather
 * than some multiple of sizeof(type). */
/* WARNING: there are *NO* checks at all, this is raw C level code. */
#undef MYNAME
#define MYNAME "ptr-set!"
static Scheme_Object *FP_ptr_set(int argc, Scheme_Object *argv[])
{
  int size; void *ptr;
  Scheme_Object *val = argv[argc-1], *base;
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-ptr", 0, argc, argv);
  ptr = SCHEME_FFIANYPTR_VAL(argv[0]);
  if (ptr == NULL)
    scheme_wrong_type(MYNAME, "non-null-ptr", 0, argc, argv);
  if (NULL == (base = ffi_base_ctype(argv[1])))
    scheme_wrong_type(MYNAME, "C-type", 1, argc, argv);
  else size = ffi_sizeof(base);
  if (FFITYPE_PRIMLABEL(base) == FFI_fmark) {
    if (argc > 3) {
      scheme_signal_error
        (MYNAME": referencing a special value with extra arguments");
    } else if (SCHEME_FFIPTRP(argv[0])) {
      ptr = ((ffi_ptr_struct*)(argv[0]))->ptr;
    } else if SCHEME_FFIOBJP(argv[0]) {
      ptr = ((ffi_obj_struct*)(argv[0]))->obj;
    } else {
      scheme_signal_error
        (MYNAME": bad lvalue (NULL or string)");
    }
  } else if (size < 0) {
    /* should not happen */
    scheme_wrong_type(MYNAME, "C-type", 1, argc, argv);
  } else if (size == 0) {
    scheme_wrong_type(MYNAME, "non-void-C-type", 1, argc, argv);
  } else if (argc > 4) {
    if (!SAME_OBJ(argv[2],abs_sym))
      scheme_wrong_type(MYNAME, "abs-flag", 2, argc, argv);
    if (!SCHEME_INTP(argv[3]))
      scheme_wrong_type(MYNAME, "integer", 3, argc, argv);
    (char*)ptr += SCHEME_INT_VAL(argv[3]);
  } else if (argc > 3) {
    if (!SCHEME_INTP(argv[2]))
      scheme_wrong_type(MYNAME, "integer", 2, argc, argv);
    (char*)ptr += size * SCHEME_INT_VAL(argv[2]);
  }
  ffi_scheme_to_c(argv[1], ptr, val, 1);
  return scheme_void;
}

/* (ptr-equal? ffi-ptr ffi-ptr) -> boolean */
#undef MYNAME
#define MYNAME "ptr-equal?"
static Scheme_Object *FP_ptr_equal_p(int argc, Scheme_Object *argv[])
{
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-ptr", 0, argc, argv);
  if (!SCHEME_FFIANYPTRP(argv[1]))
    scheme_wrong_type(MYNAME, "ffi-ptr", 1, argc, argv);
  return (SAME_OBJ(argv[0],argv[1]) ||
          (SCHEME_FFIANYPTR_VAL(argv[0]) == SCHEME_FFIANYPTR_VAL(argv[1])))
         ? scheme_true : scheme_false;
}

/* (make-sized-byte-string ffi-ptr len) */
#undef MYNAME
#define MYNAME "make-sized-byte-string"
static Scheme_Object *FP_make_sized_byte_string(int argc, Scheme_Object *argv[])
/* Warning: no copying is done so it is possible to share string contents. */
/* (Should use real byte-strings with new version.) */
{
  long len;
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-ptr", 0, argc, argv);
  if (!scheme_get_int_val(argv[1],&len))
    scheme_wrong_type(MYNAME, "integer in a C long range", 1, argc, argv);
  if (SCHEME_FALSEP(argv[0])) return scheme_false;
  else return scheme_make_sized_string(SCHEME_FFIANYPTR_VAL(argv[0]), len, 0);
}

/* internal: apply Scheme finalizer */
void ffi_scm_finalizer(void *p, void *finalizer)
{
  Scheme_Object *f = (Scheme_Object*)finalizer;
  if (!SCHEME_FALSEP(f)) _scheme_apply(f, 1, (Scheme_Object**)(&p));
}
void ffi_ptr_finalizer(void *p, void *finalizer)
{
  Scheme_Object *f = (Scheme_Object*)finalizer;
  Scheme_Object *ptr;
  if (p == NULL) return;
  ptr = ffi_make_ptr(p);
  if (!SCHEME_FALSEP(f)) _scheme_apply(f, 1, (Scheme_Object**)(&ptr));
  /* don't leave dangling references! */
  (((ffi_ptr_struct*)ptr)->ptr) = NULL;
  ptr = NULL;
}

static Scheme_Object *pointer_sym;

/* (ffi-register-finalizer ptrobj finalizer [scheme]) -> old-finalizer */
/* The finalizer is called by the primitive finalizer mechanism, make sure */
/* no references to the object are recreated.  #f means erase existing */
/* finalizer if any.*/
/* If two arguments are used, this is used with any Scheme object, and the */
/* finalizer will be called on it.  If a third argument of 'pointer is used, */
/* the object must be an ffi-ptr object, the finalizer will be invoked when */
/* the pointer itself is unreachable, and it will get a new ffi-ptr object */
/* that points to it.  (Only needed in systems where pointer aliases might */
/* be created.) */
#undef MYNAME
#define MYNAME "ffi-register-finalizer"
static Scheme_Object *FP_ffi_register_finalizer(int argc, Scheme_Object *argv[])
{
  void *ptr, *old = NULL;
  int ptrsym = (argc == 3 && argv[2] == pointer_sym);
  if (ptrsym) {
    if (!SCHEME_FFIANYPTRP(argv[0]))
      scheme_wrong_type(MYNAME, "ffi-ptr", 0, argc, argv);
    ptr = SCHEME_FFIANYPTR_VAL(argv[0]);
    if (ptr == NULL)
      scheme_wrong_type(MYNAME, "non-null-ptr", 0, argc, argv);
  } else {
    if (argc == 3)
      scheme_wrong_type(MYNAME, "pointer-mode", 2, argc, argv);
    ptr = argv[0];
  }
  if (!(SCHEME_FALSEP(argv[1]) || SCHEME_PROCP(argv[1])))
    scheme_wrong_type(MYNAME, "procedure-or-false", 1, argc, argv);
  scheme_register_finalizer
    (argv[0], (ptrsym ? ffi_ptr_finalizer : ffi_scm_finalizer),
     argv[1], NULL, &old);
  return (old == NULL) ? scheme_false : (Scheme_Object*)old;
}

/*****************************************************************************/
/* Calling foreign function objects */

Scheme_Object *ffi_do_call(void *data, int argc, Scheme_Object *argv[])
/* data := {name, c-function, itypes, otype, cif} */
{
  char          *name   = SCHEME_STR_VAL(((Scheme_Object**)data)[0]);
  void          *c_func = (void*)(((Scheme_Object**)data)[1]);
  Scheme_Object *itypes = ((Scheme_Object**)data)[2];
  Scheme_Object *otype  = ((Scheme_Object**)data)[3];
  Scheme_Object *base;
  ffi_cif       *cif    = (ffi_cif*)(((Scheme_Object**)data)[4]);
  int           nargs   = cif->nargs;
  FFIAny oval, *ival/* !!! ival[nargs] */;
  void **avalues/* !!! *avalues[nargs] */, *p;
  int i;
  ival    = scheme_malloc(nargs*sizeof(FFIAny));
  avalues = scheme_malloc(nargs*sizeof(void*));
  /* iterate on input values and types */
  for (i=0; i<nargs; i++, itypes=SCHEME_CDR(itypes)) {
    /* convert argv[i] according to current itype */
    p = ffi_scheme_to_c(SCHEME_CAR(itypes), &(ival[i]), argv[i], 0);
    /* Establish links from avalues to the actual ivals */
    avalues[i] = (p == NULL) ? (&(ival[i])) : p;
  }
  base = ffi_base_ctype(otype); /* verified below, so cannot be NULL */
  /* If this is a struct return value, then need to malloc in any case, even if
   * the size is smaller than FFIAny, because this value will be returned. */
  p = (FFITYPE_PRIMLABEL(base) == FFI_struct)
        ? scheme_malloc(FFITYPE_PRIMTYPE(base)->size)
        : &oval;
  /* call the function */
  ffi_call(cif, c_func, p, avalues);
  if (FFITYPE_PRIMLABEL(base) == FFI_fmark) {
    /* need to allocate a pointer */
    return ffi_c_to_scheme(otype, scheme_make_ffiptr(oval.x_pointer));
  } else {
    return ffi_c_to_scheme(otype, p);
  }
}

/* (ffi-call ffi-obj in-types out-type) -> (in-types -> out-value) */
/* the real work is done by ffi_do_call above */
#undef MYNAME
#define MYNAME "ffi-call"
static Scheme_Object *FP_ffi_call(int argc, Scheme_Object *argv[])
{
  static Scheme_Object *ffi_name_prefix = NULL;
  Scheme_Object *itypes = argv[1];
  Scheme_Object *otype  = argv[2];
  Scheme_Object *obj, **data, *p, *base;
  ffi_type *rtype, **atypes;
  ffi_cif *cif;
  int i, nargs;
  if (!ffi_name_prefix)
    ffi_name_prefix = scheme_make_string_without_copying("ffi:");
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-obj-or-ptr", 0, argc, argv);
  obj = SCHEME_FFIANYPTR_VAL(argv[0]);
  if (obj == NULL)
    scheme_wrong_type(MYNAME, "non-null-ptr", 0, argc, argv);
  nargs = scheme_proper_list_length(itypes);
  if (nargs < 0)
    scheme_wrong_type(MYNAME, "proper list", 1, argc, argv);
  if (NULL == (base = ffi_base_ctype(otype)))
    scheme_wrong_type(MYNAME, "C-type", 2, argc, argv);
  rtype = FFITYPE_PRIMTYPE(base);
  atypes = scheme_malloc_stubborn(nargs * sizeof(ffi_cif));
  for (i=0, p=itypes; i<nargs; i++, p=SCHEME_CDR(p)) {
    if (NULL == (base = ffi_base_ctype(SCHEME_CAR(p))))
      scheme_wrong_type(MYNAME, "list-of-C-types", 1, argc, argv);
    if (FFITYPE_PRIMLABEL(base) == FFI_void)
      scheme_wrong_type(MYNAME, "list-of-non-void-C-types", 1, argc, argv);
    atypes[i] = FFITYPE_PRIMTYPE(base);
  }
  scheme_end_stubborn_change(atypes);
  cif = scheme_malloc_stubborn(sizeof(ffi_cif));
  if (ffi_prep_cif(cif, FFI_DEFAULT_ABI, nargs, rtype, atypes) != FFI_OK)
    scheme_signal_error("internal error: ffi_prep_cif did not return FFI_OK");
  scheme_end_stubborn_change(cif);
  data = scheme_malloc_stubborn(5 * sizeof(void*));
  data[0] = scheme_append_string
              (ffi_name_prefix,
               scheme_make_string_without_copying
                 (SCHEME_FFIOBJP(argv[0]) ?
                   ((ffi_obj_struct*)(argv[0]))->name : "proc"));
  data[1] = obj;
  data[2] = itypes;
  data[3] = otype;
  data[4] = (Scheme_Object*)cif;
  scheme_end_stubborn_change(data);
  return scheme_make_closed_prim_w_arity
           (ffi_do_call, (void*)data, SCHEME_STR_VAL(data[0]), nargs, nargs);
}

/*****************************************************************************/
/* Scheme callbacks */

void ffi_do_callback(ffi_cif* cif, void* resultp, void** args, void *userdata)
{
  ffi_callback_struct *data = (ffi_callback_struct*)userdata;
  int argc = cif->nargs, i;
  Scheme_Object **argv/* !!! *argv[argc] */, *p;
  argv = scheme_malloc(argc*sizeof(Scheme_Object*));
  for (i=0, p=data->itypes; i<argc; i++, p=SCHEME_CDR(p))
    argv[i] = ffi_c_to_scheme(SCHEME_CAR(p),args[i]);
  p = _scheme_apply(data->proc, argc, argv);
  ffi_scheme_to_c(data->otype, resultp, p, 1);
}

/* (ffi-callback scheme-proc in-types out-type) -> ffi-callback */
/* the treatment of in-types and out-types is similar to that in ffi-call */
/* the real work is done by ffi_do_callback above */
#undef MYNAME
#define MYNAME "ffi-callback"
static Scheme_Object *FP_ffi_callback(int argc, Scheme_Object *argv[])
{
  ffi_callback_struct *data;
  Scheme_Object *itypes = argv[1];
  Scheme_Object *otype = argv[2];
  Scheme_Object *p, *base;
  int nargs, i;
  ffi_type *rtype, **atypes;
  ffi_cif *cif;
  ffi_closure *cl;
  if (!SCHEME_PROCP(argv[0]))
    scheme_wrong_type(MYNAME, "procedure", 0, argc, argv);
  nargs = scheme_proper_list_length(itypes);
  if (nargs < 0)
    scheme_wrong_type(MYNAME, "proper list", 1, argc, argv);
  if (NULL == (base = ffi_base_ctype(otype)))
    scheme_wrong_type(MYNAME, "C-type", 2, argc, argv);
  rtype = FFITYPE_PRIMTYPE(base);
  atypes = scheme_malloc_stubborn(nargs * sizeof(ffi_cif));
  for (i=0, p=itypes; i<nargs; i++, p=SCHEME_CDR(p)) {
    if (NULL == (base = ffi_base_ctype(SCHEME_CAR(p))))
      scheme_wrong_type(MYNAME, "list-of-C-types", 1, argc, argv);
    if (FFITYPE_PRIMLABEL(base) == FFI_void)
      scheme_wrong_type(MYNAME, "list-of-non-void-C-types", 1, argc, argv);
    atypes[i] = FFITYPE_PRIMTYPE(base);
  }
  scheme_end_stubborn_change(atypes);
  cif = scheme_malloc_stubborn(sizeof(ffi_cif));
  if (ffi_prep_cif(cif, FFI_DEFAULT_ABI, nargs, rtype, atypes) != FFI_OK)
    scheme_signal_error("internal error: ffi_prep_cif did not return FFI_OK");
  scheme_end_stubborn_change(cif);
  cl = scheme_malloc_stubborn(sizeof(ffi_closure));
  data = (ffi_callback_struct*)scheme_malloc_stubborn(sizeof(ffi_callback_struct));
  data->type = ffi_callback_tag;
  data->callback = (cl);
  data->proc = (argv[0]);
  data->itypes = (argv[1]);
  data->otype = (argv[2]);
  scheme_end_stubborn_change(data);
  if (ffi_prep_closure(cl, cif, &ffi_do_callback, (void*)data) != FFI_OK)
    scheme_signal_error
      ("internal error: ffi_prep_closure did not return FFI_OK");
  scheme_end_stubborn_change(cl);
  return (Scheme_Object*)data;
}

/*****************************************************************************/
/* Initialization */

Scheme_Object *scheme_reload(Scheme_Env *env)
{
  Scheme_Env *menv;
  ffi_type_struct *t;
  menv = scheme_primitive_module(scheme_intern_symbol("ffi-prim"), env);
  scheme_add_global("ffi-lib?",
    scheme_make_prim_w_arity(FP_ffi_lib_p, "ffi-lib?", 1, 1), menv);
  scheme_add_global("ffi-lib",
    scheme_make_prim_w_arity(FP_ffi_lib, "ffi-lib", 1, 1), menv);
  scheme_add_global("ffi-lib-name",
    scheme_make_prim_w_arity(FP_ffi_lib_name, "ffi-lib-name", 1, 1), menv);
  scheme_add_global("ffi-obj?",
    scheme_make_prim_w_arity(FP_ffi_obj_p, "ffi-obj?", 1, 1), menv);
  scheme_add_global("ffi-obj",
    scheme_make_prim_w_arity(FP_ffi_obj, "ffi-obj", 2, 2), menv);
  scheme_add_global("ffi-obj-lib",
    scheme_make_prim_w_arity(FP_ffi_obj_lib, "ffi-obj-lib", 1, 1), menv);
  scheme_add_global("ffi-obj-name",
    scheme_make_prim_w_arity(FP_ffi_obj_name, "ffi-obj-name", 1, 1), menv);
  scheme_add_global("ffi-type?",
    scheme_make_prim_w_arity(FP_ffi_type_p, "ffi-type?", 1, 1), menv);
  scheme_add_global("ffi-type-basetype",
    scheme_make_prim_w_arity(FP_ffi_type_basetype, "ffi-type-basetype", 1, 1), menv);
  scheme_add_global("ffi-type-scheme->c",
    scheme_make_prim_w_arity(FP_ffi_type_scheme2c, "ffi-type-scheme->c", 1, 1), menv);
  scheme_add_global("ffi-type-c->scheme",
    scheme_make_prim_w_arity(FP_ffi_type_c2scheme, "ffi-type-c->scheme", 1, 1), menv);
  scheme_add_global("make-ffi-type",
    scheme_make_prim_w_arity(FP_make_ffi_type, "make-ffi-type", 3, 3), menv);
  scheme_add_global("make-ffi-struct-type",
    scheme_make_prim_w_arity(FP_make_ffi_struct_type, "make-ffi-struct-type", 1, 1), menv);
  scheme_add_global("ffi-ptr?",
    scheme_make_prim_w_arity(FP_ffi_ptr_p, "ffi-ptr?", 1, 1), menv);
  scheme_add_global("ffi-callback?",
    scheme_make_prim_w_arity(FP_ffi_callback_p, "ffi-callback?", 1, 1), menv);
  scheme_add_global("ffi-sizeof",
    scheme_make_prim_w_arity(FP_ffi_sizeof, "ffi-sizeof", 1, 1), menv);
  scheme_add_global("ffi-alignof",
    scheme_make_prim_w_arity(FP_ffi_alignof, "ffi-alignof", 1, 1), menv);
  scheme_add_global("ffi-malloc",
    scheme_make_prim_w_arity(FP_ffi_malloc, "ffi-malloc", 1, 4), menv);
  scheme_add_global("ffi-end-stubborn-change",
    scheme_make_prim_w_arity(FP_ffi_end_stubborn_change, "ffi-end-stubborn-change", 1, 1), menv);
  scheme_add_global("ptr-ref",
    scheme_make_prim_w_arity(FP_ptr_ref, "ptr-ref", 2, 4), menv);
  scheme_add_global("ptr-set!",
    scheme_make_prim_w_arity(FP_ptr_set, "ptr-set!", 3, 5), menv);
  scheme_add_global("ptr-equal?",
    scheme_make_prim_w_arity(FP_ptr_equal_p, "ptr-equal?", 2, 2), menv);
  scheme_add_global("make-sized-byte-string",
    scheme_make_prim_w_arity(FP_make_sized_byte_string, "make-sized-byte-string", 2, 2), menv);
  scheme_add_global("ffi-register-finalizer",
    scheme_make_prim_w_arity(FP_ffi_register_finalizer, "ffi-register-finalizer", 2, 3), menv);
  scheme_add_global("ffi-call",
    scheme_make_prim_w_arity(FP_ffi_call, "ffi-call", 3, 3), menv);
  scheme_add_global("ffi-callback",
    scheme_make_prim_w_arity(FP_ffi_callback, "ffi-callback", 3, 3), menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_void));
  t->c_to_scheme = ((Scheme_Object*)FFI_void);
  scheme_end_stubborn_change(t);
  scheme_add_global("_void", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_sint8));
  t->c_to_scheme = ((Scheme_Object*)FFI_int8);
  scheme_end_stubborn_change(t);
  scheme_add_global("_int8", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_uint8));
  t->c_to_scheme = ((Scheme_Object*)FFI_uint8);
  scheme_end_stubborn_change(t);
  scheme_add_global("_uint8", (Scheme_Object*)t, menv);
  scheme_add_global("_byte", scheme_lookup_global(scheme_intern_symbol("_uint8"),menv), menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_sint16));
  t->c_to_scheme = ((Scheme_Object*)FFI_int16);
  scheme_end_stubborn_change(t);
  scheme_add_global("_int16", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_uint16));
  t->c_to_scheme = ((Scheme_Object*)FFI_uint16);
  scheme_end_stubborn_change(t);
  scheme_add_global("_uint16", (Scheme_Object*)t, menv);
  scheme_add_global("_word", scheme_lookup_global(scheme_intern_symbol("_uint16"),menv), menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_sint32));
  t->c_to_scheme = ((Scheme_Object*)FFI_int32);
  scheme_end_stubborn_change(t);
  scheme_add_global("_int32", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_uint32));
  t->c_to_scheme = ((Scheme_Object*)FFI_uint32);
  scheme_end_stubborn_change(t);
  scheme_add_global("_uint32", (Scheme_Object*)t, menv);
  scheme_add_global("_int", scheme_lookup_global(scheme_intern_symbol("_int32"),menv), menv);
  scheme_add_global("_uint", scheme_lookup_global(scheme_intern_symbol("_uint32"),menv), menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_sint32));
  t->c_to_scheme = ((Scheme_Object*)FFI_fixint);
  scheme_end_stubborn_change(t);
  scheme_add_global("_fixint", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_uint32));
  t->c_to_scheme = ((Scheme_Object*)FFI_ufixint);
  scheme_end_stubborn_change(t);
  scheme_add_global("_ufixint", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_smzlong));
  t->c_to_scheme = ((Scheme_Object*)FFI_long);
  scheme_end_stubborn_change(t);
  scheme_add_global("_long", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_umzlong));
  t->c_to_scheme = ((Scheme_Object*)FFI_ulong);
  scheme_end_stubborn_change(t);
  scheme_add_global("_ulong", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_smzlong));
  t->c_to_scheme = ((Scheme_Object*)FFI_fixnum);
  scheme_end_stubborn_change(t);
  scheme_add_global("_fixnum", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_umzlong));
  t->c_to_scheme = ((Scheme_Object*)FFI_ufixnum);
  scheme_end_stubborn_change(t);
  scheme_add_global("_ufixnum", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_float));
  t->c_to_scheme = ((Scheme_Object*)FFI_float);
  scheme_end_stubborn_change(t);
  scheme_add_global("_float", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_double));
  t->c_to_scheme = ((Scheme_Object*)FFI_double);
  scheme_end_stubborn_change(t);
  scheme_add_global("_double", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_sint));
  t->c_to_scheme = ((Scheme_Object*)FFI_bool);
  scheme_end_stubborn_change(t);
  scheme_add_global("_bool", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_pointer));
  t->c_to_scheme = ((Scheme_Object*)FFI_string);
  scheme_end_stubborn_change(t);
  scheme_add_global("_string", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_pointer));
  t->c_to_scheme = ((Scheme_Object*)FFI_pointer);
  scheme_end_stubborn_change(t);
  scheme_add_global("_pointer", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_pointer));
  t->c_to_scheme = ((Scheme_Object*)FFI_scheme);
  scheme_end_stubborn_change(t);
  scheme_add_global("_scheme", (Scheme_Object*)t, menv);
  t = (ffi_type_struct*)scheme_malloc_stubborn(sizeof(ffi_type_struct));
  t->type = ffi_type_tag;
  t->basetype = (NULL);
  t->scheme_to_c = ((Scheme_Object*)(&ffi_type_pointer));
  t->c_to_scheme = ((Scheme_Object*)FFI_fmark);
  scheme_end_stubborn_change(t);
  scheme_add_global("_fmark", (Scheme_Object*)t, menv);
  scheme_finish_primitive_module(menv);
  return scheme_void;
}

Scheme_Object *scheme_initialize(Scheme_Env *env)
{
  ffi_lib_tag = scheme_make_type("<ffi-lib>");
  ffi_obj_tag = scheme_make_type("<ffi-obj>");
  ffi_type_tag = scheme_make_type("<ffi-type>");
  ffi_ptr_tag = scheme_make_type("<ffi-ptr>");
  ffi_callback_tag = scheme_make_type("<ffi-callback>");
  opened_libs = scheme_make_hash_table(SCHEME_hash_string);
  /* scheme_register_extension_global should change to MZ_REGISTER_STATIC when
   * the code moves into mzscheme. */
  scheme_register_extension_global(&opened_libs, sizeof(opened_libs));
  atomic_sym = scheme_intern_symbol("atomic");
  scheme_register_extension_global(atomic_sym,sizeof(atomic_sym));
  stubborn_sym = scheme_intern_symbol("stubborn");
  scheme_register_extension_global(stubborn_sym,sizeof(stubborn_sym));
  uncollectable_sym = scheme_intern_symbol("uncollectable");
  scheme_register_extension_global(uncollectable_sym,sizeof(uncollectable_sym));
  eternal_sym = scheme_intern_symbol("eternal");
  scheme_register_extension_global(eternal_sym,sizeof(eternal_sym));
  abs_sym = scheme_intern_symbol("abs");
  scheme_register_extension_global(abs_sym,sizeof(abs_sym));
  pointer_sym = scheme_intern_symbol("pointer");
  scheme_register_extension_global(pointer_sym,sizeof(pointer_sym));
  return scheme_reload(env);
}

Scheme_Object *scheme_module_name()
{
  return scheme_intern_symbol("ffi-prim");
}

/*****************************************************************************/
