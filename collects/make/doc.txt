
make.ss
-------

>INDEX: "make"

The "make.ss" library in the "make" collection provides a `make' macro
and a `make/proc' procedure.

> (make ((target (depend ...) command ...) ...) argv)

expands to

  (make/proc
    (list (list target (list depend ...) (lambda () command ...)) ...)
    argv)

> (make/proc spec argv) performs a make according to `spec' and using
`argv' as command-line arguments selecting one or more targets.
`argv' can either be a string or a vector of strings.

`spec' is a MAKE-SPEC:

  MAKE-SPEC = (list-of MAKE-LINE)
  MAKE-LINE = (list TARGET (list-of DEPEND-STRING) COMMAND-THUNK)
  TARGET = (union string (list-of string)) ; either a string or a list of strings
  DEPEND-STRING = string
  COMMAND-THUNK = (-> void)

To make a target, make/proc is first called on each of the target's
dependencies. If a target is not in the spec and it exists, then the
target is considered made. If a target is older than any of its
dependencies, the corresponding COMMAND-THUNK is invoked. The
COMMAND-THUNK is optional; a MAKE-LINE without a COMMAND-THUNK is
useful as a target for making a number of other targets (the
dependencies).

`make/proc' catches any exceptions raised by a COMMAND-THUNK and wraps them
in an exn:make structure, and raises the wrapped exn. exn:make structures
are defined with:

  (define-struct (exn:make struct:exn) (target orig-exn))

The `target' field is a string or a list of strings naming the target(s),
and the `orig-exn' field is the original exception.

The maker.ss library is a signed unit that requires no imports
and provdes `make/proc'.

make.ss also provides the following parameters:

> (make-print-checking [on?]) - If #f, make only prints when it is
making a target. Otherwise, it prints when it is checking the
dependancies of a target. Defaultly #t.

> (make-print-dep-no-line [on?]) - If #f, make only prints "checking..."
lines for dependancies that have a corresponding make line.  Defaultly
#f.

> (make-print-reasons [on?]) If #t, make prints the reason for each
dependancy that fires. Defaultly #t.

collection.ss
-------------

>INDEX: "collections, compiling"

The "collection.ss" library in the "make" collection provides a
`make-collection' procedure.

> (make-collection collection-name et-expr collection-files argv)
constructs and performs a make to compile a collection of Scheme files
into a multi-file extension. `collection-name' is used as a name that
is embedded into publicly visible names in the extension (choosing a
unique `collection-name' for each extension helps avoid conflicts
among different extensions for certain operating systems). The
`et-expr' expression is used as an ealboration-time initialization
expression for the compiler. `collection-files' is a list of Scheme
source files to be compiled. `argv' is passed on to `make'.

The resulting extension "_loader" is compiled to the current
directory's "compiled/native/PLATFORM" subdirectory, where `PLATFORM'
is replaced by the system name of the current platform. Intermediate
.c amd .kp files are placed into "compiled/native", and intermediate
object files are also placed into "compiled/native/PLATFORM".  The .c
and .kp files are preserved so that thay can be generated once for
compiling across multiple platforms with the same filesystem.

Make rules are also generated for compiling .zo files, placed in the
"compiled" directory. The make target "zo" makes all of the .zo
files. (In other words, pass #("zo") as `argv' to compile .zo files.)

The "compiled", "compiled/native", etc. directories are automatically
created if they do not already exist. Currently, `make-collection'
does not try to infer sophisticated file dependencies. Each .c/.kp/.zo
is dependent just on the .ss source file, each object file is depend
only on its .c file, and the extension is dependent only on the
object files.
