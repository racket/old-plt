% Statement rules
\newlength{\tw}
\newlength{\len}

\rulesection{stmt}
\label{stmtb}
\begin{tabular}{lcl}
{\bf \verb+<+stmt\verb+>+} & ::=  & {\bf \verb+<+simple\_stmt~\ref{simplezzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+compound\_stmt~\ref{compoundzzzstmtb}\verb+>+}  \\
\end{tabular} \\

Simple statements (\ref{simplezzzstmtb}) span a single line (no new indentation levels).  Compound statements (\ref{compoundzzzstmtb}) may span multiple lines. \\

\rulesection{simple\_stmt}
\label{simplezzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+simple\_stmt\verb+>+} & ::=  & {\bf \verb+<+small\_stmt~\ref{smallzzzstmtb}\verb+>+}  NEWLINE \\
 & \verb+|+  & {\bf \verb+<+small\_stmt~\ref{smallzzzstmtb}\verb+>+}  \verb|;| NEWLINE \\
 & \verb+|+  & {\bf \verb+<+small\_stmt~\ref{smallzzzstmtb}\verb+>+}  \verb|;| {\bf \verb+<+simple\_stmt~\ref{simplezzzstmtb}\verb+>+}  \\
\end{tabular}

\rulesection{small\_stmt}
\label{smallzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+small\_stmt\verb+>+} & ::=  & {\bf \verb+<+expr\_stmt~\ref{exprzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+print\_stmt~\ref{printzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+del\_stmt~\ref{delzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+pass\_stmt~\ref{passzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+flow\_stmt~\ref{flowzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+import\_stmt~\ref{importzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+global\_stmt~\ref{globalzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+exec\_stmt~\ref{execzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+assert\_stmt~\ref{assertzzzstmtb}\verb+>+}  \\
\end{tabular}

\rulesection{expr\_stmt}
\label{exprzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+expr\_stmt\verb+>+} & ::=  & {\bf \verb+<+test~\ref{testb}\verb+>+}  {\bf \verb+<+augassign~\ref{augassignb}\verb+>+}  {\bf \verb+<+tuple\_or\_test~\ref{tuplezzzorzzztestb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+testlist\_list\_plus~\ref{testlistzzzlistzzzplusb}\verb+>+}  \\
\end{tabular} \\

An expression statement consists of either a mutative operation or a {\bf \verb+<+testlist\_list\_plus~\ref{testlistzzzlistzzzplusb}\verb+>+}.

\rulesection{testlist\_list\_plus}
\label{testlistzzzlistzzzplusb}
\begin{tabular}{lcl}
{\bf \verb+<+testlist\_list\_plus\verb+>+} & ::=  & {\bf \verb+<+tuple\_or\_test~\ref{tuplezzzorzzztestb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+tuple\_or\_test~\ref{tuplezzzorzzztestb}\verb+>+}  \verb|=| {\bf \verb+<+testlist\_list\_plus~\ref{testlistzzzlistzzzplusb}\verb+>+}  \\
\end{tabular} \\

A \verb|testlist_list_plus| is an assignment or an expression (\ref{tuplezzzorzzztestb}) which will be displayed in the output of the interpreter.

\rulesection{augassign}
\label{augassignb}
\begin{tabular}{lcl}
{\bf \verb+<+augassign\verb+>+} & ::=  & \verb|+=| \\
 & \verb+|+  & \verb|-=| \\
 & \verb+|+  & \verb|*=| \\
 & \verb+|+  & \verb|/=| \\
 & \verb+|+  & \verb|%=| \\
 & \verb+|+  & \verb|&=| \\
 & \verb+|+  & \verb+|=+ \\
 & \verb+|+  & \verb|^=| \\
 & \verb+|+  & \verb|<<=| \\
 & \verb+|+  & \verb|>>=| \\
 & \verb+|+  & \verb|**=| \\
 & \verb+|+  & \verb|//=| \\
\end{tabular}

\rulesection{print\_stmt}
\label{printzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+print\_stmt\verb+>+} & ::=  & print {\bf \verb+<+test\_list~\ref{testzzzlistb}\verb+>+}  \\
 & \verb+|+  & print \verb|>>| {\bf \verb+<+test\_list~\ref{testzzzlistb}\verb+>+}  \\
\end{tabular} \\

From the Python Reference~\cite{pythonlang}, section 6.6:
\begin{quote}
\verb|print| has an extended form, sometimes referred to as ``print chevron.'' 
In this form, the first expression after the \verb+>>+ must evaluate to a ``file-like'' 
object, specifically an object that has a \verb|write| method, or \verb|None|.
\end{quote}

\rulesection{del\_stmt}
\label{delzzzstmtb}
See the Python Reference~\cite{pythonlang}, section 6.5.

\begin{tabular}{lcl}
{\bf \verb+<+del\_stmt\verb+>+} & ::=  & del {\bf \verb+<+target\_tuple\_or\_expr~\ref{targetzzztuplezzzorzzzexprb}\verb+>+}  \\
\end{tabular}

\rulesection{pass\_stmt}
\label{passzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+pass\_stmt\verb+>+} & ::=  & pass \\
\end{tabular}

\rulesection{flow\_stmt}
\label{flowzzzstmtb}
A flow statement directs or modifies program flow. \\

\begin{tabular}{lcl}
{\bf \verb+<+flow\_stmt\verb+>+} & ::=  & {\bf \verb+<+break\_stmt~\ref{breakzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+continue\_stmt~\ref{continuezzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+return\_stmt~\ref{returnzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+raise\_stmt~\ref{raisezzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+yield\_stmt~\ref{yieldzzzstmtb}\verb+>+}  \\
\end{tabular}

\rulesection{break\_stmt}
\label{breakzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+break\_stmt\verb+>+} & ::=  & break \\
\end{tabular} \\

From the Python reference~\cite{pythonlang}, section 6.10:
\begin{quote}
\verb+break+ may only occur syntactically nested in a for or while loop, 
but not nested in a function or class definition within that loop.
\end{quote}

\rulesection{continue\_stmt}
\label{continuezzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+continue\_stmt\verb+>+} & ::=  & continue \\
\end{tabular} \\

From the Python reference~\cite{pythonlang}, section 6.11:
\begin{quote}
\verb|continue| may only occur syntactically nested in a for or while loop, 
but not nested in a function or class definition or try statement within 
that loop.
\end{quote}

\rulesection{return\_stmt}
\label{returnzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+return\_stmt\verb+>+} & ::=  & return {\bf \verb+<+tuple\_or\_test~\ref{tuplezzzorzzztestb}\verb+>+}  \\
 & \verb+|+  & return \\
\end{tabular} \\

From the Python reference~\cite{pythonlang}, section 6.7:
\begin{quote}
In a generator function (see \ref{yieldzzzstmtb}), 
the \verb|return| statement is not allowed to include an expression list (\ref{tuplezzzorzzztestb}). In that context, a bare return indicates that the generator is done and will cause \verb|StopIteration| to be raised.
\end{quote}

\rulesection{raise\_stmt}
\label{raisezzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+raise\_stmt\verb+>+} & ::=  & raise \\
 & \verb+|+  & raise {\bf \verb+<+test~\ref{testb}\verb+>+}  \\
 & \verb+|+  & raise {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|,| {\bf \verb+<+test~\ref{testb}\verb+>+}  \\
 & \verb+|+  & raise {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|,| {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|,| {\bf \verb+<+test~\ref{testb}\verb+>+}  \\
\end{tabular} \\

From the Python reference~\cite{pythonlang}, section 6.9:
\begin{quote}
\verb|raise| may have up to three arguments, the first being the type of the exception,
the second being its value, and the third being a traceback.
\end{quote}

\rulesection{yield\_stmt (NOT YET IMPLEMENTED)}
\label{yieldzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+yield\_stmt\verb+>+} & ::=  & yield {\bf \verb+<+tuple\_or\_test~\ref{tuplezzzorzzztestb}\verb+>+}  \\
\end{tabular} \\

From the Python reference~\cite{pythonlang}, section 6.8:
\begin{quote}
The \verb|yield| statement is only used when defining a generator function, 
and is only used in the body of the generator function. Using a yield 
statement in a function definition is sufficient to cause that definition 
to create a generator function instead of a normal function.
\end{quote}

\rulesection{import\_stmt}
\label{importzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+import\_stmt\verb+>+} & ::=  & {\bf \verb+<+import\_stmt1~\ref{importzzzstmt1b}\verb+>+}  \\
 & \verb+|+  & from {\bf \verb+<+dotted\_name~\ref{dottedzzznameb}\verb+>+}  import \verb|*| \\
 & \verb+|+  & from {\bf \verb+<+dotted\_name~\ref{dottedzzznameb}\verb+>+}  import {\bf \verb+<+import\_stmt2~\ref{importzzzstmt2b}\verb+>+}  \\
\end{tabular} \\

See the Python reference~\cite{pythonlang}, section 6.12.

\rulesection{import\_stmt1}
\label{importzzzstmt1b}
\begin{tabular}{lcl}
{\bf \verb+<+import\_stmt1\verb+>+} & ::=  & import {\bf \verb+<+dotted\_as\_name~\ref{dottedzzzaszzznameb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+import\_stmt1~\ref{importzzzstmt1b}\verb+>+}  \verb|,| {\bf \verb+<+dotted\_as\_name~\ref{dottedzzzaszzznameb}\verb+>+}  \\
\end{tabular}

\rulesection{import\_stmt2}
\label{importzzzstmt2b}
\begin{tabular}{lcl}
{\bf \verb+<+import\_stmt2\verb+>+} & ::=  & {\bf \verb+<+import\_as\_name~\ref{importzzzaszzznameb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+import\_as\_name~\ref{importzzzaszzznameb}\verb+>+}  \verb|,| {\bf \verb+<+import\_stmt2~\ref{importzzzstmt2b}\verb+>+}  \\
\end{tabular}

\rulesection{import\_as\_name}
\label{importzzzaszzznameb}
\begin{tabular}{lcl}
{\bf \verb+<+import\_as\_name\verb+>+} & ::=  & {\bf \verb+<+ident~\ref{identb}\verb+>+}  NAME {\bf \verb+<+ident~\ref{identb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+ident~\ref{identb}\verb+>+}  \\
\end{tabular}

\rulesection{dotted\_as\_name}
\label{dottedzzzaszzznameb}
\begin{tabular}{lcl}
{\bf \verb+<+dotted\_as\_name\verb+>+} & ::=  & {\bf \verb+<+dotted\_name~\ref{dottedzzznameb}\verb+>+}  NAME {\bf \verb+<+ident~\ref{identb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+dotted\_name~\ref{dottedzzznameb}\verb+>+}  \\
\end{tabular}

\rulesection{dotted\_name}
\label{dottedzzznameb}
\begin{tabular}{lcl}
{\bf \verb+<+dotted\_name\verb+>+} & ::=  & {\bf \verb+<+ident~\ref{identb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+ident~\ref{identb}\verb+>+}  \verb|.| {\bf \verb+<+dotted\_name~\ref{dottedzzznameb}\verb+>+}  \\
\end{tabular}

\rulesection{global\_stmt}
\label{globalzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+global\_stmt\verb+>+} & ::=  & global {\bf \verb+<+ident~\ref{identb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+global\_stmt~\ref{globalzzzstmtb}\verb+>+}  \verb|,| {\bf \verb+<+ident~\ref{identb}\verb+>+}  \\
\end{tabular} \\

From the Python reference~\cite{pythonlang}, section 6.13:
\begin{quote}
The global statement means that the listed identifiers are to be interpreted as globals.
Names listed in a global statement must not be used in the same code block 
textually preceding that global statement (not yet implemented). Names listed in a global statement must not be defined as formal parameters or in a for loop control target, class definition, function definition, or import statement (not yet implemented).

Programmer's note: the global is a directive to the parser. 
It applies only to code parsed at the same time as the global statement. 
In particular, a global statement contained in an exec statement does not 
affect the code block containing the exec statement, and code contained in 
an exec statement is unaffected by global statements in the code containing 
the exec statement. The same applies to the eval(), execfile() and compile() 
functions.

For example, in:
\begin{verbatim}
exec "global x"
x = 2
\end{verbatim}
the generated code will define a new \verb|x|, not modify an existing one.
\end{quote}

\rulesection{exec\_stmt (NOT YET IMPLEMENTED)}
\label{execzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+exec\_stmt\verb+>+} & ::=  & exec {\bf \verb+<+expr~\ref{exprb}\verb+>+}  \\
 & \verb+|+  & exec {\bf \verb+<+expr~\ref{exprb}\verb+>+}  in {\bf \verb+<+test~\ref{testb}\verb+>+}  \\
 & \verb+|+  & exec {\bf \verb+<+expr~\ref{exprb}\verb+>+}  in {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|,| {\bf \verb+<+test~\ref{testb}\verb+>+}  \\
\end{tabular} \\

See the Python reference~\cite{pythonlang}, section 6.14.

\rulesection{assert\_stmt}
\label{assertzzzstmtb}
\begin{tabular}{lcl}
{\bf \verb+<+assert\_stmt\verb+>+} & ::=  & assert {\bf \verb+<+test~\ref{testb}\verb+>+}  \\
 & \verb+|+  & assert {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|,| {\bf \verb+<+test~\ref{testb}\verb+>+}  \\
\end{tabular} \\

From the Python reference~\cite{pythonlang}, section 6.2:
\begin{quote}
The simple form, ``\verb|assert expression|'', is equivalent to 
\begin{verbatim}
if __debug__:
   if not expression: raise AssertionError
\end{verbatim}

 The extended form, ``\verb|assert expression1, expression2|'', is equivalent to 
\begin{verbatim}
if __debug__:
   if not expression1: raise AssertionError, expression2
\end{verbatim}
\end{quote}

\rulesection{compound\_stmt}
\label{compoundzzzstmtb}
\settowidth{\tw}{compound\_stmt  ::=  }
\addtolength{\tw}{2\arraycolsep}
\setlength{\len}{\textwidth}
\addtolength{\len}{-1\tw}
\begin{tabular}{lcp{\len}}
{\bf \verb+<+compound\_stmt\verb+>+} & ::=  & {\bf \verb+<+if\_stmt~\ref{ifzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+while\_stmt~\ref{whilezzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+for\_stmt~\ref{forzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+try\_stmt~\ref{tryzzzstmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+funcdef~\ref{funcdefb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+classdef~\ref{classdefb}\verb+>+}  \\
\end{tabular} \\

Compound statements can span multiple lines, so they may introduce a new indentation level.

\rulesection{if\_stmt}
\label{ifzzzstmtb}

\settowidth{\tw}{if\_stmt  ::=  }
\addtolength{\tw}{2\arraycolsep}

\setlength{\len}{\textwidth}
\addtolength{\len}{-1\tw}
\begin{tabular}{lcp{\len}}
{\bf \verb+<+if\_stmt\verb+>+} & ::=  & if {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  {\bf \verb+<+elif\_list~\ref{elifzzzlistb}\verb+>+}  \\
 & \verb+|+  & if {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  {\bf \verb+<+elif\_list~\ref{elifzzzlistb}\verb+>+}  else \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
\end{tabular}

\rulesection{elif\_list}
\label{elifzzzlistb}
\begin{tabular}{lcl}
{\bf \verb+<+elif\_list\verb+>+} & ::=  & $\varepsilon$ \\
 & \verb+|+  & {\bf \verb+<+elif\_list~\ref{elifzzzlistb}\verb+>+}  elif {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
\end{tabular}

%the suite subsection was moved
\rulesection{suite}
\label{suiteb}
\begin{tabular}{lcl}
{\bf \verb+<+suite\verb+>+} & ::=  & {\bf \verb+<+simple\_stmt~\ref{simplezzzstmtb}\verb+>+}  \\
 & \verb+|+  & NEWLINE INDENT {\bf \verb+<+stmt\_list\_plus~\ref{stmtzzzlistzzzplusb}\verb+>+}  DEDENT \\
\end{tabular} \\

The INDENT token indicates a new indentation level.  Similarly, the DEDENT token indicates a return to the previous indentation level.

\rulesection{stmt\_list\_plus}
\label{stmtzzzlistzzzplusb}
\begin{tabular}{lcl}
{\bf \verb+<+stmt\_list\_plus\verb+>+} & ::=  & {\bf \verb+<+stmt~\ref{stmtb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+stmt\_list\_plus~\ref{stmtzzzlistzzzplusb}\verb+>+}  {\bf \verb+<+stmt~\ref{stmtb}\verb+>+}  \\
\end{tabular}

\rulesection{while\_stmt}
\label{whilezzzstmtb}

\settowidth{\tw}{while\_stmt  ::=  }
\addtolength{\tw}{2\arraycolsep}

\setlength{\len}{\textwidth}
\addtolength{\len}{-1\tw}
\begin{tabular}{lcp{\len}}
{\bf \verb+<+while\_stmt\verb+>+} & ::=  & while {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
 & \verb+|+  & while {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  else \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
\end{tabular}

\rulesection{for\_stmt}
\label{forzzzstmtb}

\settowidth{\tw}{for\_stmt  ::=  }
\addtolength{\tw}{2\arraycolsep}

\setlength{\len}{\textwidth}
\addtolength{\len}{-1\tw}
\begin{tabular}{lcp{\len}}
{\bf \verb+<+for\_stmt\verb+>+} & ::=  & for {\bf \verb+<+target\_tuple\_or\_expr~\ref{targetzzztuplezzzorzzzexprb}\verb+>+}  in {\bf \verb+<+tuple\_or\_test~\ref{tuplezzzorzzztestb}\verb+>+}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
 & \verb+|+  & for {\bf \verb+<+target\_tuple\_or\_expr~\ref{targetzzztuplezzzorzzzexprb}\verb+>+}  in {\bf \verb+<+tuple\_or\_test~\ref{tuplezzzorzzztestb}\verb+>+}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  else \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
\end{tabular}

\rulesection{try\_stmt}
\label{tryzzzstmtb}

\settowidth{\tw}{try\_stmt  ::=  }
\addtolength{\tw}{2\arraycolsep}

\setlength{\len}{\textwidth}
\addtolength{\len}{-1\tw}
\begin{tabular}{lcp{\len}}
{\bf \verb+<+try\_stmt\verb+>+} & ::=  & try \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  {\bf \verb+<+except\_clause\_list\_plus~\ref{exceptzzzclausezzzlistzzzplusb}\verb+>+}  \\
 & \verb+|+  & try \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  {\bf \verb+<+except\_clause\_list\_plus~\ref{exceptzzzclausezzzlistzzzplusb}\verb+>+}  else \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
 & \verb+|+  & try \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  finally \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
\end{tabular}

\rulesection{except\_clause\_list\_plus}
\label{exceptzzzclausezzzlistzzzplusb}

\settowidth{\tw}{except\_clause\_list\_plus  ::=  }
\addtolength{\tw}{2\arraycolsep}

\setlength{\len}{\textwidth}
\addtolength{\len}{-1\tw}
\begin{tabular}{lcp{\len}}
{\bf \verb+<+except\_clause\_list\_plus\verb+>+} & ::=  & {\bf \verb+<+except\_clause~\ref{exceptzzzclauseb}\verb+>+}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+except\_clause\_list\_plus~\ref{exceptzzzclausezzzlistzzzplusb}\verb+>+}  {\bf \verb{<}\mbox{except\_clause~\ref{exceptzzzclauseb}}\verb|>|}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
\end{tabular}

\rulesection{except\_clause}
\label{exceptzzzclauseb}
\begin{tabular}{lcl}
{\bf \verb+<+except\_clause\verb+>+} & ::=  & except \\
 & \verb+|+  & except {\bf \verb+<+test~\ref{testb}\verb+>+}  \\
 & \verb+|+  & except {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|,| {\bf \verb+<+test~\ref{testb}\verb+>+}  \\
\end{tabular}

\rulesection{funcdef}
\label{funcdefb}

See the Python reference~\cite{pythonlang}, section 7.5.

\begin{tabular}{lcl}
{\bf \verb+<+funcdef\verb+>+} & ::=  & def {\bf \verb+<+ident~\ref{identb}\verb+>+}  {\bf \verb+<+parameters~\ref{parametersb}\verb+>+}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
\end{tabular}

\rulesection{parameters}
\label{parametersb}
\begin{tabular}{lcl}
{\bf \verb+<+parameters\verb+>+} & ::=  & \verb|(| \verb|)| \\
 & \verb+|+  & \verb|(| {\bf \verb+<+varargslist~\ref{varargslistb}\verb+>+}  \verb|)| \\
\end{tabular}

\rulesection{varargslist}
\label{varargslistb}
\begin{tabular}{lcl}
{\bf \verb+<+varargslist\verb+>+} & ::=  & \verb|**| {\bf \verb+<+ident~\ref{identb}\verb+>+}  \\
 & \verb+|+  & \verb|*| {\bf \verb+<+ident~\ref{identb}\verb+>+}  \\
 & \verb+|+  & \verb|*| {\bf \verb+<+ident~\ref{identb}\verb+>+}  \verb|,| \verb|**| {\bf \verb+<+ident~\ref{identb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+fpdef~\ref{fpdefb}\verb+>+}  \verb|,| \\
 & \verb+|+  & {\bf \verb+<+fpdef~\ref{fpdefb}\verb+>+}  \verb|=| {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|,| \\
 & \verb+|+  & {\bf \verb+<+fpdef~\ref{fpdefb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+fpdef~\ref{fpdefb}\verb+>+}  \verb|=| {\bf \verb+<+test~\ref{testb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+fpdef~\ref{fpdefb}\verb+>+}  \verb|,| {\bf \verb+<+varargslist~\ref{varargslistb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+fpdef~\ref{fpdefb}\verb+>+}  \verb|=| {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|,| {\bf \verb+<+varargslist~\ref{varargslistb}\verb+>+}  \\
\end{tabular} \\

From the Python reference~\cite{pythonlang}, section 7.5:
\begin{quote}
If the form ``*identifier'' is present, it is initialized to a tuple receiving 
any excess positional parameters, defaulting to the empty tuple. 
If the form ``**identifier'' is present, it is initialized to a new dictionary 
receiving any excess keyword arguments, defaulting to a new empty dictionary.

If a parameter has a default value, all following parameters must also have a 
default value -- this is a syntactic restriction that is not expressed by the grammar, but is checked by the parser.   
\end{quote}

\rulesection{fpdef}
\label{fpdefb}
\begin{tabular}{lcl}
{\bf \verb+<+fpdef\verb+>+} & ::=  & {\bf \verb+<+ident~\ref{identb}\verb+>+}  \\
 & \verb+|+  & ( {\bf \verb+<+fplist~\ref{fplistb}\verb+>+}  ) \\
\end{tabular} \\

A function parameter is either an identifier or a tuple that will be unpacked.  For example, in:
\begin{verbatim}
def f(x, (y, z)):
    pass

f(1,(2,3))
\end{verbatim}
when f is called, \verb|x| is bound to \verb|1|, \verb|y| is bound to \verb|2|, and
\verb|z| is bound to \verb|3|. \\

\rulesection{fplist}
\label{fplistb}
\begin{tabular}{lcl}
{\bf \verb+<+fplist\verb+>+} & ::=  & {\bf \verb+<+fpdef~\ref{fpdefb}\verb+>+}  \\
 & \verb+|+  & {\bf \verb+<+fpdef~\ref{fpdefb}\verb+>+}  \verb|,| \\
 & \verb+|+  & {\bf \verb+<+fpdef~\ref{fpdefb}\verb+>+}  \verb|,| {\bf \verb+<+fplist~\ref{fplistb}\verb+>+}  \\
\end{tabular}

\rulesection{classdef}
\label{classdefb}
\begin{tabular}{lcl}
{\bf \verb+<+classdef\verb+>+} & ::=  & class {\bf \verb+<+ident~\ref{identb}\verb+>+}  \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
 & \verb+|+  & class {\bf \verb+<+ident~\ref{identb}\verb+>+}  \verb|(| {\bf \verb+<+test~\ref{testb}\verb+>+}  \verb|)| \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
 & \verb+|+  & class {\bf \verb+<+ident~\ref{identb}\verb+>+}  \verb|(| {\bf \verb+<+testlist~\ref{testlistb}\verb+>+}  \verb|)| \verb|:| {\bf \verb+<+suite~\ref{suiteb}\verb+>+}  \\
\end{tabular} \\

In the CPython interpreter (version~2.2), ``old-style'' classes are defined by
\verb+class classname(superclasses)+, and ``new-style'' classes are defined by 
\verb+class classname+.  Such distinction is not made here; all classes
are ``new-style'' classes.

