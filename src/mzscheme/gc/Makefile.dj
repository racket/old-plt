# Primary targets:
# gc.a - builds basic library
# libgc.a - builds library for use with g++ "-fgc-keyword" extension
# c++ - adds C++ interface to library
# cords - adds cords (heavyweight strings) to library
# test - prints porting information, then builds basic version of gc.a,
#      	 and runs some tests of collector and cords.  Does not add cords or
#	 c++ interface to gc.a
# cord/de - builds dumb editor based on cords.
CC=gcc
CXX=gxx

CFLAGS= -O -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DSILENT

# Setjmp_test may yield overly optimistic results when compiled
# without optimization.
# -DSILENT disables statistics printing, and improves performance.
# -DFIND_LEAK causes the collector to assume that all inaccessible
#   objects should have been explicitly deallocated, and reports exceptions.
#   Finalization and the test program are not usable in this mode.
# -DALL_INTERIOR_POINTERS allows all pointers to the interior
#   of objects to be recognized.  (See gc_priv.h for consequences.)
# -DSMALL_CONFIG tries to tune the collector for small heap sizes,
#   usually causing it to use less space in such situations.
#   Incremental collection no longer works in this case.
# -DLARGE_CONFIG tunes the collector for unusually large heaps.
#   Necessary for heaps larger than about 500 MB on most machines.
#   Recommended for heaps larger than about 64 MB.
# -DDONT_ADD_BYTE_AT_END is meaningful only with
#   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS
#   causes all objects to be padded so that pointers just past the end of
#   an object can be recognized.  This can be expensive.  (The padding
#   is normally more than one byte due to alignment constraints.)
#   -DDONT_ADD_BYTE_AT_END disables the padding.
# -DNO_SIGNALS does not disable signals during critical parts of
#   the GC process.  This is no less correct than many malloc
#   implementations, and it sometimes has a significant performance
#   impact.  However, it is dangerous for many not-quite-ANSI C
#   programs that call things like printf in asynchronous signal handlers.
# -DNO_EXECUTE_PERMISSION may cause some or all of the heap to not
#   have execute permission, i.e. it may be impossible to execute
#   code from the heap.  Currently this only affects the incremental
#   collector on UNIX machines.  It may greatly improve its performance,
#   since this may avoid some expensive cache synchronization.
# -DOPERATOR_NEW_ARRAY declares that the C++ compiler supports the
#   new syntax "operator new[]" for allocating and deleting arrays.
#   See gc_cpp.h for details.  No effect on the C part of the collector.
#   This is defined implicitly in a few environments.
# -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined
#   as aliases for X, GC_realloc, and GC_free, respectively.
#   Calloc is redefined in terms of the new malloc.  X should
#   be either GC_malloc or GC_malloc_uncollectable.
#   The former is occasionally useful for working around leaks in code
#   you don't want to (or can't) look at.  It may not work for
#   existing code, but it often does.  Neither works on all platforms,
#   since some ports use malloc or calloc to obtain system memory.
#   (Probably works for UNIX, and win32.)
# -DIGNORE_FREE turns calls to free into a noop.  Only useful with
#   -DREDIRECT_MALLOC.
# -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.
#   Reduces code size slightly at the expense of debuggability.

LIBGC_CFLAGS= -O -DNO_SIGNALS -DSILENT \
    -DREDIRECT_MALLOC=GC_malloc_uncollectable \
    -DDONT_ADD_BYTE_AT_END -DALL_INTERIOR_POINTERS
#   Flags for building libgc.a -- the last two are required.

CXXFLAGS= $(CFLAGS) -DOPERATOR_NEW_ARRAY
AR= ar
RANLIB= ranlib


# Redefining srcdir allows object code for the nonPCR version of the collector
# to be generated in different directories.  In this case, the destination
directory
# should contain a copy of the original include directory.
srcdir = .
VPATH = $(srcdir)

OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o \
headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o\
stubborn.o typd_mlc.o ptr_chck.o mallocx.o

CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o

CORD_INCLUDE_FILES= $(srcdir)/gc.h $(srcdir)/cord/cord.h $(srcdir)/cord/ec.h \
           $(srcdir)/cord/private/cord_pos.h

# Libraries needed for curses applications.  Only needed for de.
CURSES= -lcurses -ltermlib

# The following is irrelevant on most systems.  But a few
# versions of make otherwise fork the shell specified in
# the SHELL environment variable.
SHELL= /bin/sh

SPECIALCFLAGS =
# Alternative flags to the C compiler for mach_dep.c.
# Mach_dep.c often doesn't like optimization, and it's
# not time-critical anyway.
# Set SPECIALCFLAGS to -q nodirect_code on Encore.

all: gc.a gctest

$(OBJS) test.o dyn_load.o dyn_load_sunos53.o: $(srcdir)/gc_priv.h \
 $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \
    $(srcdir)/config.h $(srcdir)/gc_typed.h Makefile
# The dependency on Makefile is needed.  Changing
# options such as -DSILENT affects the size of GC_arrays,
# invalidating all .o files that rely on gc_priv.h

mark.o typd_mlc.o finalize.o: $(srcdir)/gc_mark.h

gc.a: $(OBJS) dyn_load.o
	$(AR) ru gc.a $(OBJS) dyn_load.o
	$(RANLIB) gc.a

libgc.a:
	make CFLAGS="$(LIBGC_CFLAGS)" clean gc.a gcc_support.o
	move gc.a libgc.a
	-del on_sparc_sunos5
	./if_mach SPARC SUNOS5 touch on_sparc_sunos5
	./if_mach SPARC SUNOS5 $(AR) rus libgc.a gcc_support.o
	./if_not_there on_sparc_sunos5 $(AR) ru libgc.a gcc_support.o
	./if_not_there on_sparc_sunos5 $(RANLIB) libgc.a || cat /dev/null

cords: $(CORD_OBJS) cord/cordtest
	-del on_sparc_sunos5
	./if_mach SPARC SUNOS5 touch on_sparc_sunos5
	./if_mach SPARC SUNOS5 $(AR) rus gc.a $(CORD_OBJS)
	./if_not_there on_sparc_sunos5 $(AR) ru gc.a $(CORD_OBJS)
	./if_not_there on_sparc_sunos5 $(RANLIB) gc.a || cat /dev/null

gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/gc_cpp.h $(srcdir)/gc.h Makefile
	$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc

test_cpp: $(srcdir)/test_cpp.cc $(srcdir)/gc_cpp.h gc_cpp.o $(srcdir)/gc.h gc.a
	-del test_cpp
	$(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a


c++: gc_cpp.o $(srcdir)/gc_cpp.h test_cpp
	-del on_sparc_sunos5
	$(AR) ru gc.a gc_cpp.o
	$(RANLIB) gc.a
	./test_cpp 1

mach_dep.o: $(srcdir)/mach_dep.c
# $(srcdir)/mips_mach_dep.s $(srcdir)/rs6000_mach_dep.s if_mach if_not_there
	-del mach_dep.o
	$(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c

mark_rts.o: $(srcdir)/mark_rts.c
	-del mark_rts.o
	$(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c

cord/cordbscs.o: $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)
	$(CC) $(CFLAGS) -c $(srcdir)/cord/cordbscs.c
	move cordbscs.o cord/cordbscs.o
#  not all compilers understand -o filename

cord/cordxtra.o: $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)
	$(CC) $(CFLAGS) -c $(srcdir)/cord/cordxtra.c
	move cordxtra.o cord/cordxtra.o

cord/cordprnt.o: $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)
	$(CC) $(CFLAGS) -c $(srcdir)/cord/cordprnt.c
	move cordprnt.o cord/cordprnt.o

cord/cordtest: $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a
	-del cord/cordtest
	$(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c\
		 $(CORD_OBJS) gc.a

cord/de: $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a
	-del cord/de
	./if_mach SPARC SUNOS5 $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\
cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lthread -ldl
	./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\
cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb
	./if_mach HP_PA "" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\
cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld
	./if_mach RS6000 "" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\
cord/cordbscs.o cord/cordxtra.o gc.a -lcurses
	./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\
cord/cordbscs.o cord/cordxtra.o gc.a -lcurses
	./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\
cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES)

clean:
	-del gc.a *.o gctest gctest_dyn_link test_cpp \
	      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \
	      $(CORD_OBJS) cord/cordtest cord/de
	-del *~

gctest: test.o gc.a
	-del gctest
	$(CC) $(CFLAGS) -o gctest test.o gc.a

# If an optimized setjmp_test generates a segmentation fault,
# odds are your compiler is broken.  Gctest may still work.
# Try compiling setjmp_t.c unoptimized.
setjmp_test: $(srcdir)/setjmp_t.c $(srcdir)/gc.h
	$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c

test:  KandRtest cord/cordtest
	cord/cordtest

# Those tests that work even with a K&R C compiler:
KandRtest: setjmp_test gctest
	./setjmp_test
	./gctest



