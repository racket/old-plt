#!/bin/sh
#|
exec mzscheme -r "$0" "$0" "$@"
|#

;; This file generates foreign.c

(current-exception-handler
 (lambda (e)
 (fprintf (current-error-port) "~a\n" (if (exn? e) (exn-message e) e))
 (exit 1)))
(initial-exception-handler (current-exception-handler))

(define file    (vector-ref argv 0))
(define c-file  (regexp-replace #rx"\\.[^.]*$" file ".c"))
(define o-file  (regexp-replace #rx"\\.[^.]*$" file ".o"))
(define so-file (regexp-replace #rx"\\.[^.]*$" file ".so"))

(define current-indentation (make-parameter ""))
(define space? #f)
(define (set-indentation n)
  (current-indentation (make-string n #\space))
  (set! space? #f))

(define concat string-append)
(define \\ "newline-tag")
(define (~ . args)
  (when space? (display (current-indentation)))
  (for-each (lambda (x)
              (if (eq? x \\)
                (begin (newline) (display (current-indentation)))
                (display x)))
            args)
  (newline)
  (set! space? #t))

(define (process)
  (define scheme? #t)
  (define spc #f)
  (define (open)
    (when scheme? (error 'process "unexpected meta-open token"))
    (display #\") (set! spc #f) (set! scheme? #t))
  (define (close)
    (unless scheme? (error 'process "unexpected meta-close token"))
    (display #\") (set! spc '-) (set! scheme? #f))
  (define (newln) (if (eq? spc '-) (set! spc #f) (newline)))
  (define (disp x)
    (unless (equal? x "")
      (when (string? spc) (display spc))
      (if (regexp-match #rx"^ *$" x)
        (set! spc x)
        (let ([x (if scheme? x (regexp-replace* #rx"[\\\"]" x "\\\\&"))])
          (set! spc #f) (display x)))))
  ;; skip to "---begin"
  (let loop ()
    (unless (regexp-match #rx"^ *--- *begin *$" (read-line)) (loop)))
  ;; convert all to Scheme
  (close)
  (let loop ([str (read-line)] (k 0))
    ;; finish at end, ignore lines that begin with ";//"
    (cond [(or (eof-object? str)
               (and (zero? k) (regexp-match #rx"^ *--- *end *$" str)))
           'done]
          [(and (zero? k) (regexp-match #rx"^ *;//" str))
           (loop (read-line) 0)]
          [(regexp-match-positions #rx"\\\\?({:|:})" str k) =>
           (lambda (x)
             (let ([token (substring str (caar x) (cdar x))])
               (disp (substring str k (caar x)))
               (cond [(equal? token "{:")
                      (when (string? spc) (display spc)) (set! spc '-)
                      (open) (printf "~s\n" `(set-indentation ,(caar x)))]
                     [(equal? token ":}") (close)]
                     [else (disp token)])
               (loop str (cdar x))))]
          [else (disp (if (zero? k) str (substring str k)))
                (newln)
                (loop (read-line) 0)]))
  (open))

(with-output-to-file c-file
  (lambda ()
    (let-values ([(in out) (make-pipe)])
      (parameterize ([current-output-port out])
        (thread (lambda ()
                  (with-input-from-file file process)
                  (close-output-port out))))
      (parameterize ([current-input-port in]
                     [read-case-sensitive #t])
        (let loop ([x (read)])
          (unless (eof-object? x)
            (let ([x (eval x)]) (when (string? x) (display x)))
            (loop (read)))))))
  'replace)

#;(begin
;; compile the result
(require (lib "compile.ss" "dynext") (lib "link.ss" "dynext"))
(compile-extension #f c-file o-file '("libffi/include"))
(link-extension #f (list o-file "./libffi/.libs/libffi.a") so-file)
(delete-file o-file)
)

(exit 0)

---begin
/********************************************
 ** Do not edit this file!
 ** This file is generated from {:file:},
 ** to make changes, edit that file and
 ** run it to generate an updated version
 ** of this file.
 ********************************************/

{:

(define (scheme-id->c-name str)
  (let loop ([str (format "~a" str)]
             [substs '((#rx"->" "to") (#rx"[-/]" "_")
                       (#rx"\\?$" "_p") (#rx"!$" ""))])
    (if (null? substs)
      str
      (loop (regexp-replace* (caar substs) str (cadar substs)) (cdr substs)))))

;; User function definition
(define cfunctions '())
(define (_cdefine name minargs . maxargs)
  (define cname
    (concat "foreign_" (scheme-id->c-name name)))
  (set! maxargs (if (null? maxargs) minargs (car maxargs)))
  (set! cfunctions (cons (list name cname minargs maxargs) cfunctions))
  (~ "#undef MYNAME" \\ "#define MYNAME \""name"\"" \\
     "static Scheme_Object *"cname"(int argc, Scheme_Object *argv[])"))
(define-syntax cdefine
  (syntax-rules ()
    [(_ name minargs maxargs) (_cdefine `name minargs maxargs)]
    [(_ name args) (_cdefine `name args args)]))

;; Struct definitions
(define cstructs '())
(define (_cdefstruct name slots types)
  (define cname
    (regexp-replace* #rx"-" (symbol->string name) "_"))
  (define mname
    (list->string
     (map char-upcase (string->list (regexp-replace* #rx"_" cname "")))))
  (define predname
    (string->symbol (concat (symbol->string name)"?")))
  (~ "/* "name" structure definition */")
  (~ "static Scheme_Type "cname"_tag;" \\
     "typedef struct "cname"_struct {" \\
     "  Scheme_Object so;")
  (for-each (lambda (s t) (~ "  "t" "s";")) slots types)
  (~ "} "cname"_struct;" \\
     "#define SCHEME_"mname"P(x) (SCHEME_TYPE(x)=="cname"_tag)")
  (_cdefine predname 1)
  (~ "{ return SCHEME_"mname"P(argv[0]) ? scheme_true : scheme_false; }")
  (~ "/* 3m stuff for "cname" */" \\
     "#ifdef MZ_PRECISE_GC" \\
     "START_XFORM_SKIP;"
     "int "cname"_SIZE(void *p) {" \\
     "  return gcBYTES_TO_WORDS(sizeof("cname"_struct));" \\
     "}")
  (let ([mark/fix (lambda (mode)
                    (~ "int "cname"_"mode"(void *p) {" \\
                       "  "cname"_struct *s = ("cname"_struct *)p;")
                    (for-each (lambda (s t)
                                (when (regexp-match #rx"[*]" t)
                                  (~ "  gc"mode"(s->"s");")))
                              slots types)
                    (~ "  return gcBYTES_TO_WORDS(sizeof("cname"_struct));" \\
                       "}"))])
    (mark/fix "MARK")
    (mark/fix "FIXUP"))
  (~ "END_XFORM_SKIP;" \\
     "#endif")
  (set! cstructs (cons (list* name cname slots) cstructs)))
(define-syntax cdefstruct
  (syntax-rules ()
    [(_ name (slot type) ...)
     (_cdefstruct `name (list `slot ...) (list type ...))]))

;; Tagged object allocation
(define (_cmake-object var type . values)
  (define cstruct (cdr (assq type cstructs)))
  (~ var" = ("(car cstruct)"_struct*)scheme_malloc_tagged(sizeof("
            (car cstruct)"_struct));" \\
     var"->so.type = "(car cstruct)"_tag;")
  (for-each (lambda (v f) (~ var"->"f" = ("v");")) values (cdr cstruct)))
(define-syntax cmake-object
  (syntax-rules () [(_ var type val ...) (_cmake-object var `type val ...)]))

(define symbols '())
(define-syntax defsymbols
  (syntax-rules ()
    [(_ sym ...)
     (for-each
      (lambda (s)
        (when (assq s symbols)
          (error 'defsymbols "symbol ~s already defined" s))
        (set! symbols
              (cons (list s (string-append (regexp-replace
                                            #rx"-" (symbol->string s) "_")
                                           "_sym"))
                    symbols))
        (~ "static Scheme_Object *"(cadar symbols)";"))
      '(sym ...))]))

:}

#include "schpriv.h"
#ifndef WINDOWS_DYNAMIC_LOAD
# include <dlfcn.h>
# include <inttypes.h>
#else
# include <windows.h>
# include <wtypes.h>
  typedef _int8    int8_t;
  typedef unsigned _int8  uint8_t;
  typedef _int16   int16_t;
  typedef unsigned _int16 uint16_t;
  typedef _int32   int32_t;
  typedef unsigned _int32 uint32_t;
  typedef _int64   int64_t;
  typedef unsigned _int64 uint64_t;
#endif
#include "ffi.h"

#ifndef MZ_PRECISE_GC
# define XFORM_OK_PLUS +
# define GC_CAN_IGNORE /* empty */
#endif

/* same as the macro in file.c */
#define TO_PATH(x) (SCHEME_PATHP(x) ? (x) : scheme_char_string_to_path(x))

/*****************************************************************************/
/* Library objects */

{:(cdefstruct ffi-lib
    (handle  "void*")
    (name    "Scheme_Object*")
    (objects "Scheme_Hash_Table*")):}

static Scheme_Hash_Table *opened_libs;

/* (ffi-lib filename) -> ffi-lib */
{:(cdefine ffi-lib 1):}
{
  char *name;
  Scheme_Object *path, *hashname;
  void *handle;
  ffi_lib_struct *lib;
  if (!(SCHEME_PATH_STRINGP(argv[0]) || SCHEME_FALSEP(argv[0])))
    scheme_wrong_type(MYNAME, "string-or-false", 0, argc, argv);
  /* leave the filename as given, the system will look for it */
  /* (`#f' means open the executable) */
  path = SCHEME_FALSEP(argv[0]) ? NULL : TO_PATH(argv[0]);
  name = (path==NULL) ? NULL : SCHEME_PATH_VAL(path);
  hashname = (Scheme_Object*)((name==NULL) ? "" : name);
  lib = (ffi_lib_struct*)scheme_hash_get(opened_libs, hashname);
  if (!lib) {
    Scheme_Hash_Table *ht;
#ifdef WINDOWS_DYNAMIC_LOAD
    handle = (name==NULL) ? GetModuleHandle(NULL) : LoadLibrary(name);
    if (handle == NULL) {
      long err;
      err = GetLastError();
      scheme_raise_exn(MZEXN_FAIL_FILESYSTEM,
                       MYNAME": couldn't open %V (%E)", argv[0], err);
    }
#else
    handle = dlopen(name, RTLD_NOW | RTLD_GLOBAL);
    if (handle == NULL)
      scheme_raise_exn(MZEXN_FAIL_FILESYSTEM,
                       MYNAME": couldn't OPEN %V (%s)", argv[0], dlerror());
#endif
    ht = scheme_make_hash_table(SCHEME_hash_string);
    {:(cmake-object "lib" ffi-lib
                    "handle" "argv[0]"
                    "ht"):}
    scheme_hash_set(opened_libs, hashname, (Scheme_Object*)lib);
    /* no dlclose finalizer - since the hash table always keeps a reference */
    /* maybe add some explicit unload at some point */
  }
  return (Scheme_Object*)lib;
}

/* (ffi-lib-name ffi-lib) -> string */
{:(cdefine ffi-lib-name 1):}
{
  if (!SCHEME_FFILIBP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-lib", 0, argc, argv);
  return ((ffi_lib_struct*)argv[0])->name;
}

/*****************************************************************************/
/* Pull pointers (mostly functions) out of ffi-lib objects */

{:(cdefstruct ffi-obj
    (obj  "void*")
    (name "char*")
    (lib  "ffi_lib_struct*")):}

/* (ffi-obj objname ffi-lib-or-libname) -> ffi-obj */
{:(cdefine ffi-obj 2):}
{
  ffi_obj_struct *obj;
  void *dlobj;
  ffi_lib_struct *lib = NULL;
  char *dlname;
  if (SCHEME_FFILIBP(argv[1]))
    lib = (ffi_lib_struct*)argv[1];
  else if (SCHEME_PATH_STRINGP(argv[1]) || SCHEME_FALSEP(argv[1]))
    lib = (ffi_lib_struct*)(foreign_ffi_lib(1,&argv[1]));
  else
    scheme_wrong_type(MYNAME, "ffi-lib", 1, argc, argv);
  if (!SCHEME_BYTE_STRINGP(argv[0]))
    scheme_wrong_type(MYNAME, "string", 0, argc, argv);
  dlname = SCHEME_BYTE_STR_VAL(argv[0]);
  obj = (ffi_obj_struct*)scheme_hash_get(lib->objects, (Scheme_Object*)dlname);
  if (!obj) {
#ifdef WINDOWS_DYNAMIC_LOAD
    dlobj = GetProcAddress(lib->handle, dlname);
    if (!dlobj) {
      long err;
      err = GetLastError();
      scheme_raise_exn(MZEXN_FAIL_FILESYSTEM,
                       MYNAME": couldn't get \"%s\" from %V (%E)",
                       dlname, lib->name, err);
    }
#else
    dlobj = dlsym(lib->handle, dlname);
    if (!dlobj) {
      const char *err;
      err = dlerror();
      if (err != NULL)
        scheme_raise_exn(MZEXN_FAIL_FILESYSTEM,
                         MYNAME": couldn't get \"%s\" from %V (%s)",
                         dlname, lib->name, err);
    }
#endif
    {:(cmake-object "obj" ffi-obj "dlobj" "dlname" "lib"):}
    scheme_hash_set(lib->objects, (Scheme_Object*)dlname, (Scheme_Object*)obj);
  }
  return (obj == NULL) ? scheme_false : (Scheme_Object*)obj;
}

/* (ffi-obj-lib ffi-obj) -> ffi-lib */
{:(cdefine ffi-obj-lib 1):}
{
  if (!SCHEME_FFIOBJP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-obj", 0, argc, argv);
  return (Scheme_Object*)(((ffi_obj_struct*)argv[0])->lib);
}

/* (ffi-obj-name ffi-obj) -> string */
{:(cdefine ffi-obj-name 1):}
{
  if (!SCHEME_FFIOBJP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-obj", 0, argc, argv);
  return scheme_make_byte_string(((ffi_obj_struct*)argv[0])->name);
}

/*****************************************************************************/
/* Type helpers */

/* These are not defined in MzScheme because:
 * - SCHEME_UINT_VAL is not really a simple accessor like other SCHEME_X_VALs
 * - scheme_make_integer_from_unsigned behaves the same as the signed version
 */
#define SCHEME_UINT_VAL(obj) ((unsigned)(SCHEME_INT_VAL(obj)))
#define scheme_make_integer_from_unsigned(i) \
  ((Scheme_Object *)((((unsigned long)i) << 1) | 0x1))

#ifndef SIXTY_FOUR_BIT_INTEGERS

/* longs and ints are really the same */
#define scheme_get_realint_val(x,y) \
  scheme_get_int_val(x,(long*)(y))
#define scheme_get_unsigned_realint_val(x,y) \
  scheme_get_unsigned_int_val(x,(long*)(y))
#define scheme_make_realinteger_value \
  scheme_make_integer_value
#define scheme_make_realinteger_value_from_unsigned \
  scheme_make_integer_value_from_unsigned

#else /* SIXTY_FOUR_BIT_INTEGERS defined */

/* Modified versions of stuff from number.c  */
/* These will make sense in MzScheme when longs are not the same as ints
 * which is needed for libffi's int32 types. */
int scheme_get_realint_val(Scheme_Object *o, int *v)
{
  if (SCHEME_INTP(o)) {
    *v = (int)(SCHEME_INT_VAL(o));
    return 1;
  } else if (SCHEME_BIGNUMP(o)) {
    long l;
    int res = scheme_bignum_get_int_val(o, &l);
    *v = (int)l;
    return res;
  } else
    return 0;
}
int scheme_get_unsigned_realint_val(Scheme_Object *o, unsigned int *v)
{
  if (SCHEME_INTP(o)) {
    int i = (int)(SCHEME_INT_VAL(o));
    if (i < 0)
      return 0;
    *v = i;
    return 1;
  } else if (SCHEME_BIGNUMP(o)) {
    long l;
    int res = scheme_bignum_get_unsigned_int_val(o, &l);
    *v = (int)l;
    return res;
  } else
    return 0;
}
Scheme_Object *
scheme_make_realinteger_value(int ri)
{
  long i = (long)ri;
  Scheme_Object *o = scheme_make_integer(i);
  if (SCHEME_INT_VAL(o) == i)
    return o;
  else
    return scheme_make_bignum(i);
}
Scheme_Object *
scheme_make_realinteger_value_from_unsigned(unsigned int ri)
{
  unsigned long i = (unsigned long)ri;
  Scheme_Object *o = scheme_make_integer(i);
  if ((SCHEME_INT_VAL(o) >= 0)
      && ((unsigned long)SCHEME_INT_VAL(o)) == i)
    return o;
  else
    return scheme_make_bignum_from_unsigned(i);
}

#endif /* SIXTY_FOUR_BIT_INTEGERS */

/* This is related to the section of scheme.h that defines mzlonglong. */
#ifndef INT64_AS_LONG_LONG
#ifdef  NO_LONG_LONG_TYPE
#ifndef SIXTY_FOUR_BIT_INTEGERS
#error foreign requires a 64-bit integer type type.
#endif
#endif
#endif

unsigned short *ucs4_string_to_utf16_pointer(Scheme_Object *ucs)
{
  long ulen;
  unsigned short *res;
  res = scheme_ucs4_to_utf16
          (SCHEME_CHAR_STR_VAL(ucs), 0, 1+SCHEME_CHAR_STRLEN_VAL(ucs),
           NULL, -1, &ulen, 0);
  return res;
}

Scheme_Object *utf16_pointer_to_ucs4_string(unsigned short *utf)
{
  long ulen;
  mzchar *res;
  int end;
  for (end=0; utf[end] != 0; end++) { /**/ }
  res = scheme_utf16_to_ucs4(utf, 0, end, NULL, -1, &ulen, 0);
  return scheme_make_sized_char_string(res, ulen, 0);
}

/*****************************************************************************/
/* Types */

{:
;; Types are defined with the `defctype' function.  This looks like:
;;   (defctype 'type-name
;;     'prop1 val1
;;     'prop2 val2
;;     ...)
;; The current properties are:
;;   stype: scheme type symbol
;;   cname: like stype but used for C identifiers
;;   ftype: type name used by libffi (as ffi_type_X) (defaults to cname)
;;   ctype: C type, or #f if none (defaults to ftype, with proper massaging)
;;   macro: if specified as "X", use "SCHEME_XP" and "SCHEME_X_VAL" as the
;;          defaults for the next two properties
;;   pred:  name of predicate macro
;;    (or a function of the value and an ForeignAny obj pointer name, which
;;     produces an expression that tests the value and sets the ForeignAny obj
;;     accordingly.)
;;   s->c:  name of value extraction macro
;;    (or #f which means that the predicate already sets the value, or a
;;     function with the same arguments as above)
;;   c->s:  name of value construction macro/function
;;    (or a function of the value that generates the expression)

(define types '())

(define (get-prop type prop)
  (cadr (assq prop (cdr (assq type types)))))

(define *type-counter* 0)

(define (describe-type stype cname ftype ctype pred s->c c->s)
  (set! *type-counter* (add1 *type-counter*))
  (~ "#define FOREIGN_"cname" ("*type-counter*")" \\
     "/* Type Name:   "stype (if (equal? cname stype)
                               "" (concat " ("cname")")) \\
     " * LibFfi type: ffi_type_"ftype \\
     " * C type:      "(or ctype "-none-") \\
     " * Predicate:   "(cond [(not pred) "-none-"]
                             [(string? pred) (concat pred"(<Scheme>)")]
                             [else (pred "<Scheme>" "aux")]) \\
     " * Scheme->C:   "(cond
                        [(not s->c)
                         (if pred "-none- (set by the predicate)" "-none-")]
                        [(string? s->c) (concat s->c"(<Scheme>)")]
                        [else (s->c "<Scheme>" "aux")]) \\
     " * C->Scheme:   "(cond [(not c->s) "-none-"]
                             [(string? c->s) (concat c->s"(<C>)")]
                             [else (c->s "<C>")]) \\
     " */" \\))

(define (describe-alias from to)
  (~ "/* Alias type: `"from"'" \\
     " * Aliased to: `"to"'" \\
     " */" \\))

(define (make-ctype type args)
  (define (prop p . default)
    (let loop ([args args])
      (cond [(null? args) (and (pair? default) (car default))]
            [(eq? p (car args))
             (if (and (pair? (cadr args)) (eq? (caadr args) 'from))
               (get-prop (cadadr args) p)
               (cadr args))]
            [else (loop (cddr args))])))
  (let* ([stype (symbol->string type)]
         [cname (scheme-id->c-name stype)]
         [ftype (prop 'ftype cname)]
         [ctype (prop 'ctype
                      (regexp-replace
                       #rx"^sint"
                       (regexp-replace #rx"^(u?int(?:[0-9]+))$" ftype "\\1_t")
                       "int"))]
         [ftype (regexp-replace #rx"^(int|char|long)" ftype "s\\1")]
         [macro (prop 'macro)]
         [pred  (prop 'pred (and macro (concat "SCHEME_"macro"P")))]
         [s->c  (prop 's->c (and macro (concat "SCHEME_"macro"_VAL")))]
         [c->s  (prop 'c->s)])
    (describe-type stype cname ftype ctype pred s->c c->s)
    `(,type (stype ,stype) (cname ,cname) (ftype ,ftype) (ctype ,ctype)
      (macro ,macro) (pred ,pred) (s->c ,s->c) (c->s ,c->s))))

(define (defctype name . args)
  (set! types (append! types (list (make-ctype name args)))))

(define (defaliastype from to)
  (describe-alias from to)
  (set! types (append! types (list `(alias ,from ,to)))))

(define-syntax (for-each-type stx)
  (syntax-case stx ()
    [(_ body ...)
     (let* ([all? #f]
            [body1 (syntax-case #'(body ...) (-all-)
                     [(-all- b ...) (begin (set! all? #t) #'(begin b ...))]
                     [else #'(begin body ...)])]
            [id (lambda (sym) (datum->syntax-object (syntax _) sym))])
       (with-syntax ([body  body1]
                     [all   (if all? #'#t #'#f)]
                     [alias (id 'alias)]
                     [stype (id 'stype)]
                     [cname (id 'cname)]
                     [ctype (id 'ctype)]
                     [ftype (id 'ftype)]
                     [macro (id 'macro)]
                     [pred  (id 'pred)]
                     [s->c  (id 's->c)]
                     [c->s  (id 'c->s)])
         #'(for-each (lambda (t)
                       (define alias (and (eq? 'alias (car t)) (cdr t)))
                       (define data (cdr (if alias (assq (caddr t) types) t)))
                       (define (get sym) (cadr (assq sym data)))
                       (when (or all (not alias))
                         (let ([stype (get 'stype)]
                               [cname (get 'cname)]
                               [ftype (get 'ftype)]
                               [ctype (get 'ctype)]
                               [macro (get 'macro)]
                               [pred  (get 'pred)]
                               [s->c  (get 's->c)]
                               [c->s  (get 'c->s)])
                           body)))
                     types)))]))

(define (defctype* name/+ftype ctype pred s->c c->s)
  (let ([name (if (pair? name/+ftype) (car name/+ftype) name/+ftype)]
        [ftype (and (pair? name/+ftype) (cadr name/+ftype))])
    (apply defctype name
      `(ctype ,ctype
        ,@(if ftype `(ftype ,ftype) `())
        pred ,(if (string? pred) (concat "SCHEME_"pred"P")    pred)
        s->c ,(if (string? s->c) (concat "SCHEME_"s->c"_VAL") s->c)
        c->s ,(if (string? c->s) (concat "scheme_make_"c->s)  c->s)))))

(~ "/***********************************************************************"\\
   " * The following are the only primitive types." \\
   " * The tricky part is figuring out what width-ed types corrspond to what"\\
   " * internal types.  Matthew says:" \\
   " *   MzScheme expects to be compiled such that sizeof(int) == 4," \\
   " *   sizeof(long) == sizeof(void*), sizeof(short) >= 2," \\
   " *   sizeof(char) == 1, sizeof(float) == 4, and sizeof(double) == 8." \\
   " *   So, on a 64-bit OS, MzScheme expects only `long' to change." \\
   " **********************************************************************/"\\
   )

(~ "/* returns #<void> when used as output type, not for input types. */")
(defctype 'void
  'ctype #f 'pred #f 's->c #f 'c->s (lambda (x) "scheme_void"))

;; libffi primitive types
;;    scheme-name  c-type     SCHEME_?P  SCHEME_?_VAL scheme_make_
(defctype* 'int8   "int8_t"       "INT"  "INT"        "integer")
(defctype* 'uint8  "uint8_t"      "INT"  "UINT"       "integer_from_unsigned")
(~ "/* `byte' is a convenient name for uint8 */")
(defaliastype 'byte 'uint8)
(defctype* 'int16  "int16_t"      "INT"  "INT"        "integer")
(defctype* 'uint16 "uint16_t"     "INT"  "UINT"       "integer_from_unsigned")
(~ "/* `word' is a convenient name for uint16 */")
(defaliastype 'word 'uint16)

(~ "/* Treats integers properly: */")
(defctype* 'int32  "int32_t"
  (lambda (x aux) (concat "scheme_get_realint_val("x",&"aux")")) #f
  "realinteger_value")
(~ "/* Treats integers properly: */")
(defctype* 'uint32 "unsigned int"
  (lambda (x aux) (concat "scheme_get_unsigned_realint_val("x",&"aux")")) #f
  "realinteger_value_from_unsigned")

;; mzlonglong is always assumed to be 64 bits, or the above will throw an error
(defctype* 'int64  "int64_t"
  (lambda (x aux) (concat "scheme_get_long_long_val("x",&"aux")")) #f
  "integer_value_from_long_long")
(defctype* 'uint64 "uint64_t"
  (lambda (x aux) (concat "scheme_get_unsigned_long_long_val("x",&"aux")")) #f
  "integer_value_from_unsigned_long_long")

(~ "/* `int' and `uint' are always synonyms for int32/uint32 (see above) */")
(defaliastype 'int  'int32)
(defaliastype 'uint 'uint32)

(~ "/* This is like int32, but always assumes fixnum: */")
(defctype* '(fixint "int32")   "int32_t"  "INT" "INT"  "integer")
(~ "/* This is like uint32, but always assumes fixnum: */")
(defctype* '(ufixint "uint32") "uint32_t" "INT" "UINT" "integer_from_unsigned")

(~ "/* This is what mzscheme defines as long: */" \\
   "#ifndef SIXTY_FOUR_BIT_INTEGERS" \\
   "#define ffi_type_smzlong ffi_type_sint32" \\
   "#define ffi_type_umzlong ffi_type_uint32" \\
   "#else" \\
   "#define ffi_type_smzlong ffi_type_sint64" \\
   "#define ffi_type_umzlong ffi_type_uint64" \\
   "#endif" \\
   \\
   "/* This is what mzscheme defines as long: */")
(defctype* '(long "smzlong")  "long"
  (lambda (x aux) (concat "scheme_get_int_val("x",&"aux")")) #f
  "integer_value")
(~ "/* This is what mzscheme defines as ulong: */")
(defctype* '(ulong "umzlong") "unsigned long"
  (lambda (x aux) (concat "scheme_get_unsigned_int_val("x",&"aux")")) #f
  "integer_value_from_unsigned")

(~ "/* This is what mzscheme defines as long, assuming fixnums: */")
(defctype* '(fixnum "smzlong")
  "long"          "INT" "INT"  "integer")
(~ "/* This is what mzscheme defines as ulong, assuming fixnums: */")
(defctype* '(ufixnum "umzlong")
  "unsigned long" "INT" "UINT" "integer_from_unsigned")

(defctype* 'float  "float"        "FLT"  "FLT"        "float")
(defctype* 'double "double"       "DBL"  "DBL"        "double")
;; Not useful?  not implemented in any case.
;; (defctype* 'longdouble "long double" ...???...)

(~ "/* Booleans -- implemented as an int which is 1 or 0: */")
(defctype 'bool
  'ftype "int"
  'pred (lambda (x aux) "1")
  's->c "SCHEME_TRUEP"
  'c->s (lambda (x) (concat "("x"?scheme_true:scheme_false)")))

(~ "/* Strings -- no copying is done." \\
   " * #f is not NULL since these are used only for strings, use byte" \\
   " * strings if this is what you need. */" \\
   )

(defctype 'string/ucs-4
  'ftype "pointer"
  'ctype "mzchar*"
  'pred  "SCHEME_CHAR_STRINGP"
  's->c  "SCHEME_CHAR_STR_VAL"
  'c->s  "scheme_make_char_string_without_copying")

(defctype 'string/utf-16
  'ftype "pointer"
  'ctype "unsigned short*"
  'pred  "SCHEME_CHAR_STRINGP"
  's->c  "ucs4_string_to_utf16_pointer"
  'c->s  "utf16_pointer_to_ucs4_string")

(~ "/* Byte strings -- not copying C strings, #f is NULL." \\
   " * (note: these are not like char* which is just a pointer) */" \\
   )

(defctype 'bytes
  'ftype "pointer"
  'ctype "char*"
  'pred  (lambda (x aux)
           (concat "SCHEME_FALSEP("x")||SCHEME_BYTE_STRINGP("x")"))
  's->c  (lambda (x aux)
           (concat "SCHEME_FALSEP("x")?NULL:SCHEME_BYTE_STR_VAL("x")"))
  'c->s  (lambda (x)
           (concat "("x"==NULL)?scheme_false:"
                   "scheme_make_byte_string_without_copying("x")")))

(defctype 'path
  'ftype "pointer"
  'ctype "char*"
  'pred  (lambda (x aux)
           (concat "SCHEME_FALSEP("x")||SCHEME_PATH_STRINGP("x")"))
  's->c  (lambda (x aux)
           (concat "SCHEME_FALSEP("x")?NULL:SCHEME_PATH_VAL("x")"))
  'c->s  (lambda (x)
           (concat "("x"==NULL)?scheme_false:"
                   "scheme_make_path_without_copying("x")")))

(defctype 'symbol
  'ftype "pointer"
  'ctype "char*"
  'pred  "SCHEME_SYMBOLP"
  's->c  "SCHEME_SYM_VAL"
  'c->s  "scheme_intern_symbol")

(~ "/* This is for any C pointer: #f is NULL, cpointer values as well as" \\
   " * ffi-obj and string values pass their pointer.  When used as a return" \\
   " * value, either a cpointer object or #f is returned. */")
(defctype 'pointer
  'ctype "void*"
  'macro "FFIANYPTR"
  'c->s  "scheme_make_foreign_cpointer")

;; This is probably not needed
;; (~ "/* Used for ffi-callback objects: */")
;; (defctype 'callback
;;   'ftype "pointer"
;;   'ctype "void*"
;;   'macro "FFICALLBACK"
;;   's->c  (lambda (x aux) (concat "((ffi_callback_struct*)("x"))->callback"))
;;   'c->s  (lambda (x) x))

(~ "/* This is used for passing and Scheme_Object* value as is.  Useful for" \\
   " * functions that know about Scheme_Object*s, like MzScheme's. */")
(defctype 'scheme
  'ftype "pointer"
  'ctype "Scheme_Object*"
  'pred (lambda (x aux) "1")
  's->c (lambda (x aux) x)
  'c->s (lambda (x) x))

(~ "/* Special type, not actually used for anything except to mark points" \\
   " * that are treated like pointers but not referenced.  Used for" \\
   " * creating function types. */")
(defctype 'fmark 'ftype "pointer" 'ctype #f)

:}
typedef union _ForeignAny {
  {:(for-each-type (when ctype (~ ctype" x_"cname";"))):}
} ForeignAny;

{: (set! *type-counter* (add1 *type-counter*))
   (~ "/* This is a tag that is used to identify user-made struct types. */" \\
      "#define FOREIGN_struct ("*type-counter*")")
   (set! *type-counter* #f) ; make sure this is the last one defined
:}

/*****************************************************************************/
/* Type objects */

/* This struct is used for both user types and primitive types (including
 * struct types).  If it is a primitive type then basetype will be NULL, and
 * scheme_to_c will have the &ffi_type pointer, and c_to_scheme will have an
 * integer (a label value) for non-struct type. */
{:(cdefstruct ctype
    (basetype    "Scheme_Object*")
    (scheme_to_c "Scheme_Object*")
    (c_to_scheme "Scheme_Object*")):}

#define CTYPE_BASETYPE(x)  (((ctype_struct*)(x))->basetype)
#define CTYPE_PRIMP(x)     (NULL == (CTYPE_BASETYPE(x)))
#define CTYPE_USERP(x)     (!(CTYPE_PRIMP(x)))
#define CTYPE_PRIMTYPE(x)  ((ffi_type*)(((ctype_struct*)(x))->scheme_to_c))
#define CTYPE_PRIMLABEL(x) ((int)(((ctype_struct*)(x))->c_to_scheme))
#define CTYPE_USER_S2C(x)  (((ctype_struct*)(x))->scheme_to_c)
#define CTYPE_USER_C2S(x)  (((ctype_struct*)(x))->c_to_scheme)

/* Returns #f for primitive types. */
{:(cdefine ctype-basetype 1):}
{
  Scheme_Object *base;
  if (!SCHEME_CTYPEP(argv[0]))
    scheme_wrong_type(MYNAME, "ctype", 0, argc, argv);
  base = CTYPE_BASETYPE(argv[0]);
  if (NULL == base) return scheme_false;
  else              return base;
}

{:(cdefine ctype-scheme->c 1):}
{
  if (!SCHEME_CTYPEP(argv[0]))
    scheme_wrong_type(MYNAME, "ctype", 0, argc, argv);
  return (CTYPE_PRIMP(argv[0])) ? scheme_false :
           ((ctype_struct*)(argv[0]))->scheme_to_c;
}

{:(cdefine ctype-c->scheme 1):}
{
  if (!SCHEME_CTYPEP(argv[0]))
    scheme_wrong_type(MYNAME, "ctype", 0, argc, argv);
  return (CTYPE_PRIMP(argv[0])) ? scheme_false :
           ((ctype_struct*)(argv[0]))->c_to_scheme;
}

/* Returns a primitive type, or NULL if not a type */
static Scheme_Object *get_ctype_base(Scheme_Object *type)
{
  if (!SCHEME_CTYPEP(type)) return NULL;
  while (CTYPE_USERP(type)) { type = CTYPE_BASETYPE(type); }
  return type;
}

/* Returns the size, 0 for void, -1 if no such type */
static int ctype_sizeof(Scheme_Object *type)
{
  type = get_ctype_base(type);
  if (type == NULL) return -1;
  switch (CTYPE_PRIMLABEL(type)) {
  {:(for-each-type
      (~ "case FOREIGN_"cname": return "
         (if ctype (concat "sizeof("ctype");") "0;"))):}
  /* for structs */
  default: return CTYPE_PRIMTYPE(type)->size;
  }
}

/* (make-ctype basetype scheme->c c->scheme) -> ctype */
/* The scheme->c can throw type errors to check for valid arguments */
/* a #f means no conversion function, if both are #f -- then just return the */
/* basetype. */
{:(cdefine make-ctype 3):}
{
  ctype_struct *type;
  if (!SCHEME_CTYPEP(argv[0]))
    scheme_wrong_type(MYNAME, "C-type", 0, argc, argv);
  else if (!(SCHEME_FALSEP(argv[1]) || SCHEME_PROCP(argv[1])))
    scheme_wrong_type(MYNAME, "procedure-or-false", 1, argc, argv);
  else if (!(SCHEME_FALSEP(argv[2]) || SCHEME_PROCP(argv[2])))
    scheme_wrong_type(MYNAME, "procedure-or-false", 2, argc, argv);
  else if (SCHEME_FALSEP(argv[1]) && SCHEME_FALSEP(argv[2]))
    return argv[0];
  else {
    {:(cmake-object "type" ctype "argv[0]" "argv[1]" "argv[2]"):}
    return (Scheme_Object*)type;
  }
  return NULL; /* shush the compiler */
}

/* (make-cstruct-type types) -> ctype */
/* This creates a new primitive type that is a struct.  This type can be used
 * with cpointer objects, except that the contents is used rather than the
 * pointer value.  Marshaling to lists or whatever should be done in Scheme. */
{:(cdefine make-cstruct-type 1):}
{
  Scheme_Object *p, *base;
  ffi_type **elements, *libffi_type, **dummy;
  ctype_struct *type;
  ffi_cif cif;
  int i, nargs;
  nargs = scheme_proper_list_length(argv[0]);
  if (nargs < 0)
    scheme_wrong_type(MYNAME, "proper list", 0, argc, argv);
  /* allocate the type elements */
  elements = scheme_malloc((nargs+1) * sizeof(ffi_type*));
  elements[nargs] = NULL;
  for (i=0, p=argv[0]; i<nargs; i++, p=SCHEME_CDR(p)) {
    if (NULL == (base = get_ctype_base(SCHEME_CAR(p))))
      scheme_wrong_type(MYNAME, "list-of-C-types", 0, argc, argv);
    if (CTYPE_PRIMLABEL(base) == FOREIGN_void)
      scheme_wrong_type(MYNAME, "list-of-non-void-C-types", 0, argc, argv);
    elements[i] = CTYPE_PRIMTYPE(base);
  }
  /* allocate the new libffi type object */
  libffi_type = scheme_malloc(sizeof(ffi_type));
  libffi_type->size      = 0;
  libffi_type->alignment = 0;
  libffi_type->type      = FFI_TYPE_STRUCT;
  libffi_type->elements  = elements;
  /* use ffi_prep_cif to set the size and alignment information */
  dummy = &libffi_type;
  if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ffi_type_void, dummy) != FFI_OK)
    scheme_signal_error("internal error: ffi_prep_cif did not return FFI_OK");
  {:(cmake-object "type" ctype "NULL"
                  "(Scheme_Object*)libffi_type"
                  "(Scheme_Object*)FOREIGN_struct"):}
  return (Scheme_Object*)type;
}

/*****************************************************************************/
/* Pointer objects */
/* use cpointer (with a NULL tag when creating), #f for NULL */

#define SCHEME_FFIANYPTRP(x) \
  (SCHEME_FALSEP(x) || SCHEME_CPTRP(x) || SCHEME_FFIOBJP(x) || \
   SCHEME_BYTE_STRINGP(x))
#define SCHEME_FFIANYPTR_VAL(x) \
  (SCHEME_CPTRP(x) ? SCHEME_CPTR_VAL(x) : \
    (SCHEME_FALSEP(x) ? NULL : \
      (SCHEME_FFIOBJP(x) ? (((ffi_obj_struct*)x)->obj) : \
       SCHEME_BYTE_STRINGP(x) ? SCHEME_BYTE_STR_VAL(x) : \
         NULL)))

#define scheme_make_foreign_cpointer(x) \
  ((x==NULL)?scheme_false:scheme_make_cptr(x,NULL))

{:(cdefine cpointer? 1):}
{
  return SCHEME_FFIANYPTRP(argv[0]) ? scheme_true : scheme_false;
}

{:(cdefine cpointer-type 1):}
{
  Scheme_Object *type;
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "cpointer", 0, argc, argv);
  type = NULL;
  if (SCHEME_CPTRP(argv[0])) type = SCHEME_CPTR_TYPE(argv[0]);
  return (type==NULL) ? scheme_false : type;
}

{:(cdefine set-cpointer-type! 2):}
{
  if (!SCHEME_CPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "proper-cpointer", 0, argc, argv);
  SCHEME_CPTR_TYPE(argv[0]) = argv[1];
  return scheme_void;
}

/*****************************************************************************/
/* Callback type */

{:(cdefstruct ffi-callback
    (callback "void*")
    (proc     "Scheme_Object*")
    (itypes   "Scheme_Object*")
    (otype    "Scheme_Object*")):}

/*****************************************************************************/
/* Scheme<-->C conversions */

static Scheme_Object *c_to_scheme(Scheme_Object *type, void *src)
{
  Scheme_Object *res, *base;
  if (!SCHEME_CTYPEP(type))
    scheme_wrong_type("C->Scheme", "C-type", 0, 1, &type);
  base = CTYPE_BASETYPE(type);
  if (base != NULL) {
    res = c_to_scheme(base, src);
    if (SCHEME_FALSEP(CTYPE_USER_C2S(type)))
      return res;
    else
      return _scheme_apply(CTYPE_USER_C2S(type), 1, (Scheme_Object**)(&res));
  } else if (CTYPE_PRIMLABEL(type) == FOREIGN_fmark) {
    return (Scheme_Object*)src;
  } else switch (CTYPE_PRIMLABEL(type)) {
    {:(for-each-type
        (~ "case FOREIGN_"cname": return "
           (if ctype
             (let ([x (concat "(("ctype"*)src)[0]")])
               (if (string? c->s) (concat c->s"("x")") (c->s x)))
             "scheme_void")";")):}
    case FOREIGN_struct: return scheme_make_foreign_cpointer(src);
    default: scheme_signal_error("corrupt foreign type: %V", type);
  }
  return NULL; /* shush the compiler */
}

/* Usually writes the C object to dst and returns NULL.  When copy_structs is 0
 * (false) and the type is a struct, then return a pointer to the struct
 * object (not touching dst). */
static void* scheme_to_c(Scheme_Object *type, void *dst,
                         Scheme_Object *val, int copy_structs)
{
  if (!SCHEME_CTYPEP(type))
    scheme_wrong_type("Scheme->C", "C-type", 0, 1, &type);
  while (CTYPE_USERP(type)) {
    if (!SCHEME_FALSEP(CTYPE_USER_S2C(type)))
      val = _scheme_apply(CTYPE_USER_S2C(type), 1, (Scheme_Object**)(&val));
    type = CTYPE_BASETYPE(type);
  }
  if (CTYPE_PRIMLABEL(type) == FOREIGN_fmark) {
    if (SCHEME_FFICALLBACKP(val))
      ((void**)dst)[0] = ((ffi_callback_struct*)val)->callback;
    else if (SCHEME_CPTRP(val))
      ((void**)dst)[0] = SCHEME_CPTR_VAL(val);
    else if (SCHEME_FFIOBJP(val))
      ((void**)dst)[0] = ((ffi_obj_struct*)val)->obj;
    else /* ((void**)dst)[0] = val; */
         scheme_wrong_type("Scheme->C", "C-function-value", 0, 1, &val);
  } else switch (CTYPE_PRIMLABEL(type)) {
    {:(for-each-type
        (define (wrong-type obj type)
          (concat "scheme_wrong_type(\"Scheme->C\", \""type"\", "
                  "0, 1, &("obj"));"))
        (~ "case FOREIGN_"cname":")
        (if ctype
          (let* ([x (concat "((("ctype"*)dst)[0])")]
                 [f (lambda (p)
                      (if (string? p) (concat p"(val)") (p "val" x)))])
            (if s->c
              (~ "  if ("(f pred)") {" \\
                 "    "ctype" tmp;" \\
                 "    tmp = ("ctype")("(f s->c)");" \\
                 "    "x" = tmp;" \\
                 "  } else "(wrong-type "val" stype))
              (~ "  if (!("(pred "val" x)")) "(wrong-type "val" stype)))
            (~ "  return NULL;"))
          (~ "  "(wrong-type "type" "non-void-C-type")))):}
    case FOREIGN_struct:
      if (!SCHEME_FFIANYPTRP(val))
        scheme_wrong_type("Scheme->C", "pointer", 0, 1, &val);
      if (copy_structs) {
        memcpy(dst, SCHEME_FFIANYPTR_VAL(val), CTYPE_PRIMTYPE(type)->size);
        return NULL;
      } else {
        return SCHEME_FFIANYPTR_VAL(val);
      }
    default: scheme_signal_error("corrupt foreign type: %V", type);
  }
  return NULL; /* shush the compiler */
}

/*****************************************************************************/
/* Pointer type user functions */

/* (ctype-sizeof type) -> int, returns 0 for void, error if not a C type */
{:(cdefine ctype-sizeof 1):}
{
  int size;
  size = ctype_sizeof(argv[0]);
  if (size >= 0) return scheme_make_integer(size);
  else scheme_wrong_type(MYNAME, "C-type", 0, argc, argv);
  return NULL; /* shush the compiler */
}

/* (ctype-alignof type) -> int, returns 0 for void, error if not a C type */
{:(cdefine ctype-alignof 1):}
{
  Scheme_Object *type;
  type = get_ctype_base(argv[0]);
  if (type == NULL) scheme_wrong_type(MYNAME, "C-type", 0, argc, argv);
  else return scheme_make_integer(CTYPE_PRIMTYPE(type)->alignment);
  return NULL; /* shush the compiler */
}

{:(defsymbols atomic stubborn uncollectable eternal fail-ok):}

/* (malloc num type cpointer mode) -> pointer */
/* The arguments for this function are:
 * - num: bytes to allocate, or the number of instances of type when given,
 * - type: malloc the size of this type (or num instances of it),
 * - cpointer: a source pointer to copy contents from,
 * - mode: a symbol for different allocation functions to use - one of
 *   'atomic, 'stubborn, 'uncollectable, 'eternal
 * - if an additional 'fail-ok flag is given, then scheme_malloc_fail_ok is
 *   used with the chosen malloc function
 * The arguments can be specified in any order at all since they are all
 * different types, the only requirement is for a size, either a number of
 * bytes or a type. */
{:(cdefine malloc 1 4):}
{
  int i, size=0, num=0, failok=0;
  void *from = NULL, *res = NULL;
  Scheme_Object *mode = NULL, *a;
  void *(*mf)(size_t);
  for (i=0; i<argc; i++) {
    a = argv[i];
    if (SCHEME_INTP(a)) {
      if (num != 0)
        scheme_signal_error(MYNAME": specifying a second integer size: %V", a);
      num = SCHEME_INT_VAL(a);
      if (num <= 0)
        scheme_wrong_type(MYNAME, "positive-integer", 0, argc, argv);
    } else if (SCHEME_CTYPEP(a)) {
      if (size != 0)
        scheme_signal_error(MYNAME": specifying a second type: %V", a);
      size = ctype_sizeof(a);
      if (size < 0)
        scheme_wrong_type(MYNAME, "C-type", i, argc, argv);
      else if (size == 0)
        scheme_wrong_type(MYNAME, "non-void-C-type", i, argc, argv);
    } else if (SAME_OBJ(a, fail_ok_sym)) {
      failok = 1;
    } else if (SCHEME_SYMBOLP(a)) {
      if (mode != NULL)
        scheme_signal_error(MYNAME": specifying a second mode symbol: %V", a);
      mode = a;
    } else if (SCHEME_FFIANYPTRP(a) && !SCHEME_FALSEP(a)) {
      if (from != NULL)
        scheme_signal_error(MYNAME": specifying a second source pointer: %V",
                            a);
      from = SCHEME_FFIANYPTR_VAL(a);
    } else {
      scheme_wrong_type(MYNAME, "malloc-argument", i, argc, argv);
    }
  }
  if ((num == 0) && (size == 0)) scheme_signal_error(MYNAME": no size given");
  size = ((size==0) ? 1 : size) * ((num==0) ? 1 : num);
  if (mode == NULL)                           mf = scheme_malloc;
  else if (SAME_OBJ(mode, atomic_sym))        mf = scheme_malloc_atomic;
  else if (SAME_OBJ(mode, stubborn_sym))      mf = scheme_malloc_stubborn;
  else if (SAME_OBJ(mode, eternal_sym))       mf = scheme_malloc_eternal;
  else if (SAME_OBJ(mode, uncollectable_sym)) mf = scheme_malloc_uncollectable;
  else {
    scheme_signal_error(MYNAME": bad allocation mode: %V", mode);
    return NULL; /* shush the compiler */
  }
  if (failok) res = scheme_malloc_fail_ok(mf,size); else res = mf(size);
  if ((from != NULL) && (res != NULL)) memcpy(res, from, size);
  return scheme_make_foreign_cpointer(res);
}

/* (end-stubborn-change ptr) */
{:(cdefine end-stubborn-change 1):}
{
  void *ptr;
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "cpointer", 0, argc, argv);
  ptr = SCHEME_FFIANYPTR_VAL(argv[0]);
  if (ptr == NULL)
    scheme_wrong_type(MYNAME, "non-null-cpointer", 0, argc, argv);
  scheme_end_stubborn_change(ptr);
  return scheme_void;
}

{:(defsymbols abs):}

/* (ptr-ref cpointer type [[abs] n]) -> the object at the given location */
/* n defaults to 0 which is the only value that should be used with ffi_objs */
/* if n is given, an 'abs flag can precede it to make n be a byte offset rather
 * than some multiple of sizeof(type). */
/* WARNING: there are *NO* checks at all, this is raw C level code. */
{:(cdefine ptr-ref 2 4):}
{
  int size=0; void *ptr; Scheme_Object *base;
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "cpointer", 0, argc, argv);
  ptr = SCHEME_FFIANYPTR_VAL(argv[0]);
  if (ptr == NULL)
    scheme_wrong_type(MYNAME, "non-null-cpointer", 0, argc, argv);
  if (NULL == (base = get_ctype_base(argv[1])))
    scheme_wrong_type(MYNAME, "C-type", 1, argc, argv);
  else size = ctype_sizeof(base);
  if (CTYPE_PRIMLABEL(base) == FOREIGN_fmark) {
    if (argc > 2)
      scheme_signal_error
        (MYNAME": referencing a special value with extra arguments");
    else
      ptr = argv[0];
  } else if (size < 0) {
    /* should not happen */
    scheme_wrong_type(MYNAME, "C-type", 1, argc, argv);
  } else if (size == 0) {
    scheme_wrong_type(MYNAME, "non-void-C-type", 1, argc, argv);
  } else if (argc > 3) {
    if (!SAME_OBJ(argv[2],abs_sym))
      scheme_wrong_type(MYNAME, "abs-flag", 2, argc, argv);
    if (!SCHEME_INTP(argv[3]))
      scheme_wrong_type(MYNAME, "integer", 3, argc, argv);
    ptr = (char*)ptr XFORM_OK_PLUS SCHEME_INT_VAL(argv[3]);
  } else if (argc > 2) {
    if (!SCHEME_INTP(argv[2]))
      scheme_wrong_type(MYNAME, "integer", 2, argc, argv);
    ptr = (char*)ptr XFORM_OK_PLUS (size * SCHEME_INT_VAL(argv[2]));
  }
  return c_to_scheme(argv[1], ptr);
}

/* (ptr-set! cpointer type [[abs] n] value) -> void */
/* n defaults to 0 which is the only value that should be used with ffi_objs */
/* if n is given, an 'abs flag can precede it to make n be a byte offset rather
 * than some multiple of sizeof(type). */
/* WARNING: there are *NO* checks at all, this is raw C level code. */
{:(cdefine ptr-set! 3 5):}
{
  int size=0; void *ptr;
  Scheme_Object *val = argv[argc-1], *base;
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "cpointer", 0, argc, argv);
  ptr = SCHEME_FFIANYPTR_VAL(argv[0]);
  if (ptr == NULL)
    scheme_wrong_type(MYNAME, "non-null-cpointer", 0, argc, argv);
  if (NULL == (base = get_ctype_base(argv[1])))
    scheme_wrong_type(MYNAME, "C-type", 1, argc, argv);
  else size = ctype_sizeof(base);
  if (CTYPE_PRIMLABEL(base) == FOREIGN_fmark) {
    if (argc > 3) {
      scheme_signal_error
        (MYNAME": referencing a special value with extra arguments");
    } else if (SCHEME_CPTRP(argv[0])) {
      ptr = SCHEME_CPTR_VAL(argv[0]);
    } else if SCHEME_FFIOBJP(argv[0]) {
      ptr = ((ffi_obj_struct*)(argv[0]))->obj;
    } else {
      scheme_signal_error
        (MYNAME": bad lvalue (NULL or string)");
    }
  } else if (size < 0) {
    /* should not happen */
    scheme_wrong_type(MYNAME, "C-type", 1, argc, argv);
  } else if (size == 0) {
    scheme_wrong_type(MYNAME, "non-void-C-type", 1, argc, argv);
  } else if (argc > 4) {
    if (!SAME_OBJ(argv[2],abs_sym))
      scheme_wrong_type(MYNAME, "abs-flag", 2, argc, argv);
    if (!SCHEME_INTP(argv[3]))
      scheme_wrong_type(MYNAME, "integer", 3, argc, argv);
    ptr = (char*)ptr XFORM_OK_PLUS SCHEME_INT_VAL(argv[3]);
  } else if (argc > 3) {
    if (!SCHEME_INTP(argv[2]))
      scheme_wrong_type(MYNAME, "integer", 2, argc, argv);
    ptr = (char*)ptr XFORM_OK_PLUS (size * SCHEME_INT_VAL(argv[2]));
  }
  scheme_to_c(argv[1], ptr, val, 1);
  return scheme_void;
}

/* (ptr-equal? cpointer cpointer) -> boolean */
{:(cdefine ptr-equal? 2 2):}
{
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "cpointer", 0, argc, argv);
  if (!SCHEME_FFIANYPTRP(argv[1]))
    scheme_wrong_type(MYNAME, "cpointer", 1, argc, argv);
  return (SAME_OBJ(argv[0],argv[1]) ||
          (SCHEME_FFIANYPTR_VAL(argv[0]) == SCHEME_FFIANYPTR_VAL(argv[1])))
         ? scheme_true : scheme_false;
}

/* (make-sized-byte-string cpointer len) */
{:(cdefine make-sized-byte-string 2 2):}
/* Warning: no copying is done so it is possible to share string contents. */
/* (Should use real byte-strings with new version.) */
{
  long len;
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "cpointer", 0, argc, argv);
  if (!scheme_get_int_val(argv[1],&len))
    scheme_wrong_type(MYNAME, "integer in a C long range", 1, argc, argv);
  if (SCHEME_FALSEP(argv[0])) return scheme_false;
  else return
         scheme_make_sized_byte_string(SCHEME_FFIANYPTR_VAL(argv[0]), len, 0);
}

/* internal: apply Scheme finalizer */
void do_scm_finalizer(void *p, void *finalizer)
{
  Scheme_Object *f = (Scheme_Object*)finalizer;
  if (!SCHEME_FALSEP(f)) _scheme_apply(f, 1, (Scheme_Object**)(void*)(&p));
}
void do_ptr_finalizer(void *p, void *finalizer)
{
  Scheme_Object *f = (Scheme_Object*)finalizer;
  Scheme_Object *ptr;
  if (p == NULL) return;
  ptr = scheme_make_cptr(p,NULL);
  if (!SCHEME_FALSEP(f)) _scheme_apply(f, 1, (Scheme_Object**)(&ptr));
  /* don't leave dangling references! */
  SCHEME_CPTR_VAL(ptr) = NULL;
  ptr = NULL;
}

{:(defsymbols pointer):}

/* (register-finalizer ptrobj finalizer [scheme]) -> old-finalizer */
/* The finalizer is called by the primitive finalizer mechanism, make sure */
/* no references to the object are recreated.  #f means erase existing */
/* finalizer if any.*/
/* If two arguments are used, this is used with any Scheme object, and the */
/* finalizer will be called on it.  If a third argument of 'pointer is used, */
/* the object must be an cpointer object, the finalizer will be invoked when */
/* the pointer itself is unreachable, and it will get a new cpointer object */
/* that points to it.  (Only needed in systems where pointer aliases might */
/* be created.) */
{:(cdefine register-finalizer 2 3):}
{
  void *ptr, *old = NULL;
  int ptrsym = (argc == 3 && argv[2] == pointer_sym);
  if (ptrsym) {
    if (!SCHEME_FFIANYPTRP(argv[0]))
      scheme_wrong_type(MYNAME, "cpointer", 0, argc, argv);
    ptr = SCHEME_FFIANYPTR_VAL(argv[0]);
    if (ptr == NULL)
      scheme_wrong_type(MYNAME, "non-null-cpointer", 0, argc, argv);
  } else {
    if (argc == 3)
      scheme_wrong_type(MYNAME, "pointer-mode", 2, argc, argv);
    ptr = argv[0];
  }
  if (!(SCHEME_FALSEP(argv[1]) || SCHEME_PROCP(argv[1])))
    scheme_wrong_type(MYNAME, "procedure-or-false", 1, argc, argv);
  scheme_register_finalizer
    (argv[0], (ptrsym ? do_ptr_finalizer : do_scm_finalizer),
     argv[1], NULL, &old);
  return (old == NULL) ? scheme_false : (Scheme_Object*)old;
}

/*****************************************************************************/
/* Calling foreign function objects */

#define MAX_QUICK_ARGS 16

Scheme_Object *ffi_do_call(void *data, int argc, Scheme_Object *argv[])
/* data := {name, c-function, itypes, otype, cif} */
{
  /* The name is not currently used */
  /* char *name = SCHEME_BYTE_STR_VAL(((Scheme_Object**)data)[0]); */
  void          *c_func = (void*)(((Scheme_Object**)data)[1]);
  Scheme_Object *itypes = ((Scheme_Object**)data)[2];
  Scheme_Object *otype  = ((Scheme_Object**)data)[3];
  Scheme_Object *base;
  ffi_cif       *cif    = (ffi_cif*)(((Scheme_Object**)data)[4]);
  int           nargs   = cif->nargs;
  GC_CAN_IGNORE ForeignAny oval, *ivals;
  void **avalues, *p;
  ForeignAny stack_ivals[MAX_QUICK_ARGS];
  void *stack_avalues[MAX_QUICK_ARGS];
  int i;
  if (nargs <= MAX_QUICK_ARGS) {
    ivals   = stack_ivals;
    avalues = stack_avalues;
  } else {
    ivals   = scheme_malloc(nargs * sizeof(ForeignAny));
    avalues = scheme_malloc(nargs * sizeof(void*));
  }
  /* iterate on input values and types */
  for (i=0; i<nargs; i++, itypes=SCHEME_CDR(itypes)) {
    /* convert argv[i] according to current itype */
    p = scheme_to_c(SCHEME_CAR(itypes), &(ivals[i]), argv[i], 0);
    /* Establish links from avalues to the actual ivals */
    avalues[i] = (p == NULL) ? (&(ivals[i])) : p;
  }
  base = get_ctype_base(otype); /* verified below, so cannot be NULL */
  /* If this is a struct return value, then need to malloc in any case, even if
   * the size is smaller than ForeignAny, because this value will be
   * returned. */
  p = (CTYPE_PRIMLABEL(base) == FOREIGN_struct)
        ? scheme_malloc(CTYPE_PRIMTYPE(base)->size)
        : &oval;
  /* call the function */
  ffi_call(cif, c_func, p, avalues);
  if (CTYPE_PRIMLABEL(base) == FOREIGN_fmark) {
    /* need to allocate a pointer */
    p = scheme_make_foreign_cpointer(oval.x_pointer);
  }
  return c_to_scheme(otype, p);
}

/* (ffi-call ffi-obj in-types out-type) -> (in-types -> out-value) */
/* the real work is done by ffi_do_call above */
{:(cdefine ffi-call 3 3):}
{
  static Scheme_Object *ffi_name_prefix = NULL;
  Scheme_Object *itypes = argv[1];
  Scheme_Object *otype  = argv[2];
  Scheme_Object *obj, **data, *p, *base;
  ffi_type *rtype, **atypes;
  ffi_cif *cif;
  int i, nargs;
  if (!ffi_name_prefix)
    ffi_name_prefix = scheme_make_byte_string_without_copying("ffi:");
  if (!SCHEME_FFIANYPTRP(argv[0]))
    scheme_wrong_type(MYNAME, "ffi-obj-or-cpointer", 0, argc, argv);
  obj = SCHEME_FFIANYPTR_VAL(argv[0]);
  if (obj == NULL)
    scheme_wrong_type(MYNAME, "non-null-cpointer", 0, argc, argv);
  nargs = scheme_proper_list_length(itypes);
  if (nargs < 0)
    scheme_wrong_type(MYNAME, "proper list", 1, argc, argv);
  if (NULL == (base = get_ctype_base(otype)))
    scheme_wrong_type(MYNAME, "C-type", 2, argc, argv);
  rtype = CTYPE_PRIMTYPE(base);
  atypes = scheme_malloc(nargs * sizeof(ffi_cif));
  for (i=0, p=itypes; i<nargs; i++, p=SCHEME_CDR(p)) {
    if (NULL == (base = get_ctype_base(SCHEME_CAR(p))))
      scheme_wrong_type(MYNAME, "list-of-C-types", 1, argc, argv);
    if (CTYPE_PRIMLABEL(base) == FOREIGN_void)
      scheme_wrong_type(MYNAME, "list-of-non-void-C-types", 1, argc, argv);
    atypes[i] = CTYPE_PRIMTYPE(base);
  }
  cif = scheme_malloc(sizeof(ffi_cif));
  if (ffi_prep_cif(cif, FFI_DEFAULT_ABI, nargs, rtype, atypes) != FFI_OK)
    scheme_signal_error("internal error: ffi_prep_cif did not return FFI_OK");
  data = scheme_malloc(5 * sizeof(void*));
  p = scheme_append_byte_string
        (ffi_name_prefix,
         scheme_make_byte_string_without_copying
           (SCHEME_FFIOBJP(argv[0]) ?
             ((ffi_obj_struct*)(argv[0]))->name : "proc"));
  data[0] = p;
  data[1] = obj;
  data[2] = itypes;
  data[3] = otype;
  data[4] = (Scheme_Object*)cif;
  return scheme_make_closed_prim_w_arity
           (ffi_do_call, (void*)data, SCHEME_BYTE_STR_VAL(data[0]),
            nargs, nargs);
}

/*****************************************************************************/
/* Scheme callbacks */

void ffi_do_callback(ffi_cif* cif, void* resultp, void** args, void *userdata)
{
  ffi_callback_struct *data = (ffi_callback_struct*)userdata;
  Scheme_Object *argv_stack[MAX_QUICK_ARGS];
  int argc = cif->nargs, i;
  Scheme_Object **argv, *p, *v;
  if (argc <= MAX_QUICK_ARGS)
    argv = argv_stack;
  else
    argv = scheme_malloc(argc * sizeof(Scheme_Object*));
  for (i=0, p=data->itypes; i<argc; i++, p=SCHEME_CDR(p)) {
    v = c_to_scheme(SCHEME_CAR(p),args[i]);
    argv[i] = v;
  }
  p = _scheme_apply(data->proc, argc, argv);
  scheme_to_c(data->otype, resultp, p, 1);
}

/* (ffi-callback scheme-proc in-types out-type) -> ffi-callback */
/* the treatment of in-types and out-types is similar to that in ffi-call */
/* the real work is done by ffi_do_callback above */
{:(cdefine ffi-callback 3 3):}
{
  ffi_callback_struct *data;
  Scheme_Object *itypes = argv[1];
  Scheme_Object *otype = argv[2];
  Scheme_Object *p, *base;
  int nargs, i;
  ffi_type *rtype, **atypes;
  ffi_cif *cif;
  ffi_closure *cl;
  if (!SCHEME_PROCP(argv[0]))
    scheme_wrong_type(MYNAME, "procedure", 0, argc, argv);
  nargs = scheme_proper_list_length(itypes);
  if (nargs < 0)
    scheme_wrong_type(MYNAME, "proper list", 1, argc, argv);
  if (NULL == (base = get_ctype_base(otype)))
    scheme_wrong_type(MYNAME, "C-type", 2, argc, argv);
  rtype = CTYPE_PRIMTYPE(base);
  atypes = scheme_malloc(nargs * sizeof(ffi_cif));
  for (i=0, p=itypes; i<nargs; i++, p=SCHEME_CDR(p)) {
    if (NULL == (base = get_ctype_base(SCHEME_CAR(p))))
      scheme_wrong_type(MYNAME, "list-of-C-types", 1, argc, argv);
    if (CTYPE_PRIMLABEL(base) == FOREIGN_void)
      scheme_wrong_type(MYNAME, "list-of-non-void-C-types", 1, argc, argv);
    atypes[i] = CTYPE_PRIMTYPE(base);
  }
  cif = scheme_malloc(sizeof(ffi_cif));
  if (ffi_prep_cif(cif, FFI_DEFAULT_ABI, nargs, rtype, atypes) != FFI_OK)
    scheme_signal_error("internal error: ffi_prep_cif did not return FFI_OK");
  cl = scheme_malloc(sizeof(ffi_closure));
  {:(cmake-object "data" ffi-callback
                  "cl" "argv[0]" "argv[1]" "argv[2]"):}
  if (ffi_prep_closure(cl, cif, &ffi_do_callback, (void*)data) != FFI_OK)
    scheme_signal_error
      ("internal error: ffi_prep_closure did not return FFI_OK");
  return (Scheme_Object*)data;
}

/*****************************************************************************/
/* Initialization */

void scheme_init_foreign(Scheme_Env *env)
{
  Scheme_Env *menv;
  ctype_struct *t;
  menv = scheme_primitive_module(scheme_intern_symbol("#%foreign"), env);
  {:(for-each (lambda (x)
                (~ (cadr x)"_tag = scheme_make_type(\"<"(car x)">\");"))
              (reverse cstructs)):}
#ifdef MZ_PRECISE_GC
  {:(for-each (lambda (x)
                (~ "GC_register_traversers("(cadr x)"_tag, "(cadr x)"_SIZE, "
                   (cadr x)"_MARK, " (cadr x)"_FIXUP, 1, 0);"))
              (reverse cstructs)):}
#endif
  MZ_REGISTER_STATIC(opened_libs);
  opened_libs = scheme_make_hash_table(SCHEME_hash_string);
  {:(for-each
     (lambda (sym)
       (~ "MZ_REGISTER_STATIC("(cadr sym)");" \\
	  (cadr sym)" = scheme_intern_symbol(\""(car sym)"\");"))
     (reverse symbols)):}
  {:(for-each
      (lambda (x)
        (~ "scheme_add_global(\""(car x)"\"," \\
           "  scheme_make_prim_w_arity("
                (cadr x)", \""(car x)"\", "(caddr x)", "(cadddr x)"), menv);"))
      (reverse! cfunctions))
    (for-each-type -all-
      (if alias
        (~ "scheme_add_global(\"_"(car alias)"\", scheme_lookup_global"
           "(scheme_intern_symbol(\"_"(cadr alias)"\"),menv), "
           "menv);")
        (begin (cmake-object "t" ctype "NULL"
                 (concat "(Scheme_Object*)(void*)(&ffi_type_"ftype")")
                 (concat "(Scheme_Object*)FOREIGN_"cname))
               (~ "scheme_add_global(\"_"stype"\", (Scheme_Object*)t, "
                  "menv);")))):}
  scheme_finish_primitive_module(menv);
}

/*****************************************************************************/
