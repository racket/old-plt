# File:         makewat.env
# Purpose:      Watcom environments for wxWindows makefiles.
# Author:       Julian Smart and others
#
# The main things to change are:
#
#   WATCOM:    set to where the compiler is installed
#   WXDIR:     set to where the wxWindows is installed
#   MODE:      set to windows [16 bit windows], nt [win32s], or win386 [32-bit non-WIN32]

FINAL=0
WATCOM=f:\watcom
#.EXTENSIONS: .exe .obj .c .cc .res .rc .def

# Set this to win386 if compiling under WIN386 mode, or
# to windows for normal 16-bit Windows
MODE= nt #windows #win386 #nt

WXDIR = c:\wx
WXINC = $(WXDIR)\include\msw
WXBASEINC = $(WXDIR)\include\base
# Don't bother try using precompiled headers: Watcom's
# PCH consistency requirements are too stringent.
#PRECOMP     = /fh=watcom.pch
RC = wrc

!ifeq MODE win386

##### WIN386 OPTIONS

# Set LEVEL to 386 if using 32-bit compilation
LEVEL       = 386
CCC         = wpp$(LEVEL)
CC         =  wcc$(LEVEL)
OS_TARGET   = win386
MODEL       =
LINKOPTION  = win386
BINDCOMMAND = wbind
WATLIBDIR = $(WATCOM)\lib386\win
MINDATA     = option mindata=100K
MAXDATA     = option maxdata=100K
STACK       = option stack=64k
EXTRALIBS   =
IFLAGS      = -i=$(WXINC) -i=$(WXBASEINC) -i=$(WXDIR)\contrib\fafa 
RESFLAGS1   = -r -bt=windows
RESFLAGS2   =

#-i=$(WXDIR)\contrib\itsybits

#CPPFLAGS    = /zw /w1 /zq /d2 /zt4 $(MODEL) /dwx_msw
CPPFLAGS    = /zw /w1 /zq /d2 $(MODEL) /dwx_msw $(EXTRACPPFLAGS)

!endif
#### END WIN386 MODE

!ifeq MODE windows

##### 16-BIT WINDOWS OPTIONS

# Set LEVEL to 386 if using 32-bit compilation
LEVEL       =
CCC         = wpp$(LEVEL)
CC          = wcc$(LEVEL)
OS_TARGET   = windows
MODEL       =/ml
LINKOPTION  = windows
BINDCOMMAND = echo
WATLIBDIR = $(WATCOM)\lib286\win
MINDATA     =
MAXDATA     =
STACK       =
EXTRALIBS=$(WATLIBDIR)\shell.lib $(WATLIBDIR)\ddeml.lib $(WATLIBDIR)\ctl3d.lib $(WATLIBDIR)\commdlg.lib $(WATLIBDIR)\mmsystem.lib
IFLAGS      = -i=$(WXINC) -i=$(WXBASEINC) -i=$(WXDIR)\contrib\fafa 
RESFLAGS1   = -r -bt=windows
RESFLAGS2   =

#-i=$(WXDIR)\contrib\itsybits

# Note: I've added the data threshold (/zt4) for 16-bit operation,
# or we get link failure (TEXT segment overflow). Is this OK for
# 32-bit mode also? -- JACS
# An alternative might be /zc (put string literals in code segment).
#CPPFLAGS    = /zw /w1 /zq /d2 /zt4 $(MODEL) /dwx_msw
CPPFLAGS    = /zw /w2 /zq /d2 $(MODEL) /dwx_msw $(EXTRACPPFLAGS)

!endif
#### END WINDOWS MODE

!ifeq MODE nt

##### NT OPTIONS

LEVEL       = 386
CCC         = wpp$(LEVEL)
CC         =  wcc$(LEVEL)
OS_TARGET   = nt_win
MODEL       =
LINKOPTION  = nt_win
BINDCOMMAND = wrc
WATLIBDIR   = $(WATCOM)\lib386\nt
MINDATA     =
MAXDATA     =
STACK       = option stack=64k
EXTRALIBS   =
IFLAGS      = -i=$(WXINC) -i=$(WXBASEINC) -i=$(WXDIR)\contrib\fafa 
RESFLAGS1   = -r -bt=nt
RESFLAGS2   =

#-i=$(WXDIR)\contrib\itsybits

CPPFLAGS    = /bt=nt /w1 /DWIN32 /zq /d2 $(MODEL) /dwx_msw $(EXTRACPPFLAGS)

!endif
#### END NT MODE

.cc.obj: $< # .AUTODEPEND
    *$(CCC) $(CPPFLAGS) $(IFLAGS) $<

#    %create tmp.lbc
#    @%append tmp.lbc $(CPPFLAGS) $(IFLAGS) $<
#    echo $<
#    $(CCC) @tmp.lbc

.c.obj: $< # .AUTODEPEND
    *$(CC) $(CPPFLAGS) $(IFLAGS) $<

# This doesn't work for wcc
#    %create tmp.lbc
#    @%append tmp.lbc $(CPPFLAGS) $(IFLAGS) $<
#    echo $<
#    $(CC) @tmp.lbc
