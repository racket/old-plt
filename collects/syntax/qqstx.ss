(module qqstx mzscheme
  (provide quasisyntax
           unsyntax
           unsyntax-splicing)
  (require "stx.ss")
  (require-for-syntax "stx.ss")
  
  (define-syntaxes (unsyntax unsyntax-splicing)
    (let ([f (lambda (stx)
	       (raise-syntax-error
		#f
		"illegal outside of quasisyntax"
		stx
		#f))])
      (values f f)))

  (define (check-splicing-list l)
    (unless (stx-list? l)
      (raise-type-error
       'unsyntax-splicing
       "proper syntax list"
       l))
    l)

  (define-syntax (quasisyntax orig-stx)
    (let ([body (syntax-case orig-stx ()
                  [(_ stx) (syntax stx)])]
	  [here-stx #'here])
      (let loop ([stx body]
                 [depth 0]
                 [same-k (lambda ()
			   (datum->syntax-object 
			    here-stx
			    (list (quote-syntax syntax) body)
			    orig-stx))]
                 [convert-k (lambda (body bindings)
			      (datum->syntax-object 
			       here-stx
			       (list
				(quote-syntax with-syntax)
				bindings
				(list (quote-syntax syntax) body))
			       orig-stx))])
        (syntax-case stx (unsyntax unsyntax-splicing quasisyntax)
          [(unsyntax x)
           (if (zero? depth)
	       (let ([temp (car (generate-temporaries '(uq)))])
		 (convert-k temp (list (list temp (syntax x)))))
	       (loop (syntax x) (sub1 depth)
		     same-k
		     (lambda (v bindings)
		       (convert-k (datum->syntax-object
				   here-stx
				   (list (stx-car stx) v)
				   stx)
				  bindings))))]
          [unsyntax
           (raise-syntax-error
            #f
            "misuse within quasisyntax"
            orig-stx
            stx)]
          [((unsyntax-splicing x) . rest)
           (if (zero? depth)
	       (let ([rest-done-k
		      (lambda (rest-v bindings)
			(with-syntax ([temp (car (generate-temporaries '(uqs)))])
			  (convert-k (datum->syntax-object
				      stx
				      (list* (syntax temp)
					     (quote-syntax ...)
					     rest-v)
				      stx)
				     (cons (syntax ((temp (... ...)) (check-splicing-list x)))
					   bindings))))])
		 (loop (syntax rest) depth
		       (lambda ()
			 (rest-done-k (syntax rest) null))
		       rest-done-k))
	       (let ([mk-rest-done-k
		      (lambda (x-v x-bindings)
			(lambda (rest-v rest-bindings)
			  (convert-k (datum->syntax-object
				      stx
				      (list x-v rest-v)
				      stx)
				     (append x-bindings
					     rest-bindings))))])
		 (loop (syntax x) (sub1 depth)
		       (lambda ()
			 ;; x is unchanged.
			 (loop (syntax rest) depth
			       same-k
			       (mk-rest-done-k (stx-car stx) null)))
		       (lambda (x-v x-bindings)
			 ;; x is generated by x-v
			 (let ([rest-done-k (mk-rest-done-k x-v x-bindings)])
			   (loop (syntax rest) depth
				 (lambda ()
				   ;; rest is unchanged
				   (rest-done-k (syntax rest) null))
				 rest-done-k))))))]
          [unsyntax-splicing
           (raise-syntax-error
            #f
            "misuse within quasisyntax"
            orig-stx
            stx)]
          [(quasisyntax x)
	   (loop (syntax x) (add1 depth)
		 same-k
		 (lambda (v bindings)
		   (convert-k (datum->syntax-object
			       stx
			       (list (stx-car stx) v)
			       stx)
			      bindings)))]
          [_else
           (cond
	    ;; We treat pairs specially so that we don't generate a lot
	    ;;  of syntax objects when the input syntax collapses a list
	    ;;  into a single syntax object.
	    [(pair? (syntax-e stx))
	     (let ploop ([l (syntax-e stx)]
			 [same-k same-k]
			 [convert-k (lambda (l bindings)
				      (convert-k (datum->syntax-object
						  stx
						  l
						  stx)
						 bindings))])
	       (cond
		[(pair? l)
		 (if (and (stx-pair? (car l))
			  (module-identifier=? (stx-car (car l)) (quote-syntax unsyntax-splicing)))
		     ;; Found an `unsyntax-splicing'; stop the special
		     ;; handling for pairs
		     (loop (datum->syntax-object #f l #f) depth
			   same-k 
			   convert-k)
		     ;; Normal special pair handling
		     (ploop (cdr l)
			    (lambda ()
			      ;; rest is the same
			      (loop (car l) depth
				    same-k
				    (lambda (a a-bindings)
				      (convert-k (cons a (cdr l))
						 a-bindings))))
			    (lambda (rest rest-bindings)
			      (loop (car l) depth
				    (lambda ()
				      (convert-k (cons (car l) rest)
						 rest-bindings))
				    (lambda (a a-bindings)
				      (convert-k (cons a rest)
						 (append a-bindings
							 rest-bindings)))))))]
		[(null? l) (same-k)]
		[else (loop l depth same-k convert-k)]))]
             [(vector? (syntax-e stx))
	      (loop (datum->syntax-object
		     stx
		     (vector->list (syntax-e stx))
		     stx)
		    depth
		    same-k
		    (lambda (v bindings)
		      (convert-k (datum->syntax-object
				  stx
				  (list->vector (syntax->list v))
				  stx)
				 bindings)))]
             [else
              (same-k)])])))))
