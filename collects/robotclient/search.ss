(module search mzscheme
  
  (require (lib "list.ss"))
  
  (require "board.ss"
           "client-parameters.ss"
           "heuristics.ss"
           "weights.scm")
  
  (provide compute-move best-cmd)
  
  (define (weight-from-goal x) (* (step-weight) x))
  
  ;(make-qelt qelt move qelt)
  (define-struct qelt (left move right))
  
  ;(make-move num num num cord num command)
  (define-struct move (weight x y back step orig))
  ;(make-cord num num)
  (define-struct cord (x y))
  
  (define current-player (make-parameter null))
  
  (define best-cmd (make-parameter null))
  (define best-weight (make-parameter -inf.0))
  (define last-move (make-parameter null))
  
  (define queue-head (make-parameter null))
  (define in-queue (make-parameter 0))
  
  (define (enqueue move)
    (cond
      ((void? move) (void))
      ((null? (queue-head)) 
       (best-cmd (move-orig move))
       (best-weight (move-weight move))

       (queue-head (make-qelt null move null))
       (in-queue 1))
      (else
       (let loop ((current (queue-head)))
         (if (> (move-weight move) (move-weight (qelt-move current)))
             (let ((q (make-qelt (qelt-left current) move current)))
               (cond 
                 ((and (= (in-queue) 6) (eq? current (queue-head)))
                  (when (> (move-weight move) (best-weight))
                    (best-cmd (move-orig move))
                    (best-weight (move-weight move)))
                  (queue-head q)
                  (set-qelt-left! current q)
                  (remove-queue-tail))
                 ((= (in-queue) 6)
                  (set-qelt-left! current q)
                  (set-qelt-right! (qelt-left q) q)
                  (remove-queue-tail))
                 ((eq? current (queue-head))
                  (when (> (move-weight move) (best-weight))
                    (best-cmd (move-orig move))
                    (best-weight (move-weight move)))
                  (queue-head q)
                  (set-qelt-left! current q)
                  (in-queue (add1 (in-queue))))
                 (else
                  (set-qelt-left! current q)
                  (set-qelt-right! (qelt-left q) q)
                  (in-queue (add1 (in-queue))))))
             (if (null? (qelt-right current))
                 (when (< (in-queue) 6)
                   (let ((q (make-qelt current move null)))
                     (set-qelt-right! current q)
                     (in-queue (add1 (in-queue)))))
                 (loop (qelt-right current))))))))
  
  (define (dequeue)
    (let ((current (queue-head)))
      (queue-head (qelt-right current))
      (unless (null? (queue-head)) (set-qelt-left! (queue-head) null))
      (in-queue (sub1 (in-queue)))
      (qelt-move current)))
  
  (define (remove-queue-tail)
    (let loop ((current (queue-head)))
      (if (null? (qelt-right current))
          (set-qelt-right! (qelt-left current) null)
          (loop (qelt-right current)))))
  
  (define (get-move-weight x y)
    (let-values (((weight bid _ __) (calc-weight 'M x y (current-player) null)))
      (values weight bid)))
  
  (define (move-maker weighted-g back g command?)
    (lambda (weight x y bid . special)
      (make-move (+ weighted-g weight) x y back g (if command? command? (make-command bid (car special) (cadr special))))))
  
  (define (generate-first-moves x y packages)
    (let ((maker (move-maker 0 (make-cord x y) 1 #f))
          (old-x (cord-x (last-move)))
          (old-y (cord-y (last-move))))
      (let-values (((p-weight p-bid _ p) (calc-weight 'P x y (current-player) packages))
                   ((d-weight d-bid d __) (if (not (null? (search-player-packages (current-player))))
                                              (calc-weight 'D x y (current-player) null)
                                              (values #f void null void)))
                   ((w-weight w-bid) (if (and (> x 1)
                                              (not (and (= old-x (sub1 x))
                                                        (= old-y y))))
                                         (get-move-weight (sub1 x) y) (values #f void)))
                   ((e-weight e-bid) (if (and (< x (board-width))
                                              (not (and (= old-x (add1 x))
                                                        (= old-y y))))
                                         (get-move-weight (add1 x) y) (values #f void)))
                   ((s-weight s-bid) (if (and (> y 1)
                                              (not (and (= old-x x)
                                                        (= old-y (sub1 y)))))
                                         (get-move-weight x (sub1 y)) (values #f void)))
                   ((n-weight n-bid) (if (and (< y (board-height))
                                              (not (and (= old-x x)
                                                        (= old-y (add1 y)))))
                                         (get-move-weight x (add1 y)) (values #f void))))
        (cond 
          ((not (null? d)) (maker d-weight x y d-bid 'D d))
          ((not (null? p)) (maker p-weight x y p-bid 'P p))
          (else
           (list (when n-weight (maker (direction-weight 'N n-weight x y) x (add1 y) n-bid 'N null))
                 (when e-weight (maker (direction-weight 'E e-weight x y) (add1 x) y e-bid 'E null))
                 (when s-weight (maker (direction-weight 'S s-weight x y) x (sub1 y) s-bid 'S null))
                 (when w-weight (maker (direction-weight 'W w-weight x y) (sub1 x) y w-bid 'W null))))))))          
  
  (define (generate-moves x y weight back back-check g command)
    (let ((maker (move-maker (weight-from-goal g) back g command))
          (old-x (cord-x back-check))
          (old-y (cord-y back-check)))
      (let-values (((d-weight d-bid d _) (if (not (null? (search-player-packages (current-player))))
                                             (calc-weight 'D x y (current-player) null)
                                             (values #f void null void)))
                   ((w-weight w-bid) (if (and (> x 1)
                                              (not (and (= old-x (sub1 x))
                                                        (= old-y y))))
                                         (get-move-weight (sub1 x) y) (values #f void)))
                   ((e-weight e-bid) (if (and (< x (board-width))
                                              (not (and (= old-x (add1 x))
                                                        (= old-y y))))
                                         (get-move-weight (add1 x) y) (values #f void)))
                   ((s-weight s-bid) (if (and (> y 1)
                                              (not (and (= old-x x)
                                                        (= old-y (sub1 y)))))
                                         (get-move-weight x (sub1 y)) (values #f void)))
                   ((n-weight n-bid) (if (and (< y (board-height))
                                              (not (and (= old-x x)
                                                        (= old-y (add1 y)))))
                                         (get-move-weight x (add1 y)) (values #f void))))
        (cond
          ((not (null? d)) (maker d-weight x y d-bid))
          (else
           (list (when n-weight (maker (+ weight (direction-weight 'N n-weight x y)) x (add1 y) n-bid))
                 (when e-weight (maker (+ weight (direction-weight 'E e-weight x y)) (add1 x) y e-bid))
                 (when s-weight (maker (+ weight (direction-weight 'S s-weight x y)) x (sub1 y) s-bid))
                 (when w-weight (maker (+ weight (direction-weight 'W w-weight x y)) (sub1 x) y w-bid))))))))
  
  (define (destination-in-direction? x y dir)
    (and (not (null? (packages-held)))
         (ormap (lambda (x) x)
                (map (lambda (pack)
                       (case dir 
                         ((n) (> (package-y pack) y))
                         ((s) (< (package-y pack) y))
                         ((e) (> (package-x pack) x))
                         ((w) (< (package-x pack) x))))
                     (packages-held)))))
  
  (define (home-in-direction? x y dir)
    (and (not (null? (home-list)))
         (ormap (lambda (x) x)
                (map (lambda (home)
                       (case dir
                         ((n) (> (cdr home) y))
                         ((s) (< (cdr home) y))
                         ((e) (> (car home) x))
                         ((w) (< (car home) x))))
                     (home-list)))))

  (define (home-dir? x y dir)
    (and (not (null? (home-list)))
         (let ((home (nearest-home x y)))
           (case dir
             ((n) (> (cdr home) y))
             ((s) (< (cdr home) y))
             ((e) (> (car home) x))
             ((w) (< (car home) x))))))
  
  (define (dist gx gy px py)
    (+ (abs (- px gx))
       (abs (- py gy))))
  
  (define (nearest-home x y)
    (cdr (car (quicksort (map (lambda (home)
                                (cons (dist x y (car home) (cdr home)) home))
                              (home-list))
                         (lambda (l r) (< (car l) (car r)))))))
  
  (define (direction-weight dir weight x y)
    (cond
      ((destination-in-direction? x y dir) (+ weight (destination-in-direction-value)))
      ((home-dir? x y dir) (+ weight (home-in-direction-value)))
      (else weight)))
  
  (define (compute-move packages robots)
    (queue-head null)
    (in-queue 0)
    (when (null? (last-move)) (last-move (make-cord -inf.0 -inf.0)))
    (best-cmd null)
    (best-weight -inf.0)
    
    (current-player (make-search-player (get-player-x) (get-player-y) (player-id) (player-money) (player-capacity) (packages-held)))
    (update-robots robots (current-player))
    
    (let ((moves (generate-first-moves (get-player-x) (get-player-y) packages)))
      (if (move? moves)
          (best-cmd (move-orig moves))
          (begin (for-each enqueue moves)
                 (search-node (dequeue)))))
    
    (last-move (make-cord (get-player-x)
                          (get-player-y)))

    (best-cmd)
    )

  
  (define (search-node move)
    (when (< (move-step move) 30)
      (let ((moves (generate-moves (move-x move) 
                                   (move-y move)
                                   (move-weight move)
                                   (make-cord (move-x move) (move-y move)) 
                                   (move-back move) 
                                   (add1 (move-step move))  
                                   (move-orig move))))
        (if (move? moves)
            (best-cmd (move-orig moves))
            (begin (for-each enqueue moves)
                   (search-node (dequeue)))))))
  
  )