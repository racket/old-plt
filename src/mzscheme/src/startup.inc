  EVAL_ONE_STR(
"(module #%stx #%kernel"
"(define-values(identifier?)"
"(lambda(p)"
"(if(syntax? p)"
"(symbol?(syntax-e p))"
" #f)))"
"(define-values(stx-null?)"
"(lambda(p)"
"(if(null? p)"
" #t"
"(if(syntax? p) "
"(null?(syntax-e p))"
" #f))))"
"(define-values(stx-null/#f)"
"(lambda(p)"
"(if(null? p)"
" null"
"(if(syntax? p) "
"(if(null?(syntax-e p))"
" null"
" #f)"
" #f))))"
"(define-values(stx-pair?)"
"(lambda(p)"
"(if(pair? p)"
" #t"
"(if(syntax? p)"
"(pair?(syntax-e p))"
" #f))))"
"(define-values(stx-list?)"
"(lambda(p)"
"(if(list? p)"
" #t"
"(if(syntax? p) "
"(if(list?(syntax-e p))"
" #t"
"(let loop((l(syntax-e p)))"
"(if(pair? l)"
"(loop(cdr l))"
"(stx-list? l))))"
"(if(pair? p)"
"(stx-list?(cdr p))"
" #f)))))"
"(define-values(stx-car)"
"(lambda(p)"
"(if(pair? p)"
"(car p)"
"(car(syntax-e p)))))"
"(define-values(stx-cdr)"
"(lambda(p)"
"(if(pair? p)"
"(cdr p)"
"(cdr(syntax-e p)))))"
"(define-values(stx->list)"
"(lambda(e)"
"(if(syntax? e)"
"(syntax->list e)"
"(let((flat-end"
"(let loop((l e))"
"(if(null? l) "
" #f"
"(if(pair? l)"
"(loop(cdr l))"
"(if(syntax? l) "
"(syntax->list l)"
" #f))))))"
"(if flat-end"
"(let loop((l e))"
"(if(null? l) "
" null"
"(if(pair? l) "
"(cons(car l)(loop(cdr l)))"
"(if(syntax? l) "
" flat-end))))"
" e)))))"
"(define-values(stx-vector?)"
"(lambda(p len)"
"(if(syntax? p) "
"(if(vector?(syntax-e p))"
"(if len"
"(= len(vector-length(syntax-e p)))"
" #t)"
" #f)"
" #f)))"
"(define-values(stx-vector-ref)"
"(lambda(p pos)"
"(vector-ref(syntax-e p) pos)))"
"(define-values(stx-check/esc)"
"(lambda(v esc)"
"(if v"
" v"
"(esc #f))))"
"(define-values(cons/#f)"
"(lambda(i l)"
"(if l"
"(cons i l)"
" #f)))"
"(define-values(append/#f)"
"(lambda(l1 l2)"
"(if l2"
"(if(null? l2)"
" l1"
"(append l1 l2))"
" #f)))"
"(define-values(stx-rotate)"
"(lambda(l)"
"(apply map list l)))"
"(define-values(stx-rotate*)"
"(lambda(l)"
"(apply list*(apply map list l))))"
"(provide identifier? stx-null? stx-null/#f stx-pair? stx-list?"
" stx-car stx-cdr stx->list"
" stx-vector? stx-vector-ref"
" stx-check/esc cons/#f append/#f"
" stx-rotate stx-rotate*))"
);
  EVAL_ONE_STR(
"(module #%qq-and-or #%kernel"
"(require-for-syntax #%stx #%kernel)"
"(define-values(qq-append)"
"(lambda(a b)"
"(if(list? a)"
"(append a b)"
" (raise-type-error 'unquote-splicing \"proper list\" a))))"
"(define-syntaxes(quasiquote)"
"(let((here(quote-syntax here)) "
"(unquote-stx(quote-syntax unquote))"
"(unquote-splicing-stx(quote-syntax unquote-splicing)))"
"(lambda(in-form)"
"(if(identifier? in-form)"
" (raise-syntax-error #f \"bad syntax\" in-form))"
"(let-values"
"(((form)(if(stx-pair?(stx-cdr in-form))"
"(if(stx-null?(stx-cdr(stx-cdr in-form)))"
"(stx-car(stx-cdr in-form))"
" (raise-syntax-error #f \"bad syntax\" in-form))"
" (raise-syntax-error #f \"bad syntax\" in-form)))"
"((normal)"
"(lambda(x old)"
"(if(eq? x old)"
"(if(stx-null? x) "
"(quote-syntax())"
"(list(quote-syntax quote) x))"
" x)))"
"((apply-cons)"
"(lambda(a d)"
"(if(stx-null? d)"
"(list(quote-syntax list) a)"
"(if(if(pair? d)"
"(module-identifier=?(quote-syntax list)(car d))"
" #f)"
"(list*(quote-syntax list) a(cdr d))"
"(list(quote-syntax cons) a d))))))"
"(datum->syntax-object"
" here"
"(normal"
"(letrec-values"
"(((qq)"
"(lambda(x level)"
"(let-values"
"(((qq-list)"
"(lambda(x level)"
"(let-values"
"(((old-first)(stx-car x)))"
"(let-values"
"(((old-second)(stx-cdr x)))"
"(let-values"
"(((first)(qq old-first level)))"
"(let-values"
"(((second)(qq old-second level)))"
"(let-values"
"()"
"(if(if(eq? first old-first)"
"(eq? second old-second)"
" #f)"
" x"
"(apply-cons"
"(normal first old-first)"
"(normal second old-second)))))))))))"
"(if(stx-pair? x)"
"(let-values"
"(((first)(stx-car x)))"
"(if(if(if(identifier? first)"
"(module-identifier=? first unquote-stx)"
" #f)"
"(stx-list? x)"
" #f)"
"(let-values"
"(((rest)(stx-cdr x)))"
"(if(let-values"
"(((g35)(not(stx-pair? rest))))"
"(if g35 g35(not(stx-null?(stx-cdr rest)))))"
"(raise-syntax-error"
" 'unquote"
" \"expects exactly one expression\""
" in-form"
" x))"
"(if(zero? level)"
"(stx-car rest)"
"(qq-list x(sub1 level))))"
"(if(if(if(identifier? first)"
"(module-identifier=? first(quote-syntax quasiquote))"
" #f)"
"(stx-list? x)"
" #f)"
"(qq-list x(add1 level))"
"(if(if(if(identifier? first)"
"(module-identifier=? first unquote-splicing-stx)"
" #f)"
"(stx-list? x)"
" #f)"
"(raise-syntax-error"
" 'unquote-splicing"
" \"invalid context within quasiquote\""
" in-form"
" x)"
"(if(if(stx-pair? first)"
"(if(identifier?(stx-car first))"
"(if(module-identifier=?(stx-car first)"
" unquote-splicing-stx)"
"(stx-list? first)"
" #F)"
" #f)"
" #f)"
"(let-values"
"(((rest)(stx-cdr first)))"
"(if(let-values"
"(((g34)(not(stx-pair? rest))))"
"(if g34"
" g34"
"(not(stx-null?(stx-cdr rest)))))"
"(raise-syntax-error"
" 'unquote"
" \"expects exactly one expression\""
" in-form"
" x))"
"(let-values"
"(((uqsd)(stx-car rest))"
"((old-l)(stx-cdr x))"
"((l)(qq(stx-cdr x) level)))"
"(if(zero? level)"
"(let-values"
"(((l)(normal l old-l)))"
"(let-values"
"()"
"(list(quote-syntax qq-append) uqsd l)))"
"(let-values"
"(((restx)(qq-list rest(sub1 level))))"
"(let-values"
"()"
"(if(if(eq? l old-l)"
"(eq? restx rest)"
" #f)"
" x"
"(apply-cons"
"(apply-cons"
"(quote-syntax(quote unquote-splicing))"
"(normal restx rest))"
"(normal l old-l))))))))"
"(qq-list x level))))))"
"(if(if(syntax? x) "
"(vector?(syntax-e x))"
" #f)"
"(let-values"
"(((l)(vector->list(syntax-e x))))"
"(let-values"
"(((l2)(qq l level)))"
"(let-values"
"()"
"(if(eq? l l2)"
" x"
"(list(quote-syntax list->vector) l2)))))"
"(if(if(syntax? x)(box?(syntax-e x)) #f)"
"(let-values"
"(((v)(unbox(syntax-e x))))"
"(let-values"
"(((qv)(qq v level)))"
"(let-values"
"()"
"(if(eq? v qv)"
" x"
"(list(quote-syntax box) qv)))))"
" x)))))))"
"(qq form 0))"
" form)"
" in-form)))))"
"(define-syntaxes(and)"
"(let((here(quote-syntax here)))"
"(lambda(x)"
"(if(not(stx-list? x))"
" (raise-syntax-error #f \"bad syntax\" x))"
"(let((e(stx-cdr x)))"
"(if(stx-null? e)"
"(quote-syntax #t)"
"(if(if(stx-pair? e)"
"(stx-null?(stx-cdr e))"
" #t)"
"(stx-car e)"
"(datum->syntax-object"
" here"
"(list(quote-syntax if)"
"(stx-car e)"
"(cons(quote-syntax and)"
"(stx-cdr e))"
"(quote-syntax #f))"
" x)))))))"
"(define-syntaxes(or)"
"(let((here(quote-syntax here)))"
"(lambda(x)"
"(if(identifier? x)"
" (raise-syntax-error #f \"bad syntax\" x))"
"(let((e(stx-cdr x)))"
"(if(stx-null? e) "
"(quote-syntax #f)"
"(if(if(stx-pair? e)"
"(stx-null?(stx-cdr e))"
" #f)"
"(stx-car e)"
"(if(stx-list? e)"
"(let((tmp 'or-part))"
"(datum->syntax-object"
" here"
"(list(quote-syntax let)(list"
"(list"
" tmp"
"(stx-car e)))"
"(list(quote-syntax if)"
" tmp"
" tmp"
"(cons(quote-syntax or)"
"(stx-cdr e))))"
" x))"
"(raise-syntax-error "
" #f"
" \"bad syntax\""
" x))))))))"
"(provide quasiquote and or))"
);
  EVAL_ONE_STR(
"(module #%cond #%kernel"
"(require-for-syntax #%stx #%qq-and-or #%kernel)"
"(define-syntaxes(cond)"
"(let((here(quote-syntax here)))"
"(lambda(in-form)"
"(if(identifier? in-form)"
" (raise-syntax-error #f \"bad syntax\" in-form))"
"(datum->syntax-object"
" here"
"(let((form(stx-cdr in-form))"
"(serror"
"(lambda(msg at)"
"(raise-syntax-error #f msg in-form at))))"
"(let loop((tests form))"
"(if(stx-null? tests)"
"(quote-syntax(void))"
"(if(not(stx-pair? tests))"
"(serror"
" \"bad syntax (body must contain a list of pairs)\""
" tests)"
"(let((line(stx-car tests))"
"(rest(stx-cdr tests)))"
"(if(not(stx-pair? line))"
"(serror"
" \"bad syntax (clause is not a test-value pair)\""
" line)"
"(let*((test(stx-car line))"
"(value(stx-cdr line))"
"(else?(and(identifier? test)"
"(module-identifier=? test(quote-syntax else)))))"
"(if(and else?(stx-pair? rest))"
" (serror \"bad syntax (`else' clause must be last)\" line))"
"(if(and(stx-pair? value)"
"(identifier?(stx-car value))"
"(module-identifier=?(stx-car value)(quote-syntax =>)))"
"(if(and(stx-pair?(stx-cdr value))"
"(stx-null?(stx-cdr(stx-cdr value))))"
"(let((test(if else?"
" #t "
" test))"
"(gen(gensym)))"
" `(,(quote-syntax let)((,gen ,test))"
"(,(quote-syntax if) ,gen"
"(,(stx-car(stx-cdr value)) ,gen)"
" ,(loop rest))))"
"(serror"
" \"bad syntax (bad clause form with =>)\""
" line))"
"(if else?"
"(cons(quote-syntax begin) value)"
"(if(stx-null? value)"
"(let((gen(gensym)))"
" `(,(quote-syntax let)((,gen ,test))"
"(,(quote-syntax if) ,gen ,gen ,(loop rest))))"
"(list"
"(quote-syntax if) test"
"(cons(quote-syntax begin) value)"
"(loop rest))))))))))))"
" in-form))))"
"(provide cond))"
);
  EVAL_ONE_STR(
"(module #%struct-info #%kernel"
"(require #%stx #%qq-and-or)"
"(define-values(identifier/#f?)"
"(lambda(x)(or(not x)(identifier? x))))"
"(define-values(id/#f-list?)"
"(lambda(x)"
"(if(null? x)"
" #t"
"(if(pair? x)"
"(if(null?(cdr x))"
"(identifier/#f?(car x))"
"(and(identifier?(car x))"
"(id/#f-list?(cdr x))))"
" #f))))"
"(define-values(struct-info?)"
"(lambda(x)"
"(and(list? x)"
"(=(length x) 5)"
"(identifier/#f?(car x))"
"(identifier/#f?(cadr x))"
"(identifier/#f?(caddr x))"
"(id/#f-list?(list-ref x 3))"
"(id/#f-list?(list-ref x 4)))))"
"(define-values(struct-info-type-id) car)"
"(define-values(struct-info-constructor-id) cadr)"
"(define-values(struct-info-predicate-id) caddr)"
"(define-values(struct-info-accessor-ids) cadddr)"
"(define-values(struct-info-mutator-ids)(lambda(x)(list-ref x 4)))"
"(provide struct-info? "
" struct-info-type-id"
" struct-info-constructor-id"
" struct-info-predicate-id"
" struct-info-accessor-ids"
" struct-info-mutator-ids))"
);
  EVAL_ONE_STR(
"(module #%ds-helper #%kernel"
"(require #%stx #%qq-and-or #%cond #%struct-info)"
"(define-values(list->immutable-list)"
"(lambda(l)"
"(if(null? l) null(cons-immutable(car l)(list->immutable-list(cdr l))))))"
"(define-values(get-stx-info)"
"(lambda(orig-stx super-id defined-names gen-expr?)"
"(let((qs(if gen-expr?(lambda(x) `(quote-syntax ,x)) values))"
"(every-other(lambda(l)"
"(let loop((l l)(r null))"
"(cond"
"((null? l) r)"
"((null?(cdr l))(cons(car l) r))"
"(else(loop(cddr l)(cons(car l) r)))))))"
"(super-info(and super-id "
"(syntax-local-value super-id(lambda() #f)))))"
"(if super-id "
"(if(or(not(struct-info? super-info))"
"(not(struct-info-type-id super-info)))"
"(raise-syntax-error"
" #f"
"(if(struct-info? super-info)"
" \"parent struct information does not include a type for subtyping\""
" (format \"parent struct type not defined~a\""
"(if super-info"
" (format \" (~a does not name struct type information)\""
"(syntax-e super-id))"
" \"\")))"
" orig-stx"
" super-id)))"
"(values"
"(if super-info"
"(struct-info-type-id super-info)"
" #f)"
"(if defined-names"
"(let-values(((initial-gets initial-sets)"
"(if super-info"
"(values(map qs(struct-info-accessor-ids super-info))"
"(map qs(struct-info-mutator-ids super-info)))"
"(values null null)))"
"((fields)(cdddr defined-names))"
"((wrap)(if gen-expr?(lambda(x)(cons 'list-immutable x)) values)))"
"(wrap"
"(list-immutable(qs(car defined-names))"
"(qs(cadr defined-names))"
"(qs(caddr defined-names))"
"(wrap"
"(list->immutable-list"
"(append(map qs(every-other fields)) "
" initial-gets)))"
"(wrap"
"(list->immutable-list"
"(append(map qs(if(null? fields) "
" null "
"(every-other(cdr fields)))) "
" initial-sets))))))"
" #f)))))"
"(provide get-stx-info))"
);
  EVAL_ONE_STR(
"(module #%define-et-al #%kernel"
"(require-for-syntax #%kernel #%stx #%qq-and-or #%cond #%struct-info #%ds-helper)"
"(define-syntaxes(define define-syntax)"
"(let((here(quote-syntax here)))"
"(let((mk-define"
"(lambda(base)"
"(lambda(code)"
"(if(or(identifier? code)"
"(not(stx-pair?(stx-cdr code))))"
" (raise-syntax-error #f \"bad syntax\" code))"
"(let((body(stx-cdr code)))"
"(let((first(stx-car body))) "
"(cond"
"((identifier? first)"
"(if(and(stx-pair?(stx-cdr body))"
"(stx-null?(stx-cdr(stx-cdr body))))"
"(datum->syntax-object"
" here"
" `(,base(,first) ,@(stx->list(stx-cdr body)))"
" code)"
"(raise-syntax-error"
" #f"
" \"bad syntax (zero or multiple expressions after identifier)\""
" code)))"
"((stx-pair? first)"
"(let((bad-symbol(lambda(s)(raise-syntax-error #f"
" \"bad identifier\""
" code"
" s))))"
"(let loop((l first))"
"(cond"
"((stx-null? l) #f)"
"((stx-pair? l) "
"(if(identifier?(stx-car l))"
"(loop(stx-cdr l))"
"(bad-symbol(stx-car l))))"
"((identifier? l) #f)"
"(else(bad-symbol l)))))"
"(let((pbody(stx-cdr body)))"
"(if(not(stx-list? pbody))"
"(raise-syntax-error"
" #f"
" \"bad syntax (illegal use of `.')\""
" code))"
"(if(stx-null? pbody)"
"(raise-syntax-error"
" #f"
" \"bad syntax (empty procedure body)\""
" code))"
"(datum->syntax-object"
"(quote-syntax here)"
" `(,base(,(stx-car first)) "
"(lambda ,(stx-cdr first) ,@(stx->list pbody)))"
" code)))"
"(else"
"(raise-syntax-error"
" #f"
" \"not an identifier\""
" code"
" first)))))))))"
"(values(mk-define(quote-syntax define-values))"
"(mk-define(quote-syntax define-syntaxes))))))"
"(define-syntax when"
"(lambda(x)"
"(let((l(syntax->list x)))"
"(if(and l"
"(>(length l) 2))"
"(datum->syntax-object"
"(quote-syntax here)"
"(list(quote-syntax if)"
"(stx-car(stx-cdr x))"
"(list*"
"(quote-syntax begin)"
"(stx-cdr(stx-cdr x))))"
" x)"
"(raise-syntax-error"
" #f"
" \"bad syntax\""
" x)))))"
"(define-syntax unless"
"(lambda(x)"
"(let((l(syntax->list x)))"
"(if(and l"
"(>(length l) 2))"
"(datum->syntax-object"
"(quote-syntax here)"
"(list(quote-syntax if)"
"(cadr l)"
"(quote-syntax(void))"
"(list*"
"(quote-syntax begin)"
"(cddr l)))"
" x)"
"(raise-syntax-error"
" #f"
" \"bad syntax\""
" x)))))"
"(define-syntax let/ec "
"(lambda(code)"
"(let((l(syntax->list code)))"
"(if(and l"
"(>(length l) 2)"
"(identifier?(cadr l)))"
"(let((var(cadr l))"
"(exprs(stx-cdr(stx-cdr code))))"
"(datum->syntax-object"
"(quote-syntax here)"
" `(call/ec(lambda(,var) ,@(stx->list exprs)))"
" code))"
"(raise-syntax-error"
" #f"
" \"bad syntax\""
" code)))))"
"(define-syntaxes(define-struct generate-struct-vals)"
"(let((make-core"
"(lambda(name inspector super-id/struct: field-names)"
" `(let-values(((type maker pred access mutate)"
"(make-struct-type ',name"
" ,super-id/struct:"
" ,(length field-names)"
" 0 #f null"
" ,inspector)))"
"(values type maker pred"
" ,@(let loop((field-names field-names)(n 0))"
"(if(null? field-names)"
" null"
"(list* `(make-struct-field-accessor access ,n ',(car field-names))"
" `(make-struct-field-mutator mutate ,n ',(car field-names))"
"(loop(cdr field-names)(add1 n))))))))))"
"(values"
"(lambda(stx)"
"(if(identifier? stx)"
" (raise-syntax-error #f \"bad syntax\" stx))"
"(let((body(stx->list(stx-cdr stx))))"
"(let((syntax-error"
"(lambda(s . detail)"
"(apply"
" raise-syntax-error"
" #f"
" s"
" stx"
" detail)))"
"(build-struct-names"
"(lambda(name fields)"
"(let((name(symbol->string(syntax-e name)))"
"(fields(map symbol->string(map syntax-e fields)))"
"(+ string-append))"
"(map string->symbol"
"(append"
"(list "
" (+ \"struct:\" name)"
" (+ \"make-\" name)"
" (+ name \"?\"))"
"(apply"
" append"
"(map"
"(lambda(f) "
"(list "
" (+ name \"-\" f)"
" (+ \"set-\" name \"-\" f \"!\")))"
" fields))))))))"
"(or(pair? body)"
" (syntax-error \"empty declaration\"))"
"(or(stx-list? body)"
" (syntax-error \"illegal use of `.'\"))"
"(or(<= 2(length body) 3)"
" (syntax-error \"wrong number of parts\"))"
"(or(identifier?(car body))"
"(and(stx-pair?(car body))"
"(identifier?(stx-car(car body)))"
"(stx-pair?(stx-cdr(car body)))"
"(identifier?(stx-car(stx-cdr(car body))))"
"(stx-null?(stx-cdr(stx-cdr(car body)))))"
" (syntax-error \"first part must be an identifier or pair of identifiers\"))"
"(or(stx-list?(cadr body))"
"(if(stx-pair?(cadr body))"
" (syntax-error \"illegal use of `.' in field name sequence\")"
" (syntax-error \"field names must be a sequence\")))"
"(for-each(lambda(x) "
"(or(identifier? x)"
" (syntax-error \"field name not a identifier\" x)))"
"(stx->list(cadr body)))"
"(if(memq(syntax-local-context) '(expression))"
" (syntax-error \"only allowed in definition contexts\"))"
"(let((name(if(identifier?(car body))"
"(car body)"
"(stx-car(car body))))"
"(field-names(stx->list(cadr body)))"
"(inspector(if(null?(cddr body))"
" #f"
"(caddr body)))"
"(super-id(if(identifier?(car body))"
" #f"
"(stx-car(stx-cdr(car body))))))"
"(let((defined-names(map "
"(lambda(n)(datum->syntax-object name n name)) "
"(build-struct-names name field-names)))"
"(delay?(and(eq?(syntax-local-context) 'internal-define) super-id)))"
"(let-values(((super-id/struct: stx-info)(if delay?"
"(values #f #f)"
"(get-stx-info stx super-id defined-names #t))))"
"(datum->syntax-object"
"(quote-syntax here)"
" `(begin"
"(define-values"
" ,defined-names"
" ,(let((core(if delay?"
" `(begin0 "
"(generate-struct-vals ,stx ,name ,(and inspector 'inspector) ,super-id ,field-names))"
"(make-core name(and inspector 'inspector) super-id/struct: field-names))))"
"(if inspector"
" `(let((inspector ,inspector))"
"(if(not(inspector? inspector))"
" (raise-type-error 'define-struct \"inspector\" inspector))"
" ,core)"
" core)))"
"(define-syntaxes(,name) ,(if delay?"
" `(let-values(((super-id/struct: stx-info) "
"(get-stx-info(quote-syntax ,stx)"
"(quote-syntax ,super-id)"
"(list ,@(map(lambda(x) `(quote-syntax ,x))"
" defined-names))"
" #f)))"
" stx-info)"
" stx-info)))"
" stx)))))))"
"(lambda(stx)"
"(let*((stx(stx-cdr stx))"
"(orig-stx(stx-car stx))"
"(stx(stx-cdr stx))"
"(name(stx-car stx))"
"(stx(stx-cdr stx))"
"(inspector(stx-car stx))"
"(super-id(stx-car(stx-cdr stx)))"
"(field-names(stx-car(stx-cdr(stx-cdr stx)))))"
"(let-values(((super-id/struct: stx-info)(get-stx-info orig-stx super-id #f #f)))"
"(datum->syntax-object"
"(quote-syntax here)"
"(make-core name"
" inspector"
" super-id/struct:"
"(syntax->list field-names)))))))))"
"(provide define define-syntax when unless let/ec define-struct))"
);
  EVAL_ONE_STR(
"(module #%small-scheme #%kernel"
"(require #%stx #%qq-and-or #%cond #%define-et-al)"
"(provide(all-from #%qq-and-or)"
"(all-from #%cond)"
"(all-from #%define-et-al)))"
);
  EVAL_ONE_STR(
"(module #%sc #%kernel"
"(require #%stx #%small-scheme)"
"(define(stx-memq ssym l)"
"(ormap(lambda(p)"
"(and(syntax? p)"
"(module-identifier=? ssym p)))"
" l))"
"(define(stx-memq-pos ssym l)"
"(let loop((p 0)(l l))"
"(cond"
"((null? l) #f)"
"((and(syntax?(car l))"
"(module-identifier=? ssym(car l)))"
" p)"
"(else(loop(add1 p)(cdr l))))))"
"(define(stx-memq*-pos ssym l)"
"(let loop((p 0)(l l))"
"(cond"
"((null? l) #f)"
"((module-identifier=? ssym "
"(let loop((i(car l)))"
"(if(syntax? i)"
" i"
"(loop(car i)))))"
" p)"
"(else(loop(add1 p)(cdr l))))))"
"(define(pick-specificity e de)"
"(if(eq? e de)"
"(list e)"
"(list e de)))"
"(define syntax-case-stxsrc '(syntax-case syntax-case mzscheme))"
"(define syntax-stxsrc '(syntax syntax mzscheme))"
"(define(make-match&env/extract-vars p k just-vars? phase-param?)"
"(define top p)"
"(define(m&e p local-top use-ellipses? last? id-is-rest?)"
"(cond"
"((and use-ellipses?(ellipsis? p))"
"(unless(stx-null?(stx-cdr(stx-cdr p)))"
"(raise-syntax-error "
" 'syntax-case"
" \"misplaced ellipses in pattern\""
" top"
" p))"
"(let*((p-head(stx-car p))"
"(nestings(get-ellipsis-nestings p-head k)))"
"(let-values(((match-head mh-did-var?)(m&e p-head p-head #t #f #f)))"
"(if just-vars?"
"(values(map list nestings) #f)"
"(let((nest-vars(flatten-nestings nestings(lambda(x) #t))))"
"(values"
" `(lambda(e)"
"(if(stx-list? e)"
" ,(let((b(app-e match-head)))"
"(if(equal? b '(list e))"
"(if last?"
" '(stx->list e)"
" '(list(stx->list e)))"
" `(let/ec esc"
"(let((l(map(lambda(e)(stx-check/esc ,b esc))"
"(stx->list e))))"
"(if(null? l)"
"(quote ,(let((empties(map(lambda(v) '()) nest-vars)))"
"(if last?"
"(apply list* empties)"
" empties)))"
"(,(if last? 'stx-rotate* 'stx-rotate) l))))))"
" #f))"
" mh-did-var?))))))"
"((stx-pair? p)"
"(let((hd(stx-car p)))"
"(if(and use-ellipses?"
"(eq?(syntax-e hd) '...))"
"(if(and(stx-pair?(stx-cdr p))"
"(stx-null?(stx-cdr(stx-cdr p))))"
"(let((dp(stx-car(stx-cdr p))))"
"(m&e dp dp #f last? #f))"
"(raise-syntax-error "
" syntax-case-stxsrc"
" \"misplaced ellipses in pattern\""
" top"
" hd))"
"(let*-values(((-match-head -mh-did-var?)(if just-vars?"
"(m&e hd hd use-ellipses? #f #f)"
"(values 'not 'yet)))"
"((match-tail mt-did-var?)(m&e(stx-cdr p) local-top use-ellipses? "
" last? #t))"
"((match-head mh-did-var?)(if just-vars?"
"(values -match-head -mh-did-var?)"
"(m&e hd hd use-ellipses? "
"(and last?(not mt-did-var?))"
" #f))))"
"(if just-vars?"
"(values(append match-head match-tail) #f)"
"(values"
" `(lambda(e)"
"(if(stx-pair? e)"
" ,(let((apph(app match-head '(stx-car e)))"
"(appt(app match-tail '(stx-cdr e))))"
"(if mh-did-var?"
"(app-append apph appt)"
" `(if ,apph ,appt #f)))"
" #f))"
"(or mh-did-var? mt-did-var?)))))))"
"((stx-null? p)"
"(if just-vars?"
"(values null #f)"
"(values 'stx-null/#f #f)))"
"((identifier? p)"
"(if(stx-memq p k)"
"(if just-vars?"
"(values null #f)"
"(values"
" `(lambda(e)"
"(if(identifier? e)"
"(if(module-identifier=? e(quote-syntax ,p))"
" null"
" #f)"
" #f))"
" #f))"
"(if(and use-ellipses?"
"(eq?(syntax-e p) '...))"
"(raise-syntax-error "
" syntax-case-stxsrc"
" \"misplaced ellipses in pattern\""
" top"
" p)"
"(if just-vars?"
"(values(list p) #f)"
"(values"
"(let((wrap(if last?"
"(lambda(x) `(lambda(e) ,x))"
"(lambda(x) `(lambda(e)(list ,x))))))"
"(if id-is-rest?"
"(wrap '(datum->syntax-object #f e))"
"(wrap 'e)))"
" #t)))))"
"((stx-vector? p #f)"
"(let((l(vector->list(syntax-e p))))"
"(if(and(not just-vars?)"
"(or(not use-ellipses?)"
"(andmap(lambda(x)(not(eq? '...(syntax-e x)))) l)))"
"(let((len(vector-length(syntax-e p))))"
"(let loop((pos len)(did-var?(not last?))(body null))"
"(if(zero? pos)"
"(values "
" `(lambda(e)"
"(if(stx-vector? e ,len)"
" ,body"
" #f))"
" did-var?)"
"(let-values(((match-elem elem-did-var?) "
"(let((e(vector-ref(syntax-e p)(sub1 pos))))"
"(m&e e e use-ellipses?(not did-var?) #f))))"
"(loop(sub1 pos)"
"(or did-var? elem-did-var?)"
"(let((app-elem(app match-elem `(stx-vector-ref e ,(sub1 pos)))))"
"(if(null? body)"
" app-elem"
"(if elem-did-var?"
"(app-append app-elem body)"
" `(if ,app-elem ,body #f)))))))))"
"(let-values(((match-content did-var?)(m&e l p use-ellipses? last? #f)))"
"(if just-vars?"
"(values match-content #f)"
"(values"
" `(lambda(e)"
"(if(stx-vector? e #f)"
" ,(app match-content '(vector->list(syntax-e e)))"
" #f))"
" did-var?))))))"
"(else"
"(if just-vars?"
"(values null #f)"
"(values"
" `(lambda(e)"
"(if(equal? ,(syntax-e p)(syntax-e e))"
" null"
" #f))"
" #f)))))"
"(let-values(((r did-var?)(m&e p p #t #t #f)))"
"(if just-vars?"
"(let((ht(make-hash-table)))"
"(let loop((r r))"
"(cond"
"((syntax? r)"
"(let((l(hash-table-get ht(syntax-e r)(lambda() null))))"
"(when(ormap(lambda(i)(module-identifier=? i r)) l)"
"(raise-syntax-error "
" syntax-case-stxsrc"
" \"variable used twice in pattern\""
" top"
" r))"
"(hash-table-put! ht(syntax-e r)(cons r l))))"
"((pair? r)"
"(loop(car r))"
"(loop(cdr r)))"
"(else(void))))"
" r)"
"(if(equal? r '(lambda(e) e))"
"(if phase-param?"
" '(lambda(e module-identifier=?) e)"
" '(lambda(e) e))"
" `(lambda(e ,@(if phase-param?"
" '(module-identifier=?) "
" null))"
" ,(app-e r))))))"
"(define(make-match&env p k phase-param?)"
"(make-match&env/extract-vars p k #f phase-param?))"
"(define(get-match-vars p k)"
"(make-match&env/extract-vars p k #t #f))"
"(define(app-e rest)"
"(if(and(pair? rest)"
"(eq?(car rest) 'lambda)"
"(equal?(cadr rest) '(e)))"
"(caddr rest)"
" `(,rest e)))"
"(define(app rest e)"
"(if(and(pair? rest)"
"(eq?(car rest) 'lambda)"
"(equal?(cadr rest) '(e)))"
"(let((r(caddr rest)))"
"(cond"
"((eq? r 'e)"
" e)"
"((and(pair? r)"
"(eq?(car r) 'list)"
"(pair?(cdr r))"
"(eq?(cadr r) 'e)"
"(null?(cddr r)))"
" `(list ,e))"
"(else"
" `(,rest ,e))))"
" `(,rest ,e)))"
"(define(app-append e1 e2)"
"(if(and(pair? e1)"
"(eq?(car e1) 'list)"
"(pair?(cdr e1))"
"(null?(cddr e1)))"
" `(cons/#f ,(cadr e1) ,e2)"
" `(let((v ,e1))"
"(if v"
"(append/#f v ,e2)"
" #f))))"
"(define(make-pexpand p proto-r k dest)"
"(define top p)"
"(define(expander p proto-r local-top use-ellipses? use-tail-pos hash!)"
"(cond"
"((and use-ellipses?(ellipsis? p))"
"(let*((p-head(stx-car p))"
"(nestings(and proto-r(get-ellipsis-nestings p-head k))))"
"(when(null? nestings)"
"(apply"
" raise-syntax-error "
" syntax-stxsrc"
" \"no pattern variables before ellipses in template\""
"(pick-specificity"
" top"
" local-top)))"
"(let*((proto-rr+deep?s(and proto-r"
"(map(lambda(nesting)"
"(ellipsis-sub-env nesting proto-r top local-top))"
" nestings)))"
"(proto-rr-deep(and proto-r"
"(let loop((l proto-rr+deep?s))"
"(cond"
"((null? l) null)"
"((cdar l)(loop(cdr l)))"
"(else(cons(caar l)(loop(cdr l))))))))"
"(proto-rr-shallow(and proto-r"
"(let loop((l proto-rr+deep?s))"
"(cond"
"((null? l) null)"
"((cdar l)(cons(caar l)(loop(cdr l))))"
"(else(loop(cdr l)))))))"
"(flat-nestings-deep(and proto-r(extract-vars proto-rr-deep)))"
"(flat-nestings-shallow(and proto-r(extract-vars proto-rr-shallow)))"
"(_(unless(null? proto-rr-shallow)"
"(when(null? proto-rr-deep)"
"(apply"
" raise-syntax-error "
" syntax-stxsrc"
" \"too many ellipses in template\""
"(pick-specificity"
" top"
" local-top)))))"
"(rest(expander(stx-cdr(stx-cdr p)) proto-r local-top #t use-tail-pos hash!))"
"(ehead(expander p-head(and proto-r(append proto-rr-shallow proto-rr-deep)) p-head #t #f hash!)))"
"(if proto-r"
" `(lambda(r)"
" ,(let((pre(let((deeps"
"(let((valses"
"(map(lambda(var)"
"(apply-list-ref 'r(stx-memq*-pos var proto-r) use-tail-pos))"
" flat-nestings-deep)))"
"(cond"
"((and(= 1(length valses))"
"(null? flat-nestings-shallow)"
"(equal? ehead '(lambda(r)(car r))))"
"(car valses))"
"((and(= 2(length valses))"
"(null? flat-nestings-shallow)"
"(equal? ehead '(lambda(r)(list(car r)(cadr r)))))"
" `(map "
"(lambda(a b)(list a b))"
" ,@valses))"
"(else"
" `(map "
"(lambda vals(,ehead "
" ,(if(null? flat-nestings-shallow)"
" 'vals"
" '(append shallows vals))))"
" ,@valses))))))"
"(if(null? flat-nestings-shallow)"
" deeps"
" `(let((shallows"
"(list ,@(map(lambda(var)"
"(apply-list-ref 'r(stx-memq*-pos var proto-r) use-tail-pos))"
" flat-nestings-shallow))))"
" ,deeps))))"
"(post(apply-to-r rest)))"
"(if(eq? post 'null)"
" pre"
" `(append ,pre ,post))))"
"(void)))))"
"((stx-pair? p)"
"(let((hd(stx-car p)))"
"(if(and use-ellipses?"
"(identifier? hd)"
"(eq?(syntax-e hd) '...))"
"(if(and(stx-pair?(stx-cdr p))"
"(stx-null?(stx-cdr(stx-cdr p))))"
"(let((dp(stx-car(stx-cdr p))))"
"(expander dp proto-r dp #f use-tail-pos hash!))"
"(raise-syntax-error "
" syntax-stxsrc"
" \"misplaced ellipses in template\""
" top"
" hd))"
"(let((ehd(expander hd proto-r hd use-ellipses? use-tail-pos hash!))"
"(etl(expander(stx-cdr p) proto-r local-top use-ellipses? use-tail-pos hash!)))"
"(if proto-r"
" `(lambda(r)"
" ,(apply-cons(apply-to-r ehd)(apply-to-r etl) p))"
"(void))))))"
"((stx-vector? p #f)"
"(let((e(expander(vector->list(syntax-e p)) proto-r p use-ellipses? use-tail-pos hash!)))"
"(if proto-r"
" `(lambda(r)"
"(list->vector(stx->list ,(apply-to-r e))))"
"(void))))"
"((identifier? p)"
"(if(stx-memq p k) "
"(if proto-r "
" `(lambda(r)(quote-syntax ,p))"
"(void))"
"(if proto-r"
"(let((x(stx-memq p proto-r)))"
"(if x "
" `(lambda(r) ,(apply-list-ref 'r(stx-memq-pos p proto-r) use-tail-pos))"
"(begin"
"(when(and use-ellipses?"
"(eq?(syntax-e p) '...))"
"(raise-syntax-error "
" syntax-stxsrc"
" \"misplaced ellipses in template\""
" top"
" p))"
"(check-not-pattern p proto-r)"
" `(lambda(r)(quote-syntax ,p)))))"
"(unless(and(eq?(syntax-e p) '...)"
" use-ellipses?)"
"(hash! p)))))"
"((null? p) "
"(if proto-r "
" `(lambda(r) null)"
"(void)))"
"(else(if proto-r "
" `(lambda(r)(quote-syntax ,p))"
"(void)))))"
"(let*((ht(if proto-r"
" #f"
"(make-hash-table)))"
"(l(expander p proto-r p #t"
"(and proto-r(sub1(length proto-r)))"
"(if proto-r"
" #f"
"(lambda(r)"
"(let((l(hash-table-get ht(syntax-e r)(lambda() null))))"
"(unless(and(pair? l)"
"(ormap(lambda(i)(module-identifier=? i r)) l))"
"(hash-table-put! ht(syntax-e r)(cons r l)))))))))"
"(if proto-r"
" `(lambda(r src)"
" ,(let((main `(datum->syntax-object(quote-syntax ,(and dest"
"(datum->syntax-object"
" dest"
" 'dest"
" #f)))"
" ,(apply-to-r l) "
" src)))"
"(if(multiple-ellipsis-vars? proto-r)"
" `(let((exnh #f))"
"((let/ec esc"
"(dynamic-wind"
"(lambda()"
"(set! exnh(current-exception-handler))"
"(current-exception-handler"
"(lambda(exn)"
"(esc"
"(lambda()"
"(if(exn:break? exn)"
"(raise exn)"
"(raise-syntax-error"
" '(syntax syntax mzscheme)"
" \"incompatible ellipsis match counts for template\""
"(quote ,p)"
"(quote-syntax ,(datum->syntax-object #f '... p)))))))))"
"(lambda()"
"(let((v ,main))"
"(lambda() v)))"
"(lambda()"
"(current-exception-handler exnh))))))"
" main)))"
"(apply append(hash-table-map ht(lambda(k v) v))))))"
"(define(apply-to-r rest)"
"(if(and(pair? rest)"
"(eq?(car rest) 'lambda)"
"(equal?(cadr rest) '(r)))"
"(caddr rest)"
" `(,rest r)))"
"(define(apply-cons h t p)"
"(cond"
"((and(pair? h)"
"(eq?(car h) 'quote-syntax)"
"(eq?(cadr h)(stx-car p))"
"(or(eq? t 'null)"
"(and"
"(pair? t)"
"(eq?(car t) 'quote-syntax)"
"(eq?(cadr t)(stx-cdr p)))))"
" `(quote-syntax ,p))"
"((eq? t 'null)"
" `(list ,h))"
"((and(pair? t)"
"(memq(car t) '(list list*)))"
" `(,(car t) ,h ,@(cdr t)))"
"((and(pair? t)"
"(eq?(car t) 'cons))"
" `(list* ,h ,@(cdr t)))"
"((and(pair? h)(pair? t)"
"(eq?(car h) 'car)"
"(eq?(car t) 'cdr)"
"(symbol?(cadr h))"
"(eq?(cadr h)(cadr t)))"
"(cadr h))"
"(else"
" `(cons ,h ,t))))"
"(define(apply-list-ref e p use-tail-pos)"
"(cond"
"((and use-tail-pos(= p use-tail-pos))"
"(cond"
"((eq? p 0) e)"
"((eq? p 1) `(cdr ,e))"
"((eq? p 2) `(cddr ,e))"
"((eq? p 3) `(cdddr ,e))"
"((eq? p 4) `(cddddr ,e))"
"(else `(list-tail ,e ,p))))"
"((eq? p 0) `(car ,e))"
"((eq? p 1) `(cadr ,e))"
"((eq? p 2) `(caddr ,e))"
"((eq? p 3) `(cadddr ,e))"
"(else `(list-ref ,e ,p))))"
"(define get-ellipsis-nestings"
"(lambda(p k)"
"(let sub((p p)(use-ellipses? #t))"
"(cond "
"((and use-ellipses?(ellipsis? p))"
"(let((subs(sub(stx-car p) #t)))"
"(append(map list subs)"
"(sub(stx-cdr(stx-cdr p)) #t))))"
"((stx-pair? p) "
"(let((hd(stx-car p)))"
"(if(and use-ellipses?"
"(identifier? hd)"
"(eq?(syntax-e hd) '...)"
"(stx-pair?(stx-cdr p)))"
"(sub(stx-car(stx-cdr p)) #f)"
"(append!(sub(stx-car p) use-ellipses?) "
"(sub(stx-cdr p) use-ellipses?)))))"
"((identifier? p)"
"(if(stx-memq p k) "
" '() "
"(list p)))"
"(else '())))))"
"(define ellipsis-sub-env"
"(lambda(nesting proto-r src detail-src)"
"(let((v(ormap(lambda(proto)"
"(let((start(if(pair? proto)"
"(car proto)"
" proto)))"
"(let loop((c start)(n nesting))"
"(cond"
"((and(pair? c)(pair? n))"
"(loop(car c)(car n)))"
"((pair? n)"
"(loop c(car n)))"
"((and(syntax? c)(syntax? n))"
"(if(module-identifier=? c n)"
"(cons start(identifier? proto))"
" #f))"
"(else #f)))))"
" proto-r)))"
"(unless v"
"(apply"
" raise-syntax-error "
" syntax-stxsrc"
" \"too few ellipses for pattern variable in template\""
"(pick-specificity"
" src"
"(let loop((n nesting))"
"(if(syntax? n)"
" n"
"(loop(car n)))))))"
" v)))"
"(define(extract-vars proto-r)"
"(map(lambda(i)"
"(let loop((i i))"
"(if(syntax? i)"
" i"
"(loop(car i)))))"
" proto-r))"
"(define(check-not-pattern ssym proto-r)"
"(for-each(lambda(p)"
"(when(pair? p)"
"(let loop((l(car p)))"
"(cond"
"((syntax? l)"
"(when(module-identifier=? l ssym)"
"(raise-syntax-error "
" syntax-stxsrc"
" \"missing ellipses with pattern variable in template\""
" ssym)))"
"(else(loop(car l)))))))"
" proto-r))"
"(define(ellipsis? x)"
"(and(stx-pair? x) "
"(let((d(stx-cdr x)))"
"(and(stx-pair? d) "
"(eq?(syntax-e(stx-car d)) '...)"
"(not(eq?(syntax-e(stx-car x)) '...))))))"
"(define(flatten-nestings nestings filter?)"
"(let loop((nestings nestings))"
"(if(null? nestings)"
" null"
"(if(filter?(car nestings))"
"(cons(let loop((nesting(car nestings)))"
"(if(syntax? nesting)"
" nesting"
"(loop(car nesting))))"
"(loop(cdr nestings)))"
"(loop(cdr nestings))))))"
"(define(multiple-ellipsis-vars? proto-r)"
"(let loop((proto-r proto-r))"
"(cond"
"((null? proto-r) #f)"
"((pair?(car proto-r))"
"(let loop((proto-r(cdr proto-r)))"
"(cond"
"((null? proto-r) #f)"
"((pair?(car proto-r))"
" #t)"
"(else(loop(cdr proto-r))))))"
"(else(loop(cdr proto-r))))))"
"(define(no-ellipses? stx)"
"(let loop((stx stx))"
"(cond"
"((stx-pair? stx)"
"(and(no-ellipses?(stx-car stx))"
"(no-ellipses?(stx-cdr stx))))"
"((identifier? stx)"
"(not(eq?(syntax-e stx) '...)))"
"(else #t))))"
"(define-struct syntax-mapping(depth valvar))"
"(provide make-match&env get-match-vars make-pexpand"
" make-syntax-mapping syntax-mapping?"
" syntax-mapping-depth syntax-mapping-valvar"
" stx-memq-pos no-ellipses?))"
);
  EVAL_ONE_STR(
"(module #%stxcase #%kernel"
"(require #%stx #%small-scheme)"
"(require-for-syntax #%stx #%small-scheme #%sc #%kernel)"
"(define-syntax syntax-case*"
"(lambda(x)"
"(define l(and(stx-list? x)(stx->list x)))"
"(unless(and(stx-list? x)"
"(>(length l) 3))"
"(raise-syntax-error"
" #f"
" \"bad form\""
" x))"
"(let((expr(cadr l))"
"(kws(caddr l))"
"(lit-comp(cadddr l))"
"(clauses(cddddr l)))"
"(unless(stx-list? kws)"
"(raise-syntax-error"
" #f"
" \"expected a parenthesized sequence of literal identifiers\""
" x"
" kws))"
"(for-each"
"(lambda(lit)"
"(unless(identifier? lit)"
"(raise-syntax-error"
" #f"
" \"literal is not a identifier\""
" x"
" lit)))"
"(stx->list kws))"
"(for-each"
"(lambda(clause)"
"(unless(and(stx-list? clause)"
"(<= 2(length(stx->list clause)) 3))"
"(raise-syntax-error"
" #f"
" \"bad clause\""
" x"
" clause)))"
" clauses)"
"(let((patterns(map stx-car clauses))"
"(fenders(map(lambda(clause)"
"(and(stx-pair?(stx-cdr(stx-cdr clause)))"
"(stx-car(stx-cdr clause))))"
" clauses))"
"(answers(map(lambda(clause)"
"(let((r(stx-cdr(stx-cdr clause))))"
"(if(stx-pair? r) "
"(stx-car r)"
"(stx-car(stx-cdr clause)))))"
" clauses)))"
"(let*((arg(quote-syntax arg))"
"(rslt(quote-syntax rslt))"
"(pattern-varss(map"
"(lambda(pattern)"
"(get-match-vars pattern(stx->list kws)))"
"(stx->list patterns)))"
"(lit-comp-is-mod?(and(identifier? lit-comp)"
"(module-identifier=? "
" lit-comp"
"(quote-syntax module-identifier=?)))))"
"(datum->syntax-object"
"(quote-syntax here)"
"(list(quote-syntax let)(list(list arg(list(quote-syntax datum->syntax-object)"
"(list"
"(quote-syntax quote-syntax)"
"(datum->syntax-object"
" expr"
" 'here))"
" expr)))"
"(let loop((patterns patterns)"
"(fenders fenders)"
"(unflat-pattern-varss pattern-varss)"
"(answers answers))"
"(cond"
"((null? patterns)"
"(list"
"(quote-syntax raise-syntax-error)"
" #f"
" \"bad syntax\""
" arg))"
"(else"
"(let((rest(loop(cdr patterns)(cdr fenders)"
"(cdr unflat-pattern-varss)(cdr answers))))"
"(let((pattern(car patterns))"
"(fender(car fenders))"
"(unflat-pattern-vars(car unflat-pattern-varss))"
"(answer(car answers)))"
"(define pattern-vars"
"(map(lambda(var)"
"(let loop((var var))"
"(if(syntax? var)"
" var"
"(loop(car var)))))"
" unflat-pattern-vars))"
"(define temp-vars"
"(map"
"(lambda(p)(datum->syntax-object p(gensym) #f))"
" pattern-vars))"
"(define tail-pattern-var(sub1(length pattern-vars)))"
"(let*((do-try-next(if(car fenders)"
"(list(quote-syntax try-next))"
" rest))"
"(m"
"(list(quote-syntax let)"
"(list "
"(list rslt"
"(list*(datum->syntax-object"
"(quote-syntax here)"
"(make-match&env"
" pattern"
"(stx->list kws)"
"(not lit-comp-is-mod?))"
" pattern)"
" arg"
"(if lit-comp-is-mod?"
" null"
"(list lit-comp)))))"
"(list "
"(quote-syntax if)"
" rslt"
"(list"
"(quote-syntax let) "
"(map(lambda(pattern-var temp-var)"
"(list"
" temp-var"
"(let((pos(stx-memq-pos pattern-var pattern-vars)))"
"(let((accessor(cond"
"((= tail-pattern-var pos)"
"(cond"
"((eq? pos 0) 'tail)"
"((eq? pos 1)(quote-syntax cdr))"
"((eq? pos 2)(quote-syntax cddr))"
"((eq? pos 3)(quote-syntax cdddr))"
"((eq? pos 4)(quote-syntax cddddr))"
"(else 'tail)))"
"((eq? pos 0)(quote-syntax car))"
"((eq? pos 1)(quote-syntax cadr))"
"((eq? pos 2)(quote-syntax caddr))"
"((eq? pos 3)(quote-syntax cadddr))"
"(else #f))))"
"(cond"
"((eq? accessor 'tail)"
"(if(zero? pos)"
" rslt"
"(list"
"(quote-syntax list-tail)"
" rslt"
" pos)))"
"(accessor(list"
" accessor"
" rslt))"
"(else(list"
"(quote-syntax list-ref)"
" rslt"
" pos)))))))"
" pattern-vars temp-vars)"
"(list"
"(quote-syntax letrec-syntaxes+values) "
"(map(lambda(pattern-var unflat-pattern-var temp-var)"
"(list(list pattern-var)"
"(list"
"(quote-syntax make-syntax-mapping)"
"(let loop((var unflat-pattern-var)(d 0))"
"(if(syntax? var)"
" d"
"(loop(car var)(add1 d))))"
"(list"
"(quote-syntax quote-syntax)"
" temp-var))))"
" pattern-vars unflat-pattern-vars"
" temp-vars)"
" null"
"(if fender"
"(list(quote-syntax if) fender"
" answer"
" do-try-next)"
" answer)))"
" do-try-next))))"
"(if fender"
"(list"
"(quote-syntax let)"
"(list(list(quote try-next)"
"(list(quote-syntax lambda)"
"(list)"
" rest)))"
" m)"
" m))))))))"
" x))))))"
"(define-syntax syntax"
"(lambda(x)"
"(define here-stx(quote-syntax here))"
"(unless(and(stx-pair? x)"
"(let((rest(stx-cdr x)))"
"(and(stx-pair? rest)"
"(stx-null?(stx-cdr rest)))))"
"(raise-syntax-error"
" #f"
" \"bad form\""
" x))"
"(datum->syntax-object"
" here-stx"
"(let((pattern(stx-car(stx-cdr x))))"
"(let((unique-vars(make-pexpand pattern #f null #f)))"
"(let((var-bindings"
"(map"
"(lambda(var)"
"(and(let((v(syntax-local-value var(lambda() #f))))"
"(and(syntax-mapping? v)"
" v))))"
" unique-vars)))"
"(if(and(or(null? var-bindings)"
"(not(ormap(lambda(x) x) var-bindings)))"
"(no-ellipses? pattern))"
"(list(quote-syntax quote-syntax) pattern)"
"(let((proto-r(let loop((vars unique-vars)(bindings var-bindings))"
"(if(null? bindings)"
" null"
"(let((rest(loop(cdr vars)"
"(cdr bindings))))"
"(if(car bindings)"
"(cons(let loop((v(car vars))"
"(d(syntax-mapping-depth(car bindings))))"
"(if(zero? d)"
" v"
"(loop(list v)(sub1 d))))"
" rest)"
" rest)))))"
"(non-pattern-vars(let loop((vars unique-vars)(bindings var-bindings))"
"(if(null? bindings)"
" null"
"(let((rest(loop(cdr vars)"
"(cdr bindings))))"
"(if(car bindings)"
" rest"
"(cons(car vars) rest)))))))"
"(let((build-from-template"
"(make-pexpand pattern proto-r non-pattern-vars pattern))"
"(r(let loop((vars unique-vars)(bindings var-bindings))"
"(cond"
"((null? bindings) null)"
"((car bindings)(cons "
"(datum->syntax-object"
"(car vars)"
"(syntax-e "
"(syntax-mapping-valvar(car bindings)))"
" x)"
"(loop(cdr vars)(cdr bindings))))"
"(else(loop(cdr vars)(cdr bindings)))))))"
"(if(identifier? pattern)"
"(car r)"
"(list(datum->syntax-object"
" here-stx"
" build-from-template"
" pattern)"
"(let((len(length r)))"
"(cond"
"((zero? len)(quote-syntax()))"
"((= len 1)(car r))"
"(else"
"(cons(quote-syntax list*) r))))"
"(list(quote-syntax quote-syntax)"
"(datum->syntax-object #f 'srctag x))))))))))"
" x)))"
"(provide syntax-case* syntax))"
);
  EVAL_ONE_STR(
"(module #%stxloc #%kernel"
"(require #%stxcase #%define-et-al)"
"(require-for-syntax #%kernel #%stxcase)"
"(define-syntax syntax-case"
"(lambda(stx)"
"(syntax-case* stx() module-identifier=?"
"((_ stxe kl clause ...)"
"(syntax(syntax-case* stxe kl module-identifier=? clause ...))))))"
"(define-syntax syntax/loc"
"(lambda(stx)"
"(syntax-case* stx() module-identifier=?"
"((_ loc pattern)"
"(syntax(let((stx(syntax pattern)))"
"(datum->syntax-object"
" stx"
"(syntax-e stx)"
" loc)))))))"
"(provide syntax/loc syntax-case))"
);
  EVAL_ONE_STR(
"(module #%with-stx #%kernel"
"(require #%stx #%stxloc #%small-scheme)"
"(require-for-syntax #%kernel #%stxcase #%stxloc)"
"(define-syntax with-syntax"
"(lambda(x)"
"(syntax-case x()"
"((_() e1 e2 ...)"
"(syntax/loc x(begin e1 e2 ...)))"
"((_((out in)) e1 e2 ...)"
"(syntax/loc x(syntax-case in()(out(begin e1 e2 ...)))))"
"((_((out in) ...) e1 e2 ...)"
"(syntax-case(map(lambda(x)"
"(datum->syntax-object"
" x"
" 'here"
" x))"
"(syntax->list(syntax(in ...))))()"
"((here ...)"
"(syntax/loc x(syntax-case(vector(datum->syntax-object "
"(quote-syntax here) "
" in) "
" ...)()"
"(#(out ...)(begin e1 e2 ...))))))))))"
"(define(generate-temporaries sl)"
"(unless(stx-list? sl)"
"(raise-type-error "
" 'generate-temporaries"
" \"syntax pair\""
" sl))"
"(let((l(stx->list sl)))"
"(map(lambda(x)(datum->syntax-object"
" #f"
"(cond"
"((or(symbol? x)(string? x))"
"(gensym x))"
"((identifier? x)"
"(gensym(syntax-e x)))"
"(else(gensym)))"
" #f)) l)))"
"(provide with-syntax generate-temporaries))"
);
  EVAL_ONE_STR(
"(module #%stxcase-scheme #%kernel"
"(require #%small-scheme #%stx #%stxcase #%with-stx #%stxloc)"
"(require-for-syntax #%kernel #%small-scheme #%stx #%stxcase #%with-stx #%stxloc)"
"(define(check-duplicate-identifier names)"
"(let/ec escape"
"(let((ht(make-hash-table)))"
"(for-each"
"(lambda(defined-name)"
"(unless(identifier? defined-name)"
"(raise-type-error 'check-duplicate-identifier"
" \"list of identifiers\" names))"
"(let((l(hash-table-get ht(syntax-e defined-name)(lambda() null))))"
"(when(ormap(lambda(i)(bound-identifier=? i defined-name)) l)"
"(escape defined-name))"
"(hash-table-put! ht(syntax-e defined-name)(cons defined-name l))))"
" names)"
" #f)))"
"(define-syntax letrec-syntaxes"
"(lambda(stx)"
"(syntax-case stx()"
"((_(((id ...) expr) ...) body1 body ...)"
"(syntax/loc stx"
"(letrec-syntaxes+values(((id ...) expr) ...)"
"()"
" body1 body ...))))))"
"(define-syntax letrec-syntax"
"(lambda(stx)"
"(syntax-case stx()"
"((_((id expr) ...) body1 body ...)"
"(syntax/loc stx"
"(letrec-syntaxes+values(((id) expr) ...)"
"()"
" body1 body ...))))))"
"(define-syntax let-syntaxes"
"(lambda(stx)"
"(syntax-case stx()"
"((_(((id ...) expr) ...) body1 body ...)"
"(with-syntax((((tmp ...) ...) "
"(map"
" generate-temporaries "
"(syntax->list(syntax((id ...) ...))))))"
"(syntax/loc stx"
"(letrec-syntaxes+values(((tmp ...) expr) ...)()"
"(letrec-syntaxes+values(((id ...)(values"
"(syntax-local-value(quote-syntax tmp) void)"
" ...)) ...)"
"()"
" body1 body ...))))))))"
"(define-syntax let-syntax"
"(lambda(stx)"
"(syntax-case stx()"
"((_((id expr) ...) body1 body ...)"
"(syntax/loc stx"
"(let-syntaxes(((id) expr) ...)"
" body1 body ...))))))"
"(define-syntax syntax-rules"
"(lambda(x)"
"(syntax-case x()"
"((_(k ...)((keyword . pattern) template) ...)"
"(andmap identifier?(syntax->list(syntax(k ...))))"
"(with-syntax(((dummy ...)"
"(generate-temporaries(syntax(keyword ...)))))"
"(syntax(lambda(x)"
"(syntax-case x(k ...)"
"((dummy . pattern)(syntax/loc x template))"
" ...))))))))"
"(provide(all-from #%stxcase)(all-from #%small-scheme)"
"(all-from #%with-stx)(all-from #%stxloc) check-duplicate-identifier"
" letrec-syntaxes letrec-syntax let-syntaxes let-syntax syntax-rules))"
);
  EVAL_ONE_STR(
"(module #%qqstx #%kernel"
"(require #%stxcase-scheme #%stx)"
"(require-for-syntax #%kernel #%stxcase-scheme #%stx)"
"(provide quasisyntax"
" quasisyntax/loc"
" unsyntax"
" unsyntax-splicing)"
"(define-syntaxes(unsyntax unsyntax-splicing)"
"(let((f(lambda(stx)"
"(raise-syntax-error"
" #f"
" \"illegal outside of quasisyntax\""
" stx"
" #f))))"
"(values f f)))"
"(define(check-splicing-list l)"
"(unless(stx-list? l)"
"(raise-type-error"
" 'unsyntax-splicing"
" \"proper syntax list\""
" l))"
" l)"
"(define-syntaxes(quasisyntax quasisyntax/loc)"
"(let((qq"
"(lambda(orig-stx body mk-final)"
"(let((here-stx #'here))"
"(let loop((stx body)"
"(depth 0)"
"(same-k(lambda()"
"(datum->syntax-object "
" here-stx"
"(mk-final body)"
" orig-stx)))"
"(convert-k(lambda(body bindings)"
"(datum->syntax-object "
" here-stx"
"(list"
"(quote-syntax with-syntax)"
" bindings"
"(mk-final body))"
" orig-stx))))"
"(syntax-case stx(unsyntax unsyntax-splicing quasisyntax)"
"((unsyntax x)"
"(if(zero? depth)"
"(let((temp(car(generate-temporaries '(uq)))))"
"(convert-k temp(list(list temp(syntax x)))))"
"(loop(syntax x)(sub1 depth)"
" same-k"
"(lambda(v bindings)"
"(convert-k(datum->syntax-object"
" here-stx"
"(list(stx-car stx) v)"
" stx)"
" bindings)))))"
"(unsyntax"
"(raise-syntax-error"
" #f"
" \"misuse within quasisyntax\""
" orig-stx"
" stx))"
"(((unsyntax-splicing x) . rest)"
"(if(zero? depth)"
"(let((rest-done-k"
"(lambda(rest-v bindings)"
"(with-syntax((temp(car(generate-temporaries '(uqs)))))"
"(convert-k(datum->syntax-object"
" stx"
"(list*(syntax temp)"
"(quote-syntax ...)"
" rest-v)"
" stx)"
"(cons(syntax((temp(... ...))(check-splicing-list x)))"
" bindings))))))"
"(loop(syntax rest) depth"
"(lambda()"
"(rest-done-k(syntax rest) null))"
" rest-done-k))"
"(let((mk-rest-done-k"
"(lambda(x-v x-bindings)"
"(lambda(rest-v rest-bindings)"
"(convert-k(datum->syntax-object"
" stx"
"(cons x-v rest-v)"
" stx)"
"(append x-bindings"
" rest-bindings))))))"
"(loop(syntax x)(sub1 depth)"
"(lambda()"
"(loop(syntax rest) depth"
" same-k"
"(mk-rest-done-k(stx-car stx) null)))"
"(lambda(x-v x-bindings)"
"(let((rest-done-k(mk-rest-done-k "
"(datum->syntax-object"
"(stx-car stx)"
"(list(stx-car(stx-car stx)) x-v)"
"(stx-car stx))"
" x-bindings)))"
"(loop(syntax rest) depth"
"(lambda()"
"(rest-done-k(syntax rest) null))"
" rest-done-k)))))))"
"(unsyntax-splicing"
"(raise-syntax-error"
" #f"
" \"misuse within quasisyntax\""
" orig-stx"
" stx))"
"((quasisyntax x)"
"(loop(syntax x)(add1 depth)"
" same-k"
"(lambda(v bindings)"
"(convert-k(datum->syntax-object"
" stx"
"(list(stx-car stx) v)"
" stx)"
" bindings))))"
"(_else"
"(cond"
"((pair?(syntax-e stx))"
"(let ploop((l(syntax-e stx))"
"(same-k same-k)"
"(convert-k(lambda(l bindings)"
"(convert-k(datum->syntax-object"
" stx"
" l"
" stx)"
" bindings))))"
"(cond"
"((pair? l)"
"(if(and(stx-pair?(car l))"
"(identifier?(stx-car(car l)))"
"(module-identifier=?(stx-car(car l))(quote-syntax unsyntax-splicing)))"
"(loop(datum->syntax-object #f l #f) depth"
" same-k "
" convert-k)"
"(ploop(cdr l)"
"(lambda()"
"(loop(car l) depth"
" same-k"
"(lambda(a a-bindings)"
"(convert-k(cons a(cdr l))"
" a-bindings))))"
"(lambda(rest rest-bindings)"
"(loop(car l) depth"
"(lambda()"
"(convert-k(cons(car l) rest)"
" rest-bindings))"
"(lambda(a a-bindings)"
"(convert-k(cons a rest)"
"(append a-bindings"
" rest-bindings))))))))"
"((null? l)(same-k))"
"(else(loop l depth same-k convert-k)))))"
"((vector?(syntax-e stx))"
"(loop(datum->syntax-object"
" stx"
"(vector->list(syntax-e stx))"
" stx)"
" depth"
" same-k"
"(lambda(v bindings)"
"(convert-k(datum->syntax-object"
" stx"
"(list->vector(syntax->list v))"
" stx)"
" bindings))))"
"(else"
"(same-k))))))))))"
"(values(lambda(orig-stx)"
"(syntax-case orig-stx()"
"((_ stx)(qq orig-stx"
"(syntax stx) "
"(lambda(body)"
"(list(quote-syntax syntax) body))))))"
"(lambda(orig-stx)"
"(syntax-case orig-stx()"
"((_ loc stx)(qq orig-stx"
"(syntax stx) "
"(lambda(body)"
"(list(quote-syntax syntax/loc) "
"(syntax loc)"
" body))))))))))"
);
  EVAL_ONE_STR(
"(module #%more-scheme #%kernel"
"(require #%small-scheme)"
"(require-for-syntax #%kernel #%stx #%stxcase-scheme)"
"(define(check-parameter-procedure p)"
"(unless(and(procedure? p)"
"(procedure-arity-includes? p 0)"
"(procedure-arity-includes? p 1))"
" (raise-type-error 'parameterize \"procedure (arity 0 and 1)\" p))"
" p)"
"(define-syntax case"
"(lambda(x)"
"(syntax-case x(else)"
"((_ v)"
"(syntax(begin v(cond))))"
"((_ v(else e1 e2 ...))"
"(syntax/loc x(begin v e1 e2 ...)))"
"((_ v((k ...) e1 e2 ...))"
"(syntax/loc x(if(memv v '(k ...))(begin e1 e2 ...))))"
"((_ v((k ...) e1 e2 ...) c1 c2 ...)"
"(syntax/loc x(let((x v))"
"(if(memv x '(k ...))"
"(begin e1 e2 ...)"
"(case x c1 c2 ...)))))"
"((_ v(bad e1 e2 ...) . rest)"
"(raise-syntax-error "
" #f"
" \"bad syntax (not a datum sequence)\""
" x"
"(syntax bad)))"
"((_ v clause . rest)"
"(raise-syntax-error "
" #f"
" \"bad syntax (missing expression after datum sequence)\""
" x"
"(syntax clause)))"
"((_ . v)"
"(not(null?(syntax-e(syntax v))))"
"(raise-syntax-error "
" #f"
" \"bad syntax (illegal use of `.')\""
" x)))))"
"(define-syntax do"
"(lambda(orig-x)"
"(syntax-case orig-x()"
"((_((var init . step) ...)(e0 e1 ...) c ...)"
"(with-syntax(((step ...)"
"(map(lambda(v s)"
"(syntax-case s()"
"(() v)"
"((e)(syntax e))"
"(_(raise-syntax-error "
" #f"
" \"bad variable syntax\""
" orig-x))))"
"(syntax->list(syntax(var ...)))"
"(syntax->list(syntax(step ...))))))"
"(syntax-case(syntax(e1 ...))()"
"(()(syntax/loc"
" orig-x"
"(let doloop((var init) ...)"
"(if(not e0)"
"(begin c ...(doloop step ...))))))"
"((e1 e2 ...)"
"(syntax/loc"
" orig-x"
"(let doloop((var init) ...)"
"(if e0"
"(begin e1 e2 ...)"
"(begin c ...(doloop step ...))))))))))))"
"(define-syntax delay"
"(lambda(x)"
"(syntax-case x()"
"((delay exp)"
"(syntax/loc x(make-a-promise(lambda() exp)))))))"
"(define-struct promise(p))"
"(define make-a-promise"
"(lambda(thunk)"
"(make-promise"
"(let((result(void))(set? #f))"
"(lambda()"
"(unless set?"
"(let((v(call-with-values thunk list)))"
"(unless set?"
"(set! result v)"
"(set! set? #t))))"
"(apply values result))))))"
"(define(force p)"
"(unless(promise? p)"
" (raise-type-error 'force \"promise\" p))"
"((promise-p p)))"
"(define-syntax parameterize"
"(lambda(stx)"
"(syntax-case stx()"
"((_() expr1 expr ...)"
"(syntax(let() expr1 expr ...)))"
"((_((param val) ...) expr1 expr ...)"
"(with-syntax(((pz ...)(generate-temporaries(syntax(param ...))))"
"((save ...)(generate-temporaries(syntax(param ...)))))"
"(syntax/loc"
" stx"
"(let((pz(check-parameter-procedure param)) ..."
"(save val) ...)"
"(let((swap"
"(lambda()"
" 'done"
"(let((x save))"
"(set! save(pz)) "
"(pz x))"
" ...)))"
"(dynamic-wind"
" swap"
"(lambda() expr1 expr ...)"
" swap)))))))))"
"(define-syntax with-handlers"
"(lambda(stx)"
"(syntax-case stx()"
"((_() expr1 expr ...)(syntax/loc stx(let() expr1 expr ...)))"
"((_((pred handler) ...) expr1 expr ...)"
"(syntax/loc"
" stx"
"((call/ec "
"(lambda(k)"
"(let((l(list(cons pred handler) ...)))"
"(parameterize((current-exception-handler"
"(lambda(e)"
"(k"
"(lambda()"
"(let loop((l l))"
"(cond"
"((null? l)"
"(raise e))"
"(((caar l) e)"
"((cdar l) e))"
"(else"
"(loop(cdr l))))))))))"
"(call-with-values(lambda() expr1 expr ...)"
"(lambda args(lambda()(apply values args))))))))))))))"
"(define-syntax set!-values"
"(lambda(stx)"
"(syntax-case stx()"
"((_() expr)(syntax(let-values((() expr))(void))))"
"((_(id) expr)(identifier?(syntax id))(syntax(set! id expr)))"
"((_(id ...) expr)"
"(let((ids(stx->list(syntax(id ...)))))"
"(for-each"
"(lambda(id)"
"(unless(identifier? id)"
"(raise-syntax-error #f"
" \"not an identifier\""
" stx"
" id)))"
" ids)"
"(let((dup(check-duplicate-identifier ids)))"
"(when dup"
"(raise-syntax-error #f"
" \"duplicate identifier\""
" stx"
" dup))))"
"(with-syntax(((temp ...)(generate-temporaries(syntax(id ...)))))"
"(syntax/loc"
" stx"
"(let-values(((temp ...) expr))"
"(set! id temp) ...)))))))"
"(define-syntax let/cc"
"(lambda(stx)"
"(syntax-case stx()"
"((_ var body1 body ...)"
"(syntax/loc stx(call/cc(lambda(var) body1 body ...)))))))"
"(define-syntax let-struct"
"(lambda(stx)"
"(syntax-case stx()"
"((_ base(field ...) body1 body ...)"
"(syntax/loc stx(let()"
"(define-struct base(field ...))"
" body1 body ...))))))"
"(define-syntax fluid-let"
"(lambda(stx)"
"(syntax-case stx()"
"((_() body1 body ...)(syntax/loc stx(let() body1 body ...)))"
"((_((name val) ...) body1 body ...)"
"(with-syntax(((tmp ...)(generate-temporaries(syntax(name ...)))))"
"(syntax/loc"
" stx"
"(let((tmp val) ...)"
"(let((swap"
"(lambda()"
"(let((s tmp))"
"(set! tmp name)"
"(set! name s))"
" ...)))"
"(dynamic-wind"
" swap"
"(lambda() body1 body ...)"
" swap)))))))))"
"(define-syntax time"
"(lambda(stx)"
"(syntax-case stx()"
"((_ expr1 expr ...)"
"(syntax/loc"
" stx"
"(let-values(((v cpu user gc)(time-apply(lambda() expr1 expr ...) null)))"
" (printf \"cpu time: ~s real time: ~s gc time: ~s~n\" cpu user gc)"
"(apply values v)))))))"
"(provide case do delay force promise?"
" parameterize with-handlers set!-values"
" let/cc let-struct fluid-let time))"
);
  EVAL_ONE_STR(
"(module #%misc #%kernel"
"(require #%more-scheme #%small-scheme)"
"(define rationalize"
"(letrec((check(lambda(x) "
" (unless (real? x) (raise-type-error 'rationalize \"real\" x))))"
"(find-between "
"(lambda(lo hi)"
"(if(integer? lo)"
" lo"
"(let((lo-int(floor lo))"
"(hi-int(floor hi)))"
"(if(< lo-int hi-int)"
"(add1 lo-int)"
"(+ lo-int"
"(/(find-between(/(- hi lo-int))(/(- lo lo-int)))))))))))"
"(lambda(x within)"
"(check x)(check within)"
"(let*((delta(abs within))"
"(lo(- x delta))"
"(hi(+ x delta)))"
"(cond"
"((not(= x x)) +nan.0)"
"((<= lo 0 hi)(if(exact? x) 0 0.0))"
"((negative? lo)(-(find-between(- hi)(- lo))))"
"(else(find-between lo hi)))))))"
"(define(read-eval-print-loop)"
"(let*((eeh #f)"
"(jump #f)"
"(be? #f)"
"(rep-error-escape-handler(lambda()(jump))))"
"(dynamic-wind"
"(lambda()(set! eeh(error-escape-handler))"
"(set! be?(break-enabled))"
"(error-escape-handler rep-error-escape-handler)"
"(break-enabled #f))"
"(lambda()"
"(let/ec done"
"(let loop()"
"(let/ec k"
"(dynamic-wind"
"(lambda()"
"(break-enabled be?)"
"(set! jump k))"
"(lambda()"
"(let((v((current-prompt-read))))"
"(when(eof-object? v)(done(void)))"
"(call-with-values"
"(lambda()((current-eval) v))"
"(lambda results(for-each(current-print) results)))))"
"(lambda() "
"(set! be?(break-enabled))"
"(break-enabled #f)"
"(set! jump #f))))"
"(loop))))"
"(lambda()(error-escape-handler eeh)"
"(break-enabled be?)"
"(set! jump #f)"
"(set! eeh #f)))))"
"(define load/cd"
"(lambda(n)"
"(unless(string? n)"
" (raise-type-error 'load/cd \"string\" n))"
"(let-values(((base name dir?)(split-path n)))"
"(if dir?"
"(raise"
"(make-exn:i/o:filesystem"
"(string->immutable-string"
" (format \"load/cd: cannot open a directory: ~s\" n))"
"(current-continuation-marks)"
" n"
" #f))"
"(if(not(string? base))"
"(load n)"
"(begin"
"(if(not(directory-exists? base))"
"(raise"
"(make-exn:i/o:filesystem"
"(string->immutable-string"
"(format "
" \"load/cd: directory of ~s does not exist (current directory is ~s)\" "
" n(current-directory)))"
"(current-continuation-marks)"
" base"
" #f)))"
"(let((orig(current-directory)))"
"(dynamic-wind"
"(lambda()(current-directory base))"
"(lambda()(load name))"
"(lambda()(current-directory orig))))))))))"
"(define(-load load name path)"
"(unless(and(string? path)(or(relative-path? path)(absolute-path? path)))"
" (raise-type-error name \"pathname string\" path))"
"(if(complete-path? path)"
"(load path)"
"(let((dir(current-load-relative-directory)))"
"(load(if dir(path->complete-path path dir) path)))))"
"(define(load-relative path)(-load load 'load-relative path))"
"(define(load-relative-extension path)(-load load-extension 'load-relative-extension path))"
"(define path-list-string->path-list"
"(let((r(regexp(let((sep(case(system-type) "
" ((unix beos oskit macosx) \":\")"
" ((windows macos) \";\"))))\n"
" (format \"([^~a]*)~a(.*)\" sep sep))))"
"(cons-path(lambda(default s l) "
" (if (string=? s \"\")"
"(append default l)"
"(if(or(relative-path? s)(absolute-path? s))(cons s l) l)))))"
"(lambda(s default)"
" (unless (string? s) (raise-type-error 'path-list-string->path-list \"string\" s))"
" (unless (list? default) (raise-type-error 'path-list-string->path-list \"list\" default))"
"(let loop((s s))"
"(let((m(regexp-match r s)))"
"(if m"
"(cons-path default(cadr m)(loop(caddr m)))"
"(cons-path default s null)))))))"
"(define find-executable-path"
"(lambda(program libpath)"
"(unless(and(string? program) "
"(or(relative-path? program)"
"(absolute-path? program)))"
" (raise-type-error 'find-executable-path \"path string\" program))"
"(unless(or(not libpath)(and(string? libpath)(relative-path? libpath)))"
" (raise-type-error 'find-executable-path \"relative-path string or #f\" libpath))"
"(letrec((found-exec"
"(lambda(exec-name)"
"(if libpath"
"(let-values(((base name isdir?)(split-path exec-name)))"
"(if(string? base)"
"(let((lib(build-path base libpath)))"
"(if(or(directory-exists? lib) "
"(file-exists? lib))"
" lib"
"(let((resolved(resolve-path exec-name)))"
"(cond"
"((string=? resolved exec-name) #f)"
"((relative-path? resolved)"
"(found-exec(build-path base resolved)))"
"(else(found-exec resolved))))))"
" #f))"
" exec-name))))"
"(if(and(relative-path? program)"
"(let-values(((base name dir?)(split-path program)))"
"(eq? base 'relative)))"
" (let ((paths-str (getenv \"PATH\"))"
" (win-add (lambda (s) (if (eq? (system-type) 'windows) (cons \".\" s) s))))"
"(let loop((paths(if paths-str "
"(win-add(path-list-string->path-list paths-str null))"
" null)))"
"(if(null? paths)"
" #f"
"(let*((base(path->complete-path(car paths)))"
"(name(build-path base program)))"
"(if(file-exists? name)"
"(found-exec name)"
"(loop(cdr paths)))))))"
"(let((p(path->complete-path program)))"
"(and(file-exists? p)(found-exec p)))))))"
"(define(-check-relpath who s)"
"(unless(string? s)"
" (raise-type-error who \"string\" s))"
"(unless(relative-path? s)"
"(raise(make-exn:i/o:filesystem"
"(string->immutable-string"
" (format \"~a: invalid relative path: ~s\" who s))"
"(current-continuation-marks) s 'ill-formed-path))))"
"(define(-check-collection who collection collection-path)"
"(-check-relpath who collection) "
"(for-each(lambda(p)(-check-relpath who p)) collection-path))"
"(define(-find-col who collection collection-path)"
"(let((all-paths(current-library-collection-paths)))"
"(let cloop((paths all-paths))"
"(if(null? paths)"
"(raise"
"(make-exn:i/o:filesystem"
"(string->immutable-string"
" (format \"~a: collection not found: ~s in any of: ~s\" "
" who(if(null? collection-path)"
" collection"
"(apply build-path collection collection-path))"
" all-paths))"
"(current-continuation-marks)"
" collection"
" #f))"
"(let((dir(build-path(car paths) collection)))"
"(if(directory-exists? dir)"
"(let*((cpath(apply build-path dir collection-path)))"
"(if(directory-exists? cpath)"
" cpath"
"(cloop(cdr paths))))"
"(cloop(cdr paths))))))))"
" (define -re:suffix (regexp \"\\\\..?.?.?$\"))"
" "
"(define current-load/use-compiled"
"(make-parameter"
"(let((default-load/use-compiled"
"(let((resolve(lambda(s)"
"(if(complete-path? s)"
" s"
"(let((d(current-load-relative-directory)))"
"(if d(path->complete-path s d) s)))))"
"(date>=?"
"(lambda(a bm)"
"(and a"
"(let((am(with-handlers((not-break-exn?(lambda(x) #f)))"
"(file-or-directory-modify-seconds a))))"
"(or(and(not bm) am)(and am bm(>= am bm))))))))"
"(lambda(path expect-module)"
"(unless(and(string? path)(or(relative-path? path)(absolute-path? path)))"
" (raise-type-error 'load/use-compiled \"pathname string\" path))"
"(let*-values(((path)(resolve path))"
"((base file dir?)(split-path path))"
"((base)(if(eq? base 'relative) 'same base))"
"((mode)(use-compiled-file-kinds))"
"((comp?)(not(eq? mode 'none))))"
"(let*((get-so(lambda(file)"
"(if comp?"
"(build-path base"
" \"compiled\""
" \"native\""
"(system-library-subpath)"
"(regexp-replace "
" -re:suffix file"
"(case(system-type)"
" ((windows) \".dll\")"
" (else \".so\"))))"
" #f)))"
"(zo(and comp?"
"(build-path base"
" \"compiled\""
" (regexp-replace -re:suffix file \".zo\"))))"
"(so(get-so file))"
" (_loader-so (get-so \"_loader.ss\"))"
"(path-d(with-handlers((not-break-exn?(lambda(x) #f)))"
"(file-or-directory-modify-seconds path)))"
"(with-dir(lambda(t) "
"(parameterize((current-load-relative-directory "
"(if(string? base) base(current-directory))))"
"(t)))))"
"(cond"
"((and(date>=? _loader-so path-d)"
"(let((getter(load-extension _loader-so)))"
" (let-values (((loader modname) (getter (string->symbol (regexp-replace -re:suffix file \"\")))))"
"(and loader"
"(begin"
"(when expect-module"
"(unless(eq? modname expect-module)"
"(raise"
"(make-exn:module"
"(string->immutable-string"
" (format \"load-extension: expected module declaration for `~a', found ~a through loader: ~~e\""
" expect-module"
"(if modname "
" (format \"module declaration for `~a'\" modname)"
" \"none\")"
" _loader-so))"
"(current-continuation-marks)))))"
" loader)))))"
" =>(lambda(loader)(with-dir loader)))"
"((date>=? so path-d)"
"(with-dir(lambda()((current-load-extension) so expect-module))))"
"((date>=? zo path-d)"
"(with-dir(lambda()((current-load) zo expect-module))))"
"(else"
"(with-dir(lambda()((current-load) path expect-module)))))))))))"
" default-load/use-compiled)"
"(lambda(p)"
"(unless(and(procedure? p)"
"(procedure-arity-includes? p 2))"
"(raise-type-error 'current-load/use-compiled"
" \"procedure (arity 2)\""
" p))"
" p)))"
"(define(collection-path collection . collection-path) "
"(-check-collection 'collection-path collection collection-path)"
"(-find-col 'collection-path collection collection-path))"
"(define(load/use-compiled f)((current-load/use-compiled) f #f))"
" (define -re:dir (regexp \"(.+?)/+(.*)\"))"
" (define -re:auto (regexp \"^,\"))"
" (define -re:ok-relpath (regexp \"^[-a-zA-Z0-9_. ]+(/+[-a-zA-Z0-9_. ]+)*$\"))"
"(define -module-hash-table-table(make-hash-table 'weak)) "
"(define -loading-filename(gensym))"
"(define standard-module-name-resolver"
"(lambda(s relto stx)"
"(if s"
"(let((get-dir(lambda()"
"(or(and relto"
"(let((rts(symbol->string relto)))"
"(and(regexp-match -re:auto rts)"
"(let-values(((base n d?)"
"(split-path "
"(substring rts 1(string-length rts)))))"
" base))))"
"(current-load-relative-directory)"
"(current-directory)))))"
"(let((filename"
"(cond"
"((string? s)"
"(if(regexp-match -re:ok-relpath s)"
"(let loop((path(get-dir))(s s))"
"(let((prefix(regexp-match -re:dir s)))"
"(if prefix"
"(loop(build-path path "
"(let((p(cadr prefix)))"
"(cond"
" ((string=? p \".\") 'same)"
" ((string=? p \"..\") 'up)"
"(else p))))"
"(caddr prefix))"
"(build-path path s))))"
"(list"
"(string-append"
" \" (relative string form must contain only a-z, A-Z, 0-9, -, _, ., /, and \""
" \"space, with no leading or trailing /)\"))))"
"((or(not(pair? s))"
"(not(list? s)))"
" #f)"
"((eq?(car s) 'lib)"
"(let((cols(let((len(length s)))"
"(if(= len 2)"
" (list \"mzlib\")"
"(if(> len 2)"
"(cddr s)"
" #f)))))"
"(and cols"
"(andmap(lambda(x)(and(string? x)(relative-path? x))) cols)"
"(string?(cadr s))"
"(relative-path?(cadr s))"
"(let((p(-find-col 'standard-module-name-resolver(car cols)(cdr cols))))"
"(build-path p(cadr s))))))"
"((eq?(car s) 'file)"
"(and(=(length s) 2)"
"(let((p(cadr s)))"
"(and(string? p)"
"(or(relative-path? p)"
"(absolute-path? p))"
"(path->complete-path p(get-dir))))))"
"(else #f))))"
"(unless(string? filename)"
"(if stx"
"(raise-syntax-error"
" '(require require mzscheme)"
" (format \"bad module path~a\" (if filename"
"(car filename)"
" \"\"))"
" stx)"
"(raise-type-error "
" 'standard-module-name-resolver"
" (format \"module path~a\" (if filename"
"(car filename)"
" \"\"))"
" s)))"
"(let((filename(normal-case-path(simplify-path(expand-path filename)))))"
"(let-values(((base name dir?)(split-path filename)))"
" (let ((no-sfx (regexp-replace -re:suffix name \"\"))"
" (abase (format \",~a\" base)))"
"(let((modname(string->symbol(string-append abase no-sfx)))"
"(ht(hash-table-get"
" -module-hash-table-table"
"(current-namespace)"
"(lambda()"
"(let((ht(make-hash-table)))"
"(hash-table-put! -module-hash-table-table"
"(current-namespace)"
" ht)"
" ht)))))"
"(let((got(hash-table-get ht modname(lambda() #f)))"
"(suffix(let((m(regexp-match -re:suffix name)))"
"(if m(car m) #t))))"
"(when got"
"(unless(or(symbol? got)(equal? suffix got))"
"(error"
" 'standard-module-name-resolver"
" \"module previously loaded with suffix ~s, cannot load with suffix ~s: ~e\""
" (if (eq? #t got) \"\" got)"
" (if (eq? #t suffix) \"\" suffix)"
" filename)))"
"(unless got"
"(let((l(continuation-mark-set->list"
"(current-continuation-marks)"
" -loading-filename)))"
"(for-each"
"(lambda(s)"
"(when(string=? s filename)"
"(error"
" 'standard-module-name-resolver"
" \"cycle in loading at ~e: ~e\""
" filename"
"(reverse(cons s l)))))"
" l))"
"(let((prefix(string->symbol abase)))"
"(with-continuation-mark -loading-filename filename"
"(parameterize((current-module-name-prefix prefix))"
"((current-load/use-compiled) filename(string->symbol no-sfx)))))"
"(hash-table-put! ht modname suffix)))"
" modname))))))"
"(let((ht(hash-table-get"
" -module-hash-table-table"
"(current-namespace)"
"(lambda()"
"(let((ht(make-hash-table)))"
"(hash-table-put! -module-hash-table-table"
"(current-namespace)"
" ht)"
" ht)))))"
"(hash-table-put! ht relto 'attach)))))"
"(define(find-library-collection-paths)"
"(path-list-string->path-list"
" (or (getenv \"PLTCOLLECTS\") \"\")"
"(or(ormap"
"(lambda(f)(let((p(f)))(and p(directory-exists? p)(list p))))"
"(list"
" (lambda () (let ((v (getenv \"PLTHOME\")))"
" (and v (build-path v \"collects\"))))"
" (lambda () (find-executable-path (find-system-path 'exec-file) \"collects\"))"
" (lambda () (find-executable-path (find-system-path 'exec-file) (build-path 'up \"collects\")))"
" (lambda () (find-executable-path (find-system-path 'exec-file) (build-path 'up 'up \"collects\")))"
" (lambda () (find-executable-path (find-system-path 'exec-file) (build-path 'up 'up 'up \"collects\")))))"
" null)))"
"(define(port? x)(or(input-port? x)(output-port? x)))"
"(define(not-break-exn? x)(not(exn:break? x)))"
"(define interaction-environment(lambda()(current-namespace)))"
"(define(scheme-report-environment n)"
"(unless(= n 5)"
" (raise-type-error 'scheme-report-environment \"5\" n))"
"(mk-r5rs #f))"
"(define(null-environment n)"
"(unless(= n 5)"
" (raise-type-error 'null-environment \"5\" n))"
"(mk-r5rs #t))"
"(define(mk-r5rs stx-only?)"
"(let((n(make-namespace 'empty))"
"(orig(make-namespace)))"
"(parameterize((current-namespace n))"
"(namespace-attach-module orig '#%r5rs)"
"(namespace-require '#%r5rs)"
"(namespace-transformer-require '(rename mzscheme syntax-rules syntax-rules))"
"(unless stx-only?"
"(for-each"
"(lambda(n)"
"(namespace-set-variable-value! n(dynamic-require 'mzscheme n)))"
" '(car "
" cdr caar cadr cdar cddr"
" caaar caadr cadar caddr cdaar cdadr cddar cdddr"
" caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr"
" cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr"
" map = < > <= >= max min + - * / "
" abs gcd lcm exp log sin cos tan not eq?"
" call-with-current-continuation make-string"
" symbol->string string->symbol make-rectangular "
" exact->inexact inexact->exact number->string string->number "
" rationalize output-port? current-input-port current-output-port current-error-port "
" open-input-file open-output-file close-input-port close-output-port"
" with-output-to-file transcript-on transcript-off flush-output"
" string-length string-ci<=? string-ci>=? string-append "
" string->list list->string string-fill! "
" vector-length vector->list list->vector vector-fill!"
" char-alphabetic? char-numeric? char-whitespace? "
" char-upper-case? char-lower-case? char->integer integer->char char-downcase"
" call-with-output-file call-with-input-file with-input-from-file"
" apply for-each symbol? pair? cons set-car! set-cdr! null? list? list length append reverse"
" list-tail list-ref memq memv member assq assv assoc procedure?"
" number? complex? real? rational? integer? exact? inexact? zero?"
" positive? negative? odd? even? "
" quotient remainder modulo floor ceiling truncate round "
" numerator denominator asin acos atan sqrt"
" expt make-polar real-part imag-part angle magnitude input-port?"
" read read-char peek-char eof-object?"
" char-ready? write display newline write-char load "
" string? string string-ref string-set! string=? substring string-copy"
" string-ci=? string<? string>? string<=? string>=? string-ci<? string-ci>?"
" vector? make-vector vector vector-ref vector-set! "
" char? char=? char<? char>? char<=? char>=? "
" char-ci=? char-ci<? char-ci>? char-ci<=? char-ci>=? "
" char-upcase boolean? eqv? equal? force"
" call-with-values values eval port? scheme-report-environment null-environment "
" interaction-environment dynamic-wind))))"
" n))"
"(provide rationalize "
" read-eval-print-loop"
" load/cd"
" load-relative load-relative-extension"
" path-list-string->path-list find-executable-path"
" collection-path load/use-compiled current-load/use-compiled"
" port? not-break-exn?"
" find-library-collection-paths"
" interaction-environment scheme-report-environment null-environment"
" standard-module-name-resolver))"
);
  EVAL_ONE_STR(
"(module #%stxmz-body #%kernel"
"(require #%stxcase-scheme)"
"(require-for-syntax #%kernel #%stx)"
"(require(rename #%kernel #%plain-module-begin #%module-begin))"
"(define-syntax mzscheme-in-stx-module-begin"
"(lambda(stx)"
"(if(stx-pair? stx)"
"(datum->syntax-object"
"(quote-syntax here)"
"(list*(quote-syntax #%plain-module-begin)"
"(quote-syntax"
"(require-for-syntax mzscheme))"
"(stx-cdr stx))"
" stx)"
" (raise-syntax-error #f \"bad syntax\" stx))))"
"(provide mzscheme-in-stx-module-begin))"
);
  EVAL_ONE_STR(
"(module mzscheme #%kernel"
"(require #%more-scheme)"
"(require #%misc)"
"(require #%stxcase-scheme)"
"(require #%stx)"
"(require #%stxmz-body)"
"(require #%qqstx)"
"(provide(all-from #%more-scheme)"
"(all-from #%misc)"
"(all-from #%stxcase-scheme)"
" identifier? "
"(all-from #%qqstx)"
"(all-from-except #%kernel #%module-begin)"
"(rename mzscheme-in-stx-module-begin #%module-begin)"
"(rename #%module-begin #%plain-module-begin)))"
);
  EVAL_ONE_STR(
"(module #%r5rs mzscheme"
"(provide quasiquote unquote unquote-splicing "
" if let and or cond case define delay do"
" letrec let* begin lambda quote set!"
" define-syntax"
" #%app #%datum #%top))"
);
  EVAL_ONE_STR(
"(require(rename mzscheme namespace-require/copy namespace-require/copy))"
);
  EVAL_ONE_STR(
"(begin"
"(namespace-require/copy 'mzscheme)"
"(require-for-syntax mzscheme))"
);
  EVAL_ONE_STR(
"(current-module-name-resolver standard-module-name-resolver)"
);
