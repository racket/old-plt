This is lightning.info, produced by makeinfo version 4.5 from
lightning.texi.

INFO-DIR-SECTION GNU lightning, a library for dynamic code generation
START-INFO-DIR-ENTRY
* Using and porting GNU lightning: (lightning).
END-INFO-DIR-ENTRY

   This file documents GNU lightning, Version 1.2a.  It was last
updated on 15 March 2004.

   Copyright (C) 2000 Free Software Foundation, Inc.  Authored by Paolo
Bonzini.

   This document is released under the terms of the GNU Free
Documentation License as published by the Free Software Foundation;
either version 1.1, or (at your option) any later version.

   You should have received a copy of the GNU Free Documentation
License along with GNU lightning; see the file `COPYING.DOC'.  If not,
write to the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.

   There are no Secondary Sections, no Cover Texts and no Invariant
Sections (as defined in the license); this text, along with its
equivalent in the printed manual, constitutes the Title Page.


File: lightning.info,  Node: Implementing the ABI,  Next: Macro list,  Prev: Immediate values,  Up: Standard macros

Implementing the ABI
--------------------

   Implementing the underlying architecture's ABI is done in the macros
that handle function prologs and epilogs and argument passing.

   Let's look at the prologs and epilogs first.  These are usually
pretty simple and, what's more important, with constant content--that
is, they always generate exactly the same instruction sequence.  Here is
an example:

               SPARC                        x86
               save %sp, -96, %sp           push %ebp
                                            push %ebx
                                            push %esi
                                            push %edi
                                            movl %esp, %ebp
               ...                          ...
               ret                          popl %edi
               restore                      popl %esi
                                            popl %ebx
                                            popl %ebp
                                            ret

   The registers that are saved (`%ebx', `%esi', `%edi') are mapped to
the `V0' through `V2' registers in the GNU lightning instruction set.

   Argument passing is more tricky.  There are basically three cases(1):
Register windows
     Output registers are different from input registers--the prolog
     takes care of moving the caller's output registers to the callee's
     input registers.  This is the case with the SPARC.

Passing parameters via registers
     In this case, output registers are the same as input registers.
     The program must take care of saving input parameters somewhere
     (on the stack, or in non-argument registers).  This is the case
     with the PowerPC.

All the parameters are passed on the stack
     This case is by far the simplest and is the most common in CISC
     architectures, like the x86 and Motorola 68000.

   In all cases, the port-specific header file will define two variable
for private use--one to be used by the caller during the
`prepare'/`pusharg'/`finish' sequence, one to be used by the callee,
specifically in the `jit_prolog' and `jit_arg' macros.

   Let's look again, this time with more detail, at each of the cases.

Register windows
     `jit_finish' is the same as `jit_calli', and is defined in
     `core-common.h' (*note Common features supported by
     `core-common.h': Common features.).

          #define jit_prepare_i(numargs)  (_jitl.pusharg = _Ro(numargs))
          #define jit_pusharg_i(rs)       (--_jitl.pusharg,         \
                                           MOVrr((rs), _jitl.pusharg))

     Remember that arguments pushing takes place in reverse order, thus
     giving a pre-decrement (rather than post-increment) in
     `jit_pusharg_i'.

     Here is what happens on the callee's side:

          #define jit_arg_c()           (_jitl.getarg++)
          #define jit_getarg_c(rd, ofs) jit_extr_c_i  ((rd), (ofs))
          #define jit_prolog(numargs)   (SAVErir(JIT_SP, -96, JIT_SP), \
                                         _jitl.getarg = _Ri(0))

     The `jit_arg' macros return nothing more than a register index,
     which is then used by the `jit_getarg' macros.  `jit_prolog'
     resets the counter used by `jit_arg' to zero; the `numargs'
     parameter is not used. It is sufficient for `jit_leaf' to be a
     synonym for `jit_prolog'.

Passing parameter via registers
     The code is almost the same as that for the register windows case,
     but with an additional complexity--`jit_arg' will transfer the
     argument from the input register to a non-argument register so that
     function calls will not clobber it.  The prolog and epilog code
     can then become unbearably long, up to 20 instructions on the PPC;
     a common solution in this case is that of "trampolines".

     The prolog does nothing more than put the function's actual
     address in a caller-preserved register and then call the
     trampoline:
                 mflr    r0                 ! grab return address
                 movei   r10, trampo_2args  ! jump to trampoline
                 mtlr    r10
                 blrl
          here:  mflr    r31                ! r31 = address of epilog
                 ...actual code...
                 mtlr    r31                ! return to the trampoline
                 blr

     In this case, `jit_prolog' does use its argument containing the
     number of parameters to pick the appropriate trampoline. Here,
     `trampo_2args' is the address of a trampoline designed for
     2-argument functions.

     The trampoline executes the prolog code, jumps to the contents of
     `r10', and upon return from the subroutine it executes the epilog
     code.

All the parameters are passed on the stack
     `jit_pusharg' uses a hardware push operation, which is commonly
     available on CISC machines (where this approach is most likely
     followed).  Since the stack has to be cleaned up after the call,
     `jit_prepare_i' remembers how many parameters have been put there,
     and `jit_finish' adjusts the stack pointer after the call.

          #define jit_prepare_i(numargs) (_jitl.args += (numargs))
          #define jit_pusharg_i(rs)      PUSHLr(rs)
          #define jit_finish(sub)        (jit_calli((sub)),              \
                                         ADDLir(4 * _jitl.args, JIT_SP), \
                                         _jitl.numargs = 0)

     Note the usage of `+=' in `jit_prepare_i'.  This is done so that
     one can defer the popping of the arguments that were saved on the
     stack ("stack pollution").  To do so, it is sufficient to use
     `jit_calli' instead of `jit_finish' in all but the last call.

     On the caller's side, `arg' returns an offset relative to the
     frame pointer, and `getarg' loads the argument from the stack:

          #define jit_getarg_c(rd, ofs) jit_ldxi_c((rd), _EBP, (ofs));
          #define jit_arg_c()           ((_jitl.frame += sizeof(int) \
                                                      -  sizeof(int))

     The `_jitl.frame' variable is initialized by `jit_prolog' with the
     displacement between the value of the frame pointer (`%ebp') and
     the address of the first parameter.

   These schemes are the most used, so `core-common.h' provides a way
to employ them automatically.  If you do not define the `jit_getarg_c'
macro and its companions, `core-common.h' will presume that you intend
to pass parameters through either the registers or the stack.

   If you define `JIT_FP', stack-based parameter passing will be
employed and the `jit_getarg' macros will be defined like this:

     #define jit_getarg_c(reg, ofs)  jit_ldxi_c((reg), JIT_FP, (ofs));

   In other words, the `jit_arg' macros (which are still to be defined
by the platform-specific back-end) shall return an offset into the stack
frame.  On the other hand, if you don't define `JIT_FP', register-based
parameter passing will be employed and the `jit_arg' macros shall
return a register number; in this case, `jit_getarg' will be
implemented in terms of `jit_extr' and `jit_movr' operations:

     #define jit_getarg_c(reg, ofs)		jit_extr_c_i  ((reg), (ofs))
     #define jit_getarg_i(reg, ofs)		jit_movr_i    ((reg), (ofs))

   ---------- Footnotes ----------

   (1) For speed and ease of implementation, GNU lightning does not
currently support passing some of the parameters on the stack and some
in registers.


File: lightning.info,  Node: Macro list,  Prev: Implementing the ABI,  Up: Standard macros

Macros composing the platform-independent layer
-----------------------------------------------

Register names (all mandatory but the last two)
          #define JIT_R
          #define JIT_R_NUM
          #define JIT_V
          #define JIT_V_NUM
          #define JIT_FPR
          #define JIT_FPR_NUM
          #define JIT_SP
          #define JIT_FP
          #define JIT_RZERO

Helper macros (non-mandatory):
          #define jit_fill_delay_after(branch)

Mandatory:
          #define jit_arg_c()
          #define jit_arg_i()
          #define jit_arg_l()
          #define jit_arg_p()
          #define jit_arg_s()
          #define jit_arg_uc()
          #define jit_arg_ui()
          #define jit_arg_ul()
          #define jit_arg_us()
          #define jit_abs_d(rd,rs)
          #define jit_addi_i(d, rs, is)
          #define jit_addr_d(rd,s1,s2)
          #define jit_addr_i(d, s1, s2)
          #define jit_addxi_i(d, rs, is)
          #define jit_addxr_i(d, s1, s2)
          #define jit_andi_i(d, rs, is)
          #define jit_andr_i(d, s1, s2)
          #define jit_beqi_i(label, rs, is)
          #define jit_beqr_d(label, s1, s2)
          #define jit_beqr_i(label, s1, s2)
          #define jit_bgei_i(label, rs, is)
          #define jit_bgei_ui(label, rs, is)
          #define jit_bger_d(label, s1, s2)
          #define jit_bger_i(label, s1, s2)
          #define jit_bger_ui(label, s1, s2)
          #define jit_bgti_i(label, rs, is)
          #define jit_bgti_ui(label, rs, is)
          #define jit_bgtr_d(label, s1, s2)
          #define jit_bgtr_i(label, s1, s2)
          #define jit_bgtr_ui(label, s1, s2)
          #define jit_blei_i(label, rs, is)
          #define jit_blei_ui(label, rs, is)
          #define jit_bler_d(label, s1, s2)
          #define jit_bler_i(label, s1, s2)
          #define jit_bler_ui(label, s1, s2)
          #define jit_bltgtr_d(label, s1, s2)
          #define jit_blti_i(label, rs, is)
          #define jit_blti_ui(label, rs, is)
          #define jit_bltr_d(label, s1, s2)
          #define jit_bltr_i(label, s1, s2)
          #define jit_bltr_ui(label, s1, s2)
          #define jit_bmci_i(label, rs, is)
          #define jit_bmcr_i(label, s1, s2)
          #define jit_bmsi_i(label, rs, is)
          #define jit_bmsr_i(label, s1, s2)
          #define jit_bnei_i(label, rs, is)
          #define jit_bner_d(label, s1, s2)
          #define jit_bner_i(label, s1, s2)
          #define jit_boaddi_i(label, rs, is)
          #define jit_boaddi_ui(label, rs, is)
          #define jit_boaddr_i(label, s1, s2)
          #define jit_boaddr_ui(label, s1, s2)
          #define jit_bordr_d(label, s1, s2)
          #define jit_bosubi_i(label, rs, is)
          #define jit_bosubi_ui(label, rs, is)
          #define jit_bosubr_i(label, s1, s2)
          #define jit_bosubr_ui(label, s1, s2)
          #define jit_buneqr_d(label, s1, s2)
          #define jit_bunger_d(label, s1, s2)
          #define jit_bungtr_d(label, s1, s2)
          #define jit_bunler_d(label, s1, s2)
          #define jit_bunltr_d(label, s1, s2)
          #define jit_bunordr_d(label, s1, s2)
          #define jit_calli(label)
          #define jit_callr(label)
          #define jit_ceilr_d_i(rd, rs)
          #define jit_divi_i(d, rs, is)
          #define jit_divi_ui(d, rs, is)
          #define jit_divr_d(rd,s1,s2)
          #define jit_divr_i(d, s1, s2)
          #define jit_divr_ui(d, s1, s2)
          #define jit_eqi_i(d, rs, is)
          #define jit_eqr_d(d, s1, s2)
          #define jit_eqr_i(d, s1, s2)
          #define jit_extr_i_d(rd, rs)
          #define jit_floorr_d_i(rd, rs)
          #define jit_gei_i(d, rs, is)
          #define jit_gei_ui(d, s1, s2)
          #define jit_ger_d(d, s1, s2)
          #define jit_ger_i(d, s1, s2)
          #define jit_ger_ui(d, s1, s2)
          #define jit_gti_i(d, rs, is)
          #define jit_gti_ui(d, s1, s2)
          #define jit_gtr_d(d, s1, s2)
          #define jit_gtr_i(d, s1, s2)
          #define jit_gtr_ui(d, s1, s2)
          #define jit_hmuli_i(d, rs, is)
          #define jit_hmuli_ui(d, rs, is)
          #define jit_hmulr_i(d, s1, s2)
          #define jit_hmulr_ui(d, s1, s2)
          #define jit_jmpi(label)
          #define jit_jmpr(reg)
          #define jit_ldxi_f(rd, rs, is)
          #define jit_ldxr_f(rd, s1, s2)
          #define jit_ldxi_c(d, rs, is)
          #define jit_ldxi_d(rd, rs, is)
          #define jit_ldxi_i(d, rs, is)
          #define jit_ldxi_s(d, rs, is)
          #define jit_ldxi_uc(d, rs, is)
          #define jit_ldxi_us(d, rs, is)
          #define jit_ldxr_c(d, s1, s2)
          #define jit_ldxr_d(rd, s1, s2)
          #define jit_ldxr_i(d, s1, s2)
          #define jit_ldxr_s(d, s1, s2)
          #define jit_ldxr_uc(d, s1, s2)
          #define jit_ldxr_us(d, s1, s2)
          #define jit_lei_i(d, rs, is)
          #define jit_lei_ui(d, s1, s2)
          #define jit_ler_d(d, s1, s2)
          #define jit_ler_i(d, s1, s2)
          #define jit_ler_ui(d, s1, s2)
          #define jit_lshi_i(d, rs, is)
          #define jit_lshr_i(d, r1, r2)
          #define jit_ltgtr_d(d, s1, s2)
          #define jit_lti_i(d, rs, is)
          #define jit_lti_ui(d, s1, s2)
          #define jit_ltr_d(d, s1, s2)
          #define jit_ltr_i(d, s1, s2)
          #define jit_ltr_ui(d, s1, s2)
          #define jit_modi_i(d, rs, is)
          #define jit_modi_ui(d, rs, is)
          #define jit_modr_i(d, s1, s2)
          #define jit_modr_ui(d, s1, s2)
          #define jit_movi_d(rd,immd)
          #define jit_movi_f(rd,immf)
          #define jit_movi_i(d, is)
          #define jit_movi_p(d, is)
          #define jit_movr_d(rd,rs)
          #define jit_movr_i(d, rs)
          #define jit_muli_i(d, rs, is)
          #define jit_muli_ui(d, rs, is)
          #define jit_mulr_d(rd,s1,s2)
          #define jit_mulr_i(d, s1, s2)
          #define jit_mulr_ui(d, s1, s2)
          #define jit_negr_d(rd,rs)
          #define jit_nei_i(d, rs, is)
          #define jit_ner_d(d, s1, s2)
          #define jit_ner_i(d, s1, s2)
          #define jit_nop()
          #define jit_ordr_d(d, s1, s2)
          #define jit_ori_i(d, rs, is)
          #define jit_orr_i(d, s1, s2)
          #define jit_patch_at(jump_pc, value)
          #define jit_patch_movi(jump_pc, value)
          #define jit_pop_i(rs)
          #define jit_prepare_d(numargs)
          #define jit_prepare_f(numargs)
          #define jit_prepare_i(numargs)
          #define jit_push_i(rs)
          #define jit_pusharg_i(rs)
          #define jit_ret()
          #define jit_retval_i(rd)
          #define jit_roundr_d_i(rd, rs)
          #define jit_rshi_i(d, rs, is)
          #define jit_rshi_ui(d, rs, is)
          #define jit_rshr_i(d, r1, r2)
          #define jit_rshr_ui(d, r1, r2)
          #define jit_sqrt_d(rd,rs)
          #define jit_stxi_c(rd, id, rs)
          #define jit_stxi_d(id, rd, rs)
          #define jit_stxi_f(id, rd, rs)
          #define jit_stxi_i(rd, id, rs)
          #define jit_stxi_s(rd, id, rs)
          #define jit_stxr_c(d1, d2, rs)
          #define jit_stxr_d(d1, d2, rs)
          #define jit_stxr_f(d1, d2, rs)
          #define jit_stxr_i(d1, d2, rs)
          #define jit_stxr_s(d1, d2, rs)
          #define jit_subr_d(rd,s1,s2)
          #define jit_subr_i(d, s1, s2)
          #define jit_subxi_i(d, rs, is)
          #define jit_subxr_i(d, s1, s2)
          #define jit_truncr_d_i(rd, rs)
          #define jit_uneqr_d(d, s1, s2)
          #define jit_unger_d(d, s1, s2)
          #define jit_ungtr_d(d, s1, s2)
          #define jit_unler_d(d, s1, s2)
          #define jit_unltr_d(d, s1, s2)
          #define jit_unordr_d(d, s1, s2)
          #define jit_xori_i(d, rs, is)
          #define jit_xorr_i(d, s1, s2)

Non mandatory--there should be no need to define them:
          #define jit_extr_c_ui(d, rs)
          #define jit_extr_s_ui(d, rs)
          #define jit_extr_c_ul(d, rs)
          #define jit_extr_s_ul(d, rs)
          #define jit_extr_i_ul(d, rs)
          #define jit_negr_i(d, rs)
          #define jit_negr_l(d, rs)

Non mandatory--whether to define them depends on the ABI:
          #define jit_prolog(n)
          #define jit_finish(sub)
          #define jit_finishr(reg)
          #define jit_leaf(n)
          #define jit_getarg_c(reg, ofs)
          #define jit_getarg_i(reg, ofs)
          #define jit_getarg_l(reg, ofs)
          #define jit_getarg_p(reg, ofs)
          #define jit_getarg_s(reg, ofs)
          #define jit_getarg_uc(reg, ofs)
          #define jit_getarg_ui(reg, ofs)
          #define jit_getarg_ul(reg, ofs)
          #define jit_getarg_us(reg, ofs)
          #define jit_getarg_f(reg, ofs)
          #define jit_getarg_d(reg, ofs)

Non mandatory--define them if instructions that do this exist:
          #define jit_extr_c_i(d, rs)
          #define jit_extr_s_i(d, rs)
          #define jit_extr_c_l(d, rs)
          #define jit_extr_s_l(d, rs)
          #define jit_extr_i_l(d, rs)
          #define jit_rsbi_i(d, rs, is)
          #define jit_rsbi_l(d, rs, is)

Non mandatory if condition code are always set by add/sub, needed on other systems:
          #define jit_addci_i(d, rs, is)
          #define jit_addci_l(d, rs, is)
          #define jit_subci_i(d, rs, is)
          #define jit_subci_l(d, rs, is)

Mandatory on little endian systems--don't define them on other systems:
          #define jit_ntoh_ui(d, rs)
          #define jit_ntoh_us(d, rs)

Mandatory if JIT_RZERO not defined--don't define them if it is defined:
          #define jit_ldi_c(d, is)
          #define jit_ldi_i(d, is)
          #define jit_ldi_s(d, is)
          #define jit_ldr_c(d, rs)
          #define jit_ldr_i(d, rs)
          #define jit_ldr_s(d, rs)
          #define jit_ldi_uc(d, is)
          #define jit_ldi_ui(d, is)
          #define jit_ldi_ul(d, is)
          #define jit_ldi_us(d, is)
          #define jit_ldr_uc(d, rs)
          #define jit_ldr_ui(d, rs)
          #define jit_ldr_ul(d, rs)
          #define jit_ldr_us(d, rs)
          #define jit_sti_c(id, rs)
          #define jit_sti_i(id, rs)
          #define jit_sti_s(id, rs)
          #define jit_str_c(rd, rs)
          #define jit_str_i(rd, rs)
          #define jit_str_s(rd, rs)
          #define jit_ldi_f(rd, is)
          #define jit_sti_f(id, rs)
          #define jit_ldi_d(rd, is)
          #define jit_sti_d(id, rs)
          #define jit_ldr_f(rd, rs)
          #define jit_str_f(rd, rs)
          #define jit_ldr_d(rd, rs)
          #define jit_str_d(rd, rs)

Synonyms--don't define them:
          #define jit_addi_p(d, rs, is)
          #define jit_addi_ui(d, rs, is)
          #define jit_addi_ul(d, rs, is)
          #define jit_addr_p(d, s1, s2)
          #define jit_addr_ui(d, s1, s2)
          #define jit_addr_ul(d, s1, s2)
          #define jit_andi_ui(d, rs, is)
          #define jit_andi_ul(d, rs, is)
          #define jit_andr_ui(d, s1, s2)
          #define jit_andr_ul(d, s1, s2)
          #define jit_beqi_p(label, rs, is)
          #define jit_beqi_ui(label, rs, is)
          #define jit_beqi_ul(label, rs, is)
          #define jit_beqr_p(label, s1, s2)
          #define jit_beqr_ui(label, s1, s2)
          #define jit_beqr_ul(label, s1, s2)
          #define jit_bmci_ui(label, rs, is)
          #define jit_bmci_ul(label, rs, is)
          #define jit_bmcr_ui(label, s1, s2)
          #define jit_bmcr_ul(label, s1, s2)
          #define jit_bmsi_ui(label, rs, is)
          #define jit_bmsi_ul(label, rs, is)
          #define jit_bmsr_ui(label, s1, s2)
          #define jit_bmsr_ul(label, s1, s2)
          #define jit_bgei_p(label, rs, is)
          #define jit_bger_p(label, s1, s2)
          #define jit_bgti_p(label, rs, is)
          #define jit_bgtr_p(label, s1, s2)
          #define jit_blei_p(label, rs, is)
          #define jit_bler_p(label, s1, s2)
          #define jit_blti_p(label, rs, is)
          #define jit_bltr_p(label, s1, s2)
          #define jit_bnei_p(label, rs, is)
          #define jit_bnei_ui(label, rs, is)
          #define jit_bnei_ul(label, rs, is)
          #define jit_bner_p(label, s1, s2)
          #define jit_bner_ui(label, s1, s2)
          #define jit_bner_ul(label, s1, s2)
          #define jit_eqi_p(d, rs, is)
          #define jit_eqi_ui(d, rs, is)
          #define jit_eqi_ul(d, rs, is)
          #define jit_eqr_p(d, s1, s2)
          #define jit_eqr_ui(d, s1, s2)
          #define jit_eqr_ul(d, s1, s2)
          #define jit_extr_c_s(d, rs)
          #define jit_extr_c_us(d, rs)
          #define jit_extr_uc_s(d, rs)
          #define jit_extr_uc_us(d, rs)
          #define jit_extr_uc_i(d, rs)
          #define jit_extr_uc_ui(d, rs)
          #define jit_extr_us_i(d, rs)
          #define jit_extr_us_ui(d, rs)
          #define jit_extr_uc_l(d, rs)
          #define jit_extr_uc_ul(d, rs)
          #define jit_extr_us_l(d, rs)
          #define jit_extr_us_ul(d, rs)
          #define jit_extr_ui_l(d, rs)
          #define jit_extr_ui_ul(d, rs)
          #define jit_gei_p(d, rs, is)
          #define jit_ger_p(d, s1, s2)
          #define jit_gti_p(d, rs, is)
          #define jit_gtr_p(d, s1, s2)
          #define jit_ldr_p(d, rs)
          #define jit_ldi_p(d, is)
          #define jit_ldxi_p(d, rs, is)
          #define jit_ldxr_p(d, s1, s2)
          #define jit_lei_p(d, rs, is)
          #define jit_ler_p(d, s1, s2)
          #define jit_lshi_ui(d, rs, is)
          #define jit_lshi_ul(d, rs, is)
          #define jit_lshr_ui(d, s1, s2)
          #define jit_lshr_ul(d, s1, s2)
          #define jit_lti_p(d, rs, is)
          #define jit_ltr_p(d, s1, s2)
          #define jit_movi_p(d, is)
          #define jit_movi_ui(d, rs)
          #define jit_movi_ul(d, rs)
          #define jit_movr_p(d, rs)
          #define jit_movr_ui(d, rs)
          #define jit_movr_ul(d, rs)
          #define jit_nei_p(d, rs, is)
          #define jit_nei_ui(d, rs, is)
          #define jit_nei_ul(d, rs, is)
          #define jit_ner_p(d, s1, s2)
          #define jit_ner_ui(d, s1, s2)
          #define jit_ner_ul(d, s1, s2)
          #define jit_hton_ui(d, rs)
          #define jit_hton_us(d, rs)
          #define jit_ori_ui(d, rs, is)
          #define jit_ori_ul(d, rs, is)
          #define jit_orr_ui(d, s1, s2)
          #define jit_orr_ul(d, s1, s2)
          #define jit_pop_ui(rs)
          #define jit_pop_ul(rs)
          #define jit_push_ui(rs)
          #define jit_push_ul(rs)
          #define jit_pusharg_c(rs)
          #define jit_pusharg_p(rs)
          #define jit_pusharg_s(rs)
          #define jit_pusharg_uc(rs)
          #define jit_pusharg_ui(rs)
          #define jit_pusharg_ul(rs)
          #define jit_pusharg_us(rs)
          #define jit_retval_c(rd)
          #define jit_retval_p(rd)
          #define jit_retval_s(rd)
          #define jit_retval_uc(rd)
          #define jit_retval_ui(rd)
          #define jit_retval_ul(rd)
          #define jit_retval_us(rd)
          #define jit_rsbi_p(d, rs, is)
          #define jit_rsbi_ui(d, rs, is)
          #define jit_rsbi_ul(d, rs, is)
          #define jit_rsbr_p(d, rs, is)
          #define jit_rsbr_ui(d, s1, s2)
          #define jit_rsbr_ul(d, s1, s2)
          #define jit_sti_p(d, is)
          #define jit_sti_uc(d, is)
          #define jit_sti_ui(d, is)
          #define jit_sti_ul(d, is)
          #define jit_sti_us(d, is)
          #define jit_str_p(d, rs)
          #define jit_str_uc(d, rs)
          #define jit_str_ui(d, rs)
          #define jit_str_ul(d, rs)
          #define jit_str_us(d, rs)
          #define jit_stxi_p(d, rs, is)
          #define jit_stxi_uc(d, rs, is)
          #define jit_stxi_ui(d, rs, is)
          #define jit_stxi_ul(d, rs, is)
          #define jit_stxi_us(d, rs, is)
          #define jit_stxr_p(d, s1, s2)
          #define jit_stxr_uc(d, s1, s2)
          #define jit_stxr_ui(d, s1, s2)
          #define jit_stxr_ul(d, s1, s2)
          #define jit_stxr_us(d, s1, s2)
          #define jit_subi_p(d, rs, is)
          #define jit_subi_ui(d, rs, is)
          #define jit_subi_ul(d, rs, is)
          #define jit_subr_p(d, s1, s2)
          #define jit_subr_ui(d, s1, s2)
          #define jit_subr_ul(d, s1, s2)
          #define jit_subxi_p(d, rs, is)
          #define jit_subxi_ui(d, rs, is)
          #define jit_subxi_ul(d, rs, is)
          #define jit_subxr_p(d, s1, s2)
          #define jit_subxr_ui(d, s1, s2)
          #define jit_subxr_ul(d, s1, s2)
          #define jit_xori_ui(d, rs, is)
          #define jit_xori_ul(d, rs, is)
          #define jit_xorr_ui(d, s1, s2)
          #define jit_xorr_ul(d, s1, s2)

Shortcuts--don't define them:
          #define JIT_R0
          #define JIT_R1
          #define JIT_R2
          #define JIT_V0
          #define JIT_V1
          #define JIT_V2
          #define JIT_FPR0
          #define JIT_FPR1
          #define JIT_FPR2
          #define JIT_FPR3
          #define JIT_FPR4
          #define JIT_FPR5
          #define jit_patch(jump_pc)
          #define jit_notr_c(d, rs)
          #define jit_notr_i(d, rs)
          #define jit_notr_l(d, rs)
          #define jit_notr_s(d, rs)
          #define jit_notr_uc(d, rs)
          #define jit_notr_ui(d, rs)
          #define jit_notr_ul(d, rs)
          #define jit_notr_us(d, rs)
          #define jit_rsbr_d(d, s1, s2)
          #define jit_rsbr_i(d, s1, s2)
          #define jit_rsbr_l(d, s1, s2)
          #define jit_subi_i(d, rs, is)
          #define jit_subi_l(d, rs, is)

Mandatory unless target arithmetic is always done in the same precision:
          #define jit_abs_f(rd,rs)
          #define jit_addr_f(rd,s1,s2)
          #define jit_beqr_f(label, s1, s2)
          #define jit_bger_f(label, s1, s2)
          #define jit_bgtr_f(label, s1, s2)
          #define jit_bler_f(label, s1, s2)
          #define jit_bltgtr_f(label, s1, s2)
          #define jit_bltr_f(label, s1, s2)
          #define jit_bner_f(label, s1, s2)
          #define jit_bordr_f(label, s1, s2)
          #define jit_buneqr_f(label, s1, s2)
          #define jit_bunger_f(label, s1, s2)
          #define jit_bungtr_f(label, s1, s2)
          #define jit_bunler_f(label, s1, s2)
          #define jit_bunltr_f(label, s1, s2)
          #define jit_bunordr_f(label, s1, s2)
          #define jit_ceilr_f_i(rd, rs)
          #define jit_divr_f(rd,s1,s2)
          #define jit_eqr_f(d, s1, s2)
          #define jit_extr_d_f(rs, rd)
          #define jit_extr_f_d(rs, rd)
          #define jit_extr_i_f(rd, rs)
          #define jit_floorr_f_i(rd, rs)
          #define jit_ger_f(d, s1, s2)
          #define jit_gtr_f(d, s1, s2)
          #define jit_ler_f(d, s1, s2)
          #define jit_ltgtr_f(d, s1, s2)
          #define jit_ltr_f(d, s1, s2)
          #define jit_movr_f(rd,rs)
          #define jit_mulr_f(rd,s1,s2)
          #define jit_negr_f(rd,rs)
          #define jit_ner_f(d, s1, s2)
          #define jit_ordr_f(d, s1, s2)
          #define jit_roundr_f_i(rd, rs)
          #define jit_rsbr_f(d, s1, s2)
          #define jit_sqrt_f(rd,rs)
          #define jit_subr_f(rd,s1,s2)
          #define jit_truncr_f_i(rd, rs)
          #define jit_uneqr_f(d, s1, s2)
          #define jit_unger_f(d, s1, s2)
          #define jit_ungtr_f(d, s1, s2)
          #define jit_unler_f(d, s1, s2)
          #define jit_unltr_f(d, s1, s2)
          #define jit_unordr_f(d, s1, s2)

Mandatory if sizeof(long) != sizeof(int)--don't define them on other systems:
          #define jit_addi_l(d, rs, is)
          #define jit_addr_l(d, s1, s2)
          #define jit_andi_l(d, rs, is)
          #define jit_andr_l(d, s1, s2)
          #define jit_beqi_l(label, rs, is)
          #define jit_beqr_l(label, s1, s2)
          #define jit_bgei_l(label, rs, is)
          #define jit_bgei_ul(label, rs, is)
          #define jit_bger_l(label, s1, s2)
          #define jit_bger_ul(label, s1, s2)
          #define jit_bgti_l(label, rs, is)
          #define jit_bgti_ul(label, rs, is)
          #define jit_bgtr_l(label, s1, s2)
          #define jit_bgtr_ul(label, s1, s2)
          #define jit_blei_l(label, rs, is)
          #define jit_blei_ul(label, rs, is)
          #define jit_bler_l(label, s1, s2)
          #define jit_bler_ul(label, s1, s2)
          #define jit_blti_l(label, rs, is)
          #define jit_blti_ul(label, rs, is)
          #define jit_bltr_l(label, s1, s2)
          #define jit_bltr_ul(label, s1, s2)
          #define jit_bosubi_l(label, rs, is)
          #define jit_bosubi_ul(label, rs, is)
          #define jit_bosubr_l(label, s1, s2)
          #define jit_bosubr_ul(label, s1, s2)
          #define jit_boaddi_l(label, rs, is)
          #define jit_boaddi_ul(label, rs, is)
          #define jit_boaddr_l(label, s1, s2)
          #define jit_boaddr_ul(label, s1, s2)
          #define jit_bmci_l(label, rs, is)
          #define jit_bmcr_l(label, s1, s2)
          #define jit_bmsi_l(label, rs, is)
          #define jit_bmsr_l(label, s1, s2)
          #define jit_bnei_l(label, rs, is)
          #define jit_bner_l(label, s1, s2)
          #define jit_divi_l(d, rs, is)
          #define jit_divi_ul(d, rs, is)
          #define jit_divr_l(d, s1, s2)
          #define jit_divr_ul(d, s1, s2)
          #define jit_eqi_l(d, rs, is)
          #define jit_eqr_l(d, s1, s2)
          #define jit_extr_c_l(d, rs)
          #define jit_extr_c_ul(d, rs)
          #define jit_extr_s_l(d, rs)
          #define jit_extr_s_ul(d, rs)
          #define jit_extr_i_l(d, rs)
          #define jit_extr_i_ul(d, rs)
          #define jit_gei_l(d, rs, is)
          #define jit_gei_ul(d, rs, is)
          #define jit_ger_l(d, s1, s2)
          #define jit_ger_ul(d, s1, s2)
          #define jit_gti_l(d, rs, is)
          #define jit_gti_ul(d, rs, is)
          #define jit_gtr_l(d, s1, s2)
          #define jit_gtr_ul(d, s1, s2)
          #define jit_hmuli_l(d, rs, is)
          #define jit_hmuli_ul(d, rs, is)
          #define jit_hmulr_l(d, s1, s2)
          #define jit_hmulr_ul(d, s1, s2)
          #define jit_ldi_l(d, is)
          #define jit_ldi_ui(d, is)
          #define jit_ldr_l(d, rs)
          #define jit_ldr_ui(d, rs)
          #define jit_ldxi_l(d, rs, is)
          #define jit_ldxi_ui(d, rs, is)
          #define jit_ldxi_ul(d, rs, is)
          #define jit_ldxr_l(d, s1, s2)
          #define jit_ldxr_ui(d, s1, s2)
          #define jit_ldxr_ul(d, s1, s2)
          #define jit_lei_l(d, rs, is)
          #define jit_lei_ul(d, rs, is)
          #define jit_ler_l(d, s1, s2)
          #define jit_ler_ul(d, s1, s2)
          #define jit_lshi_l(d, rs, is)
          #define jit_lshr_l(d, s1, s2)
          #define jit_lti_l(d, rs, is)
          #define jit_lti_ul(d, rs, is)
          #define jit_ltr_l(d, s1, s2)
          #define jit_ltr_ul(d, s1, s2)
          #define jit_modi_l(d, rs, is)
          #define jit_modi_ul(d, rs, is)
          #define jit_modr_l(d, s1, s2)
          #define jit_modr_ul(d, s1, s2)
          #define jit_movi_l(d, rs)
          #define jit_movr_l(d, rs)
          #define jit_muli_l(d, rs, is)
          #define jit_muli_ul(d, rs, is)
          #define jit_mulr_l(d, s1, s2)
          #define jit_mulr_ul(d, s1, s2)
          #define jit_nei_l(d, rs, is)
          #define jit_ner_l(d, s1, s2)
          #define jit_ori_l(d, rs, is)
          #define jit_orr_l(d, s1, s2)
          #define jit_pop_l(rs)
          #define jit_push_l(rs)
          #define jit_pusharg_l(rs)
          #define jit_retval_l(rd)
          #define jit_rshi_l(d, rs, is)
          #define jit_rshi_ul(d, rs, is)
          #define jit_rshr_l(d, s1, s2)
          #define jit_rshr_ul(d, s1, s2)
          #define jit_sti_l(d, is)
          #define jit_str_l(d, rs)
          #define jit_stxi_l(d, rs, is)
          #define jit_stxr_l(d, s1, s2)
          #define jit_subr_l(d, s1, s2)
          #define jit_xori_l(d, rs, is)
          #define jit_xorr_l(d, s1, s2)


File: lightning.info,  Node: Standard functions,  Next: Floating-point macros,  Prev: Standard macros,  Up: Porting GNU lightning

More complex tasks in the platform-independent layer
====================================================

   There is actually a single function that you *must* define in the
`funcs-SUFFIX.h' file, that is, `jit_flush_code'.

   As explained in *Note Generating code at run-time: GNU lightning
macros, its purpose is to flush part of the processor's instruction
cache (usually the part of memory that contains the generated code),
avoiding the processor executing bogus data that it happens to find in
the cache.  The `jit_flush_code' function takes the first and the last
address to flush.

   On many processors (for example, the x86 and the all the processors
in the 68k family up to the 68030), it is not even necessary to flush
the cache.  In this case, the contents of the file will simply be

     #ifndef __lightning_funcs_h
     #define __lightning_funcs_h
     
     #define jit_flush_code(dest, end)
     
     #endif /* __lightning_core_h */

   On other processors, flushing the cache is necessary for proper
behavior of the program; in this case, the file will contain a proper
definition of the function.  However, we must make yet another
distinction.

   On some processors, flushing the cache is obtained through a call to
the operating system or to the C run-time library.  In this case, the
definition of `jit_flush_code' will be very simple: two examples are
the Alpha and the 68040. For the Alpha the code will be:
     #define jit_flush_code(dest, end) \
             __asm__ __volatile__("call_pal 0x86");

and, for the Motorola
     #define jit_flush_code(start, end) \
             __clear_cache((start), (end))

   As you can see, the Alpha does not even need to pass the start and
end address to the function.  It is good practice to protect usage of
the GNU CC-specific `__asm__' directive by relying on the preprocessor.
For example:

     #if !defined(__GNUC__) && !defined(__GNUG__)
     #error Go get GNU C, I do not know how to flush the cache
     #error with this compiler.
     #else
     #define jit_flush_code(dest, end) \
             __asm__ __volatile__("call_pal 0x86");
     #endif

   GNU lightning's configuration process tries to compile a dummy file
that includes `lightning.h', and gives a warning if there are problem
with the compiler that is installed on the system.

   In more complex cases, you'll need to write a full-fledged function.
Don't forget to make it `static', otherwise you'll have problems
linking programs that include `lightning.h' multiple times. An example,
taken from the `funcs-ppc.h' file, is:

     #ifndef __lightning_funcs_h
     #define __lightning_funcs_h
     
     #if !defined(__GNUC__) && !defined(__GNUG__)
     #error Go get GNU C, I do not know how to flush the cache
     #error with this compiler.
     #else
     static void
     jit_flush_code(start, end)
          void       *start;
          void       *end;
     {
       register char *dest = start;
     
       for (; dest <= end; dest += SIZEOF_CHAR_P)
         __asm__ __volatile__
           ("dcbst 0,%0; sync; icbi 0,%0; isync"::"r"(dest));
     }
     #endif
     
     #endif /* __lightning_funcs_h */

   The `funcs-SUFFIX.h' file is also the right place to put helper
functions that do complex tasks for the `core-SUFFIX.h' file.  For
example, the PowerPC assembler defines `jit_prolog' as a function and
puts it in that file (for more information, *note Implementing the
ABI::).  Take special care when defining such a function, as explained
in *Note Reentrant usage of GNU lightning: Reentrancy.


File: lightning.info,  Node: Floating-point macros,  Prev: Standard functions,  Up: Porting GNU lightning

Implementing macros for floating point
======================================


File: lightning.info,  Node: Future,  Next: Acknowledgements,  Prev: Porting GNU lightning,  Up: Top

The future of GNU lightning
***************************

   Presented below is the set of tasks that I feel need to be performed
to make GNU lightning a more fully functional, viable system.  They are
presented in no particular order.  I would _very much_ welcome any
volunteers who would like to help with the implementation of one or
more of these tasks.  Please write to me, Paolo Bonzini, at
<bonzini@gnu.org> if you are interested in adding your efforts to the
GNU lightning project.

   Tasks:
   * The most important task to make GNU lightning more widely usable
     is to retarget it.  Although currently supported architectures
     (x86, SPARC, PowerPC) are certainly some of the most widely used,
     GNU lightning could be ported to others--namely, the Alpha and
     MIPS architectures.

   * Another interesting task is to allow the instruction stream to grow
     dynamically.  This is a problem because not all architectures allow
     to write position independent code.(1)

   * Optimize leaf procedures on the SPARC.  This involves using the
     output registers (`%oX') instead of the local registers (`%lX')
     when writing leaf procedures;  the problem is, leaf procedures
     also receive parameters in the output registers, so they would be
     overwritten by write accesses to general-purpose registers.

   ---------- Footnotes ----------

   (1) The x86's absolute jumps, for example, are actually slow
indirect jumps, and need a register.


File: lightning.info,  Node: Acknowledgements,  Prev: Future,  Up: Top

Acknowledgements
****************

   As far as I know, the first general-purpose portable dynamic code
generator is DCG, by Dawson R. Engler and T. A. Proebsting.  Further
work by Dawson R. Engler resulted in the VCODE system; unlike DCG,
VCODE used no intermediate representation and directly inspired GNU
lightning.

   Thanks go to Ian Piumarta, who kindly accepted to release his own
program CCG under the GNU General Public License, thereby allowing GNU
lightning to use the run-time assemblers he had wrote for CCG.  CCG
provides a way of dynamically assemble programs written in the
underlying architecture's assembly language.  So it is not portable,
yet very interesting.

   I also thank Steve Byrne for writing GNU Smalltalk, since GNU
lightning was first developed as a tool to be used in GNU Smalltalk's
dynamic translator from bytecodes to native code.


